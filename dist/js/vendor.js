!function(global, factory) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    } : factory(global);
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    "use strict";
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement("script");
        script.text = code, doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        return "function" === type || jQuery.isWindow(obj) ? !1 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function winnow(elements, qualifier, not) {
        return jQuery.isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        }) : risSimple.test(qualifier) ? jQuery.filter(qualifier, elements, not) : (qualifier = jQuery.filter(qualifier, elements), 
        jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && 1 === elem.nodeType;
        }));
    }
    function sibling(cur, dir) {
        for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
        return cur;
    }
    function createOptions(options) {
        var object = {};
        return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = !0;
        }), object;
    }
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject) {
        var method;
        try {
            value && jQuery.isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && jQuery.isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.call(void 0, value);
        } catch (value) {
            reject.call(void 0, value);
        }
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), 
        jQuery.ready();
    }
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    function getData(data) {
        return "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data;
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), 
        data = elem.getAttribute(name), "string" == typeof data) {
            try {
                data = getData(data);
            } catch (e) {}
            dataUser.set(elem, key, data);
        } else data = void 0;
        return data;
    }
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3], valueParts = valueParts || [], initialInUnit = +initial || 1;
            do scale = scale || ".5", initialInUnit /= scale, jQuery.style(elem, prop, initialInUnit + unit); while (scale !== (scale = currentValue() / initial) && 1 !== scale && --maxIterations);
        }
        return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], 
        tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), 
        adjusted;
    }
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        return display ? display : (temp = doc.body.appendChild(doc.createElement(nodeName)), 
        display = jQuery.css(temp, "display"), temp.parentNode.removeChild(temp), "none" === display && (display = "block"), 
        defaultDisplayMap[nodeName] = display, display);
    }
    function showHide(elements, show) {
        for (var display, elem, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index], 
        elem.style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, 
        values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", 
        dataPriv.set(elem, "display", display)));
        for (index = 0; length > index; index++) null != values[index] && (elements[index].style.display = values[index]);
        return elements;
    }
    function getAll(context, tag) {
        var ret;
        return ret = "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : "undefined" != typeof context.querySelectorAll ? context.querySelectorAll(tag || "*") : [], 
        void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; l > i; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    function buildFragment(elems, context, scripts, selection, ignored) {
        for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++) if (elem = elems[i], 
        elem || 0 === elem) if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], 
            j = wrap[0]; j--; ) tmp = tmp.lastChild;
            jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        } else nodes.push(context.createTextNode(elem));
        for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem); else if (contains = jQuery.contains(elem.ownerDocument, elem), 
        tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
        scripts) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
        return fragment;
    }
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if ("object" == typeof types) {
            "string" != typeof selector && (data = data || selector, selector = void 0);
            for (type in types) on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, 
        data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn) return elem;
        return 1 === one && (origFn = fn, fn = function(event) {
            return jQuery().off(event), origFn.apply(this, arguments);
        }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem : elem;
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld), 
            events = pdataOld.events)) {
                delete pdataCur.handle, pdataCur.events = {};
                for (type in events) for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i]);
            }
            dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), 
            dataUser.set(dest, udataCur));
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue);
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            isFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored);
        });
        if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored), 
        first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
        first || ignored)) {
            for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment, 
            i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
            callback.call(collection[i], node, i);
            if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
            i = 0; hasScripts > i; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc));
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), 
        node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")), 
        node.parentNode.removeChild(node));
        return elem;
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name], 
        "" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
        !support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, 
        minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
        ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
        void 0 !== ret ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    function vendorPropName(name) {
        if (name in emptyStyle) return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; ) if (name = cssPrefixes[i] + capName, 
        name in emptyStyle) return name;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        for (i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0; 4 > i; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
        isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
        "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
        "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var val, valueIsBorderBox = !0, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        if (elem.getClientRects().length && (val = elem.getBoundingClientRect()[name]), 
        0 >= val || null == val) {
            if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), 
            rnumnonpx.test(val)) return val;
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    function raf() {
        timerId && (window.requestAnimationFrame(raf), jQuery.fx.tick());
    }
    function createFxNow() {
        return window.setTimeout(function() {
            fxNow = void 0;
        }), fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        for (includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth) which = cssExpand[i], 
        attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs;
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; length > index; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
        oldfire = hooks.empty.fire, hooks.empty.fire = function() {
            hooks.unqueued || oldfire();
        }), hooks.unqueued++, anim.always(function() {
            anim.always(function() {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
            });
        }));
        for (prop in props) if (value = props[prop], rfxtypes.test(value)) {
            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                hidden = !0;
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
        if (propTween = !jQuery.isEmptyObject(props), propTween || !jQuery.isEmptyObject(orig)) {
            isBox && 1 === elem.nodeType && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], 
            restoreDisplay = dataShow && dataShow.display, null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")), 
            display = jQuery.css(elem, "display"), "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([ elem ], !0), 
            restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), 
            showHide([ elem ]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                style.display = restoreDisplay;
            }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), 
            style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function() {
                style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
            })), propTween = !1;
            for (prop in orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
            }), toggle && (dataShow.hidden = !hidden), hidden && showHide([ elem ], !0), anim.done(function() {
                hidden || showHide([ elem ]), dataPriv.remove(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop, orig[prop]);
            })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, 
            hidden && (propTween.end = propTween.start, propTween.start = 0));
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
        value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
        index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], 
        hooks && "expand" in hooks) {
            value = hooks.expand(value), delete props[name];
            for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
        } else specialEasing[name] = easing;
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [ animation, percent, remaining ]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [ animation ]), 
            !1);
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
                return gotoEnd ? (deferred.notifyWith(elem, [ animation, 1, 0 ]), deferred.resolveWith(elem, [ animation, gotoEnd ])) : deferred.rejectWith(elem, [ animation, gotoEnd ]), 
                this;
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); length > index; index++) if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return jQuery.isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)), 
        result;
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
            traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add);
        }); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", 
            (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), 
                inspect(dataTypeOrTransport), !1);
            }), selected;
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
        void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
        }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                firstDataType || (firstDataType = type);
            }
            finalDataType = finalDataType || firstDataType;
        }
        return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
        responses[finalDataType]) : void 0;
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
        !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
        prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
            if (conv = converters[prev + " " + current] || converters["* " + current], !conv) for (conv2 in converters) if (tmp = conv2.split(" "), 
            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], 
                dataTypes.unshift(tmp[1]));
                break;
            }
            if (conv !== !0) if (conv && s["throws"]) response = conv(response); else try {
                response = conv(response);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                };
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView;
    }
    var arr = [], document = window.document, getProto = Object.getPrototypeOf, slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, fnToString = hasOwn.toString, ObjectFunctionString = fnToString.call(Object), support = {}, version = "3.1.1", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return null == num ? slice.call(this) : 0 > num ? this[num + this.length] : this[num];
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this, ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (0 > i ? len : 0);
            return this.pushStack(j >= 0 && len > j ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    }, jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, 
        i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, 
        i--); length > i; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
        copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
        clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, 
        target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target;
    }, jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return "function" === jQuery.type(obj);
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return null != obj && obj === obj.window;
        },
        isNumeric: function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            return obj && "[object Object]" === toString.call(obj) ? (proto = getProto(obj)) ? (Ctor = hasOwn.call(proto, "constructor") && proto.constructor, 
            "function" == typeof Ctor && fnToString.call(Ctor) === ObjectFunctionString) : !0 : !1;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return !1;
            return !0;
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            DOMEval(code);
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) for (length = obj.length; length > i && callback.call(obj[i], i, obj[i]) !== !1; i++) ; else for (i in obj) if (callback.call(obj[i], i, obj[i]) === !1) break;
            return obj;
        },
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)), 
            ret;
        },
        inArray: function(elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; len > j; j++) first[i++] = second[j];
            return first.length = i, first;
        },
        grep: function(elems, callback, invert) {
            for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++) callbackInverse = !callback(elems[i], i), 
            callbackInverse !== callbackExpect && matches.push(elems[i]);
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) for (length = elems.length; length > i; i++) value = callback(elems[i], i, arg), 
            null != value && ret.push(value); else for (i in elems) value = callback(elems[i], i, arg), 
            null != value && ret.push(value);
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), 
            jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0;
        },
        now: Date.now,
        support: support
    }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), 
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    var Sizzle = function(window) {
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
            if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), 
            context = context || document, documentIsHTML)) {
                if (11 !== nodeType && (match = rquickExpr.exec(selector))) if (m = match[1]) {
                    if (9 === nodeType) {
                        if (!(elem = context.getElementById(m))) return results;
                        if (elem.id === m) return results.push(elem), results;
                    } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
                    results;
                } else {
                    if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
                    results;
                    if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
                    results;
                }
                if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (1 !== nodeType) newContext = context, newSelector = selector; else if ("object" !== context.nodeName.toLowerCase()) {
                        for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando), 
                        groups = tokenize(selector), i = groups.length; i--; ) groups[i] = "#" + nid + " " + toSelector(groups[i]);
                        newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                    } catch (qsaError) {} finally {
                        nid === expando && context.removeAttribute("id");
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
            }
            var keys = [];
            return cache;
        }
        function markFunction(fn) {
            return fn[expando] = !0, fn;
        }
        function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return !1;
            } finally {
                el.parentNode && el.parentNode.removeChild(el), el = null;
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = arr.length; i--; ) Expr.attrHandle[arr[i]] = handler;
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
            if (diff) return diff;
            if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function(elem) {
                return "form" in elem ? elem.parentNode && elem.disabled === !1 ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label" in elem ? elem.disabled === disabled : !1;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                });
            });
        }
        function testContext(context) {
            return context && "undefined" != typeof context.getElementsByTagName && context;
        }
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && "parentNode" === key, doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
                return !1;
            } : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) if (outerCache = elem[expando] || (elem[expando] = {}), 
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem; else {
                    if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                    if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                }
                return !1;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                return !0;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++) (elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), 
            mapped && map.push(i));
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
                postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), 
                postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
            });
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                return checkContext = null, ret;
            } ]; len > i; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                    for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++) ;
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                        value: " " === tokens[i - 2].type ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++]; ) if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        outermost && (dirruns = dirrunsUnique);
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                }
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
                unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0), 0;
        }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            for (var i = 0, len = list.length; len > i; i++) if (list[i] === elem) return i;
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            return asCodePoint ? "\x00" === ch ? "" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch;
        }, unloadHandler = function() {
            setDocument();
        }, disabledAncestor = addCombinator(function(elem) {
            return elem.disabled === !0 && ("form" in elem || "label" in elem);
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                    target.length = j - 1;
                }
            };
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1;
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
            docElem = document.documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), 
            support.attributes = assert(function(el) {
                return el.className = "i", !el.getAttribute("className");
            }), support.getElementsByTagName = assert(function(el) {
                return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length;
            }), support.getElementsByClassName = rnative.test(document.getElementsByClassName), 
            support.getById = assert(function(el) {
                return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length;
            }), support.getById ? (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [ elem ] : [];
                }
            }) : (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var node, i, elems, elem = context.getElementById(id);
                    if (elem) {
                        if (node = elem.getAttributeNode("id"), node && node.value === id) return [ elem ];
                        for (elems = context.getElementsByName(id), i = 0; elem = elems[i++]; ) if (node = elem.getAttributeNode("id"), 
                        node && node.value === id) return [ elem ];
                    }
                    return [];
                }
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0;
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                    return tmp;
                }
                return results;
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                return "undefined" != typeof context.getElementsByClassName && documentIsHTML ? context.getElementsByClassName(className) : void 0;
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
                el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
                el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
                el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), 
                el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
            }), assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document.createElement("input");
                input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), 
                el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
                2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), 
                rbuggyMatches.push("!=", pseudos);
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
            hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1);
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                for (;ap[i] === bp[i]; ) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }, document) : document;
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
            support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
            } catch (e) {}
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), 
            contains(context, elem);
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }, Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
            results.sort(sortOrder), hasDuplicate) {
                for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                for (;j--; ) results.splice(duplicates[j], 1);
            }
            return sortInput = null, results;
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
            } else for (;node = elem[i++]; ) ret += getText(node);
            return ret;
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
                    "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), 
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), 
                    match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
                    match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                        if (parent) {
                            if (simple) {
                                for (;dir; ) {
                                    for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling";
                                }
                                return !0;
                            }
                            if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                for (node = parent, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), 
                                cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex && cache[2], 
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                    uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            } else if (useCache && (node = elem, outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [], 
                            nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex), diff === !1) for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), uniqueCache[type] = [ dirruns, diff ]), 
                            node !== elem)); ) ;
                            return diff -= last, diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]), 
                        seed[idx] = !(matches[idx] = matched[i]);
                    }) : function(elem) {
                        return fn(elem, 0, args);
                    }) : fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return text = text.replace(runescape, funescape), function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
                    lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), 
                        elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: createDisabledPseudo(!1),
                disabled: createDisabledPseudo(!0),
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name;
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ 0 > argument ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; --i >= 0; ) matchIndexes.push(i);
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
            submit: !0,
            reset: !0
        }) Expr.pseudos[i] = createButtonPseudo(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), 
                groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break;
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
                cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
                cached.selector = selector;
            }
            return cached;
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], 
                    !context) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], 
                !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                    if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), 
                    results;
                    break;
                }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), 
            results;
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
        support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(el) {
            return 1 & el.compareDocumentPosition(document.createElement("fieldset"));
        }), assert(function(el) {
            return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href");
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
        }), support.attributes && assert(function(el) {
            return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value");
        }) || addHandle("value", function(elem, name, isXML) {
            return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue;
        }), assert(function(el) {
            return null == el.getAttribute("disabled");
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }), Sizzle;
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, 
    jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    }, siblings = function(n, elem) {
        for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
        return matched;
    }, rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType;
        }));
    }, jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; len > i; i++) if (jQuery.contains(self[i], this)) return !0;
            }));
            for (ret = this.pushStack([]), i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0));
        },
        is: function(selector) {
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) return this;
        if (root = root || rootjQuery, "string" == typeof selector) {
            if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector), 
            !match || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), 
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this;
            }
            return elem = document.getElementById(match[2]), elem && (this[0] = elem, this.length = 1), 
            this;
        }
        return selector.nodeType ? (this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn, rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                for (var i = 0; l > i; i++) if (jQuery.contains(this, targets[i])) return !0;
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
            if (!rneedsContext.test(selectors)) for (;l > i; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }
    }), jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 
            this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), 
            this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    jQuery.Callbacks = function(options) {
        options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            for (locked = options.once, fired = firing = !0; queue.length; firingIndex = -1) for (memory = queue.shift(); ++firingIndex < list.length; ) list[firingIndex].apply(memory[0], memory[1]) === !1 && options.stopOnFalse && (firingIndex = list.length, 
            memory = !1);
            options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "");
        }, self = {
            add: function() {
                return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), 
                function add(args) {
                    jQuery.each(args, function(_, arg) {
                        jQuery.isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== jQuery.type(arg) && add(arg);
                    });
                }(arguments), memory && !firing && fire()), this;
            },
            remove: function() {
                return jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
                    firingIndex >= index && firingIndex--;
                }), this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
                return list && (list = []), this;
            },
            disable: function() {
                return locked = queue = [], list = memory = "", this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                return locked = queue = [], memory || firing || (list = memory = ""), this;
            },
            locked: function() {
                return !!locked;
            },
            fireWith: function(context, args) {
                return locked || (args = args || [], args = [ context, args.slice ? args.slice() : args ], 
                queue.push(args), firing || fire()), this;
            },
            fire: function() {
                return self.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    }, jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2 ], [ "resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected" ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments), this;
                },
                "catch": function(fn) {
                    return promise.then(null, fn);
                },
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [ returned ] : arguments);
                            });
                        }), fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                if (!(maxDepth > depth)) {
                                    if (returned = handler.apply(that, args), returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                    then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, 
                                    jQuery.isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, 
                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, 
                                    args = [ returned ]), (special || deferred.resolveWith)(that, args));
                                }
                            }, process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), 
                                    depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [ e ]), 
                                    deferred.rejectWith(that, args));
                                }
                            };
                            depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), 
                            window.setTimeout(process));
                        };
                    }
                    var maxDepth = 0;
                    return jQuery.Deferred(function(newDefer) {
                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), 
                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)), 
                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            return jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add, stateString && list.add(function() {
                    state = stateString;
                }, tuples[3 - i][2].disable, tuples[0][2].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), 
                    this;
                }, deferred[tuple[0] + "With"] = list.fireWith;
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
        },
        when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value, 
                    --remaining || master.resolveWith(resolveContexts, resolveValues);
                };
            };
            if (1 >= remaining && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject), 
            "pending" === master.state() || jQuery.isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
            for (;i--; ) adoptValue(resolveValues[i], updateFunc(i), master.reject);
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }, jQuery.readyException = function(error) {
        window.setTimeout(function() {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        return readyList.then(fn)["catch"](function(error) {
            jQuery.readyException(error);
        }), this;
    }, jQuery.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0);
        },
        ready: function(wait) {
            (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || readyList.resolveWith(document, [ jQuery ]));
        }
    }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), 
    window.addEventListener("load", completed));
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key) access(elems, fn, i, key[i], !0, emptyGet, raw);
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
        bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
        })), fn)) for (;len > i; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    }, acceptData = function(owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
    };
    Data.uid = 1, Data.prototype = {
        cache: function(owner) {
            var value = owner[this.expando];
            return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: !0
            }))), value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if ("string" == typeof data) cache[jQuery.camelCase(data)] = value; else for (prop in data) cache[jQuery.camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function(owner, key, value) {
            return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), 
            void 0 !== value ? value : key);
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (void 0 !== cache) {
                if (void 0 !== key) {
                    jQuery.isArray(key) ? key = key.map(jQuery.camelCase) : (key = jQuery.camelCase(key), 
                    key = key in cache ? [ key ] : key.match(rnothtmlwhite) || []), i = key.length;
                    for (;i--; ) delete cache[key[i]];
                }
                (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando]);
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return void 0 !== cache && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data(), dataUser = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    }), jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
                    dataAttr(elem, name, data[name])));
                    dataPriv.set(elem, "hasDataAttrs", !0);
                }
                return data;
            }
            return "object" == typeof key ? this.each(function() {
                dataUser.set(this, key);
            }) : access(this, function(value) {
                var data;
                if (elem && void 0 === value) {
                    if (data = dataUser.get(elem, key), void 0 !== data) return data;
                    if (data = dataAttr(elem, key), void 0 !== data) return data;
                } else this.each(function() {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, !0);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    }), jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            return elem ? (type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), 
            data && (!queue || jQuery.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), 
            queue || []) : void 0;
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), 
            delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    }), jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [ elements ]);
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) tmp = dataPriv.get(elements[i], type + "queueHooks"), 
            tmp && tmp.empty && (count++, tmp.empty.add(resolve));
            return resolve(), defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHiddenWithinTree = function(elem, el) {
        return elem = el || elem, "none" === elem.style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display");
    }, swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options) elem.style[name] = old[name];
        return ret;
    }, defaultDisplayMap = {};
    jQuery.fn.extend({
        show: function() {
            return showHide(this, !0);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i, rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, rscriptType = /^$|\/(?:java|ecma)script/i, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var rhtml = /<|&#?\w+;/;
    !function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), 
        div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
    }();
    var documentElement = document.documentElement, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, 
            selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), 
            handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), 
            (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                return "undefined" != typeof jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            }), types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
            type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
            type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, 
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
            }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
            special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle)), 
            special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
            selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), 
            jQuery.event.global[type] = !0);
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [], 
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                    for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, 
                    handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
                    handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                    origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), 
                    delete events[type]);
                } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
            if (event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
                j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) && (event.handleObj = handleObj, 
                event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), 
                void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event), event.result;
            }
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1)) for (;cur !== this; cur = cur.parentNode || this) if (1 === cur.nodeType && ("click" !== event.type || cur.disabled !== !0)) {
                for (matchedHandlers = [], matchedSelectors = {}, i = 0; delegateCount > i; i++) handleObj = handlers[i], 
                sel = handleObj.selector + " ", void 0 === matchedSelectors[sel] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length), 
                matchedSelectors[sel] && matchedHandlers.push(handleObj);
                matchedHandlers.length && handlerQueue.push({
                    elem: cur,
                    handlers: matchedHandlers
                });
            }
            return cur = this, delegateCount < handlers.length && handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            }), handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: !0,
                configurable: !0,
                get: jQuery.isFunction(hook) ? function() {
                    return this.originalEvent ? hook(this.originalEvent) : void 0;
                } : function() {
                    return this.originalEvent ? this.originalEvent[name] : void 0;
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                }
            }
        }
    }, jQuery.removeEvent = function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle);
    }, jQuery.Event = function(src, props) {
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
        this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse, 
        this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, 
        this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, 
        props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
        void (this[jQuery.expando] = !0)) : new jQuery.Event(src, props);
    }, jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, jQuery.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        "char": !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(event) {
            var button = event.button;
            return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which;
        }
    }, jQuery.event.addProp), jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, 
                ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
            }
        };
    }), jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, 
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), 
            this;
            if ("object" == typeof types) {
                for (type in types) this.off(type, selector, types[type]);
                return this;
            }
            return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), 
            fn === !1 && (fn = returnFalse), this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone), 
            srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++) fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
            destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
            clone;
        },
        cleanData: function(elems) {
            for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                    elem[dataPriv.expando] = void 0;
                }
                elem[dataUser.expando] && (elem[dataUser.expando] = void 0);
            }
        }
    }), jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, !0);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value);
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
            elem.textContent = "");
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, 
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (;l > i; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
                        elem.innerHTML = value);
                        elem = 0;
                    } catch (e) {}
                }
                elem && this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this));
            }, ignored);
        }
    }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++) elems = i === last ? this : this.clone(!0), 
            jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        return view && view.opener || (view = window), view.getComputedStyle(elem);
    };
    !function() {
        function computeStyleTests() {
            if (div) {
                div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", 
                div.innerHTML = "", documentElement.appendChild(container);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = "2px" === divStyle.marginLeft, 
                boxSizingReliableVal = "4px" === divStyle.width, div.style.marginRight = "50%", 
                pixelMarginRightVal = "4px" === divStyle.marginRight, documentElement.removeChild(container), 
                div = null;
            }
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
        support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", 
        container.appendChild(div), jQuery.extend(support, {
            pixelPosition: function() {
                return computeStyleTests(), pixelPositionVal;
            },
            boxSizingReliable: function() {
                return computeStyleTests(), boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                return computeStyleTests(), pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                return computeStyleTests(), reliableMarginLeftVal;
            }
        }));
    }();
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), 
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, 
                "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), 
                type = "number"), null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), 
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
                hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), 
                void 0);
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), 
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), 
            void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
            "" === extra || extra ? (num = parseFloat(val), extra === !0 || isFinite(num) ? num || 0 : val) : val;
        }
    }), jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                return computed ? !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, name, extra) : swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                }) : void 0;
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles);
                return subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[name] = value, 
                value = jQuery.css(elem, name)), setPositiveNumber(elem, value, subtract);
            }
        };
    }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        return computed ? (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px" : void 0;
    }), jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [ value ]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
    }), jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map;
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    }), jQuery.Tween = Tween, Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, 
            this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, 
            this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
        }
    }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""), 
                result && "auto" !== result ? result : 0);
            },
            set: function(tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            }
        }
    }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
        }
    }, jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [ function(prop, value) {
                var tween = this.createTween(prop, value);
                return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween;
            } ]
        },
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.match(rnothtmlwhite);
            for (var prop, index = 0, length = props.length; length > index; index++) prop = props[index], 
            Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback);
        },
        prefilters: [ defaultPrefilter ],
        prefilter: function(callback, prepend) {
            prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback);
        }
    }), jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        return jQuery.fx.off || document.hidden ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default), 
        (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, 
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
        }, opt;
    }, jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || dataPriv.get(this, "finish")) && anim.stop(!0);
            };
            return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd);
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
            clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function() {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
                dequeue = !1, timers.splice(index, 1));
                (dequeue || !gotoEnd) && jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            return type !== !1 && (type = type || "fx"), this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
                index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
                timers.splice(index, 1));
                for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish;
            });
        }
    }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
        };
    }), jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    }), jQuery.timers = [], jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0;
    }, jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop();
    }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
        timerId || (timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval));
    }, jQuery.fx.stop = function() {
        window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : window.clearInterval(timerId), 
        timerId = null;
    }, jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", 
        this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    }, function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, 
        input = document.createElement("input"), input.value = "t", input.type = "radio", 
        support.radioValue = "t" === input.value;
    }();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    }), jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return "undefined" == typeof elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), 
            void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), 
            value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), 
            null == ret ? void 0 : ret));
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) elem.removeAttribute(name);
        }
    }), boolHook = {
        set: function(elem, value, name) {
            return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), 
            name;
        }
    }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, 
            ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), 
            ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    }), jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, 
            hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    }), support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
        },
        set: function(elem) {
            var parent = elem.parentNode;
            parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex);
        }
    }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    }), jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") > -1; ) cur = cur.replace(" " + clazz + " ", " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            }) : this.each(function() {
                var className, i, self, classNames;
                if ("string" === type) for (i = 0, self = jQuery(this), classNames = value.match(rnothtmlwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else (void 0 === value || "boolean" === type) && (className = getClass(this), 
                className && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || value === !1 ? "" : dataPriv.get(this, "__className__") || ""));
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            for (className = " " + selector + " "; elem = this[i++]; ) if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return !0;
            return !1;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function(i) {
                    var val;
                    1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, 
                    null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
                        return null == value ? "" : value + "";
                    })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], 
                    hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
                });
                if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
                hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, 
                "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret);
            }
        }
    }), jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                    for (i = 0 > index ? max : one ? index : 0; max > i; i++) if (option = options[i], 
                    (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        if (value = jQuery(option).val(), one) return value;
                        values.push(value);
                    }
                    return values;
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i], 
                    (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1), values;
                }
            }
        }
    }), jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1 : void 0;
            }
        }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value;
        });
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."), 
            type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
            event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), 
            event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), 
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]), 
            special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
                    tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType : special.bindType || type, 
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"), 
                handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), 
                event.result === !1 && event.preventDefault());
                return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], 
                tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, 
                tmp && (elem[ontype] = tmp)), event.result;
            }
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: !0
            });
            jQuery.event.trigger(e, null, elem);
        }
    }), jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0;
        }
    }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    }), jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    }), support.focusin = "onfocusin" in window, support.focusin || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), 
                dataPriv.remove(doc, fix));
            }
        };
    });
    var location = window.location, nonce = jQuery.now(), rquery = /\?/;
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || "string" != typeof data) return null;
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = void 0;
        }
        return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), 
        xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value);
        };
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
            add(this.name, this.value);
        }); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&");
    }, jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href, jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), 
                transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, 
                isSuccess = status >= 200 && 300 > status || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), 
                response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
                modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), 
                modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, 
                success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, 
                (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), 
                jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", 
                isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
                jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]), 
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
                --jQuery.active || jQuery.event.trigger("ajaxStop")));
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return null == match ? null : match;
                },
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, 
                    requestHeaders[name] = value), this;
                },
                overrideMimeType: function(type) {
                    return null == completed && (s.mimeType = type), this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) if (completed) jqXHR.always(map[jqXHR.status]); else for (code in map) statusCode[code] = [ statusCode[code], map[code] ];
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this;
                }
            };
            if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), 
            s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [ "" ], 
            null == s.crossDomain) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = !0;
                }
            }
            if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
            fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
            s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), 
            s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), 
            s.data && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), 
            s.cache === !1 && (cacheURL = cacheURL.replace(rantiCache, "$1"), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), 
            s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
            (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || completed)) return jqXHR.abort();
            if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), 
            jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
                completed) return jqXHR;
                s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout));
                try {
                    completed = !1, transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) throw e;
                    done(-1, e);
                }
            } else done(-1, "No Transport");
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
        }
    }), jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
            jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    }), jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            "throws": !0
        });
    }, jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            return this[0] && (jQuery.isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), 
            this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
                return elem;
            }).append(this)), this;
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            }) : this.each(function() {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            return this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            }), this;
        }
    }), jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    }, jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    }, jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, 
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        return support.cors || xhrSupported && !options.crossDomain ? {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
                options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
                options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                for (i in headers) xhr.setRequestHeader(i, headers[i]);
                callback = function(type) {
                    return function() {
                        callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null, 
                        "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                            binary: xhr.response
                        } : {
                            text: xhr.responseText
                        }, xhr.getAllResponseHeaders()));
                    };
                }, xhr.onload = callback(), errorCallback = xhr.onerror = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                    4 === xhr.readyState && window.setTimeout(function() {
                        callback && errorCallback();
                    });
                }, callback = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    if (callback) throw e;
                }
            },
            abort: function() {
                callback && callback();
            }
        } : void 0;
    }), jQuery.ajaxPrefilter(function(s) {
        s.crossDomain && (s.contents.script = !1);
    }), jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text), text;
            }
        }
    }), jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
    }), jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type);
                    }), document.head.appendChild(script[0]);
                },
                abort: function() {
                    callback && callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback;
        }
    }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, 
        jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), 
        s.converters["script json"] = function() {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
            responseContainer = arguments;
        }, jqXHR.always(function() {
            void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, 
            s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), 
            responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
            responseContainer = overwritten = void 0;
        }), "script") : void 0;
    }), support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        return body.innerHTML = "<form></form><form></form>", 2 === body.childNodes.length;
    }(), jQuery.parseHTML = function(data, context, keepScripts) {
        if ("string" != typeof data) return [];
        "boolean" == typeof context && (keepScripts = context, context = !1);
        var base, parsed, scripts;
        return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""), 
        base = context.createElement("base"), base.href = document.location.href, context.head.appendChild(base)) : context = document), 
        parsed = rsingleTag.exec(data), scripts = !keepScripts && [], parsed ? [ context.createElement(parsed[1]) ] : (parsed = buildFragment([ data ], context, scripts), 
        scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
    }, jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off > -1 && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)), 
        jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 
        self.length > 0 && jQuery.ajax({
            url: url,
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }), this;
    }, jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    }), jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    }, jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
            curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, 
            calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
            jQuery.isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), 
            null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), 
            "using" in options ? options.using.call(elem, props) : curElem.css(props);
        }
    }, jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var docElem, win, rect, doc, elem = this[0];
            if (elem) return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), 
            rect.width || rect.height ? (doc = elem.ownerDocument, win = getWindow(doc), docElem = doc.documentElement, 
            {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            }) : rect) : {
                top: 0,
                left: 0
            };
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), 
                offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", !0),
                    left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", !0)
                }), {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    }), jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                return void 0 === val ? win ? win[prop] : elem[method] : void (win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val);
            }, method, val, arguments.length);
        };
    }), jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0;
        });
    }), jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, 
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : void 0, chainable);
            };
        });
    }), jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    }), jQuery.parseJSON = JSON.parse, "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery;
    });
    var _jQuery = window.jQuery, _$ = window.$;
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
        jQuery;
    }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery;
}), function(window) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function() {
            var paramPrefix, i, SKIP_INDEXES = 2, templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1];
            for (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                return shiftedIndex < templateArgs.length ? toDebugString(templateArgs[shiftedIndex]) : match;
            }), message += "\nhttp://errors.angularjs.org/1.6.1/" + (module ? module + "/" : "") + code, 
            i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
            return new ErrorConstructor(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || "function" == typeof obj.item);
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; length > key; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; ii > i; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isArrayBuffer(obj) {
        return "[object ArrayBuffer]" === toString.call(obj);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return -1 !== Array.prototype.indexOf.call(array, obj);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), index;
    }
    function copy(source, destination) {
        function copyRecurse(source, destination) {
            var key, h = destination.$$hashKey;
            if (isArray(source)) for (var i = 0, ii = source.length; ii > i; i++) destination.push(copyElement(source[i])); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key]); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key])); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key]));
            return setHashKey(destination, h), destination;
        }
        function copyElement(source) {
            if (!isObject(source)) return source;
            var index = stackSource.indexOf(source);
            if (-1 !== index) return stackDest[index];
            if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            var needsRecurse = !1, destination = copyType(source);
            return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), 
            needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
            switch (toString.call(source)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

              case "[object ArrayBuffer]":
                if (!source.slice) {
                    var copied = new ArrayBuffer(source.byteLength);
                    return new Uint8Array(copied).set(new Uint8Array(source)), copied;
                }
                return source.slice(0);

              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source.constructor(source.valueOf());

              case "[object RegExp]":
                var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                return re.lastIndex = source.lastIndex, re;

              case "[object Blob]":
                return new source.constructor([ source ], {
                    type: source.type
                });
            }
            return isFunction(source.cloneNode) ? source.cloneNode(!0) : void 0;
        }
        var stackSource = [], stackDest = [];
        if (destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                "$$hashKey" !== key && delete destination[key];
            }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination);
        }
        return copyElement(source);
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 === t2 && "object" === t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1)) return isRegExp(o2) ? o1.toString() === o2.toString() : !1;
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                keySet = createMap();
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) === o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return isUndefined(obj) ? void 0 : (isNumber(pretty) || (pretty = pretty ? 2 : null), 
        JSON.stringify(obj, toJsonReplacer, pretty));
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset(), timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), 
            -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), 
            key = tryDecodeURIComponent(key), isDefined(key) && (val = isDefined(val) ? tryDecodeURIComponent(val) : !0, 
            hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
        return null;
    }
    function allowAutoBootstrap(document) {
        if (!document.currentScript) return !0;
        var src = document.currentScript.getAttribute("src"), link = document.createElement("a");
        if (link.href = src, document.location.origin === link.origin) return !0;
        switch (link.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "blob:":
          case "file:":
          case "data:":
            return !0;

          default:
            return !1;
        }
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        if (forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement) {
            if (!isAutoBootstrapAllowed) return void window.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
            config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {
            strictDi: !1
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, void (isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        var originalCleanData;
        if (!bindJQueryFired) {
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0, 
            jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function(elems) {
                for (var events, elem, i = 0; null != (elem = elems[i]); i++) events = jQuery._data(elem, "events"), 
                events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
                originalCleanData(elems);
            }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0;
        }
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), 
        blockNodes.push(node));
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function stringify(value) {
        if (null == value) return "";
        switch (typeof value) {
          case "string":
            break;

          case "number":
            value = "" + value;
            break;

          default:
            value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
        }
        return value;
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method, queue) {
                        return queue || (queue = invokeQueue), function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            queue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key]);
        }
        return dst || src;
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj;
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            reloadWithDebugInfo: reloadWithDebugInfo,
            $$minErr: minErr,
            $$csp: csp,
            $$encodeUriSegment: encodeUriSegment,
            $$encodeUriQuery: encodeUriQuery,
            $$stringify: stringify
        }), (angularModule = setupModuleLoader(window))("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$HashMap: $$HashMapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function cssKebabToCamel(name) {
        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
    }
    function fnCamelCaseReplace(all, letter) {
        return letter.toUpperCase();
    }
    function kebabToCamel(name) {
        return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) return !0;
        return !1;
    }
    function jqLiteCleanData(nodes) {
        for (var i = 0, ii = nodes.length; ii > i; i++) jqLiteRemoveData(nodes[i]);
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node);
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll) for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++) jqLiteRemoveData(descendants[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) if (type) {
            var removeHandler = function(type) {
                var listenerFns = events[type];
                isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), 
                delete events[type]);
            };
            forEach(type.split(" "), function(type) {
                removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
            });
        } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), 
        delete events[type];
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = void 0;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: void 0
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var prop, isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[kebabToCamel(key)];
                for (prop in key) data[kebabToCamel(prop)] = key[prop];
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; length > i; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function jqLiteReady(fn) {
        function trigger() {
            window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), 
            fn();
        }
        "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), 
        window.addEventListener("load", trigger));
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return event.immediatePropagationStopped === !0;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        (!related || related !== target && !jqLiteContains.call(target, related)) && handler.call(target, event);
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + " ";
    }
    function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
    }
    function anonFn(fn) {
        var args = extractArgs(fn);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), 
                    cache[serviceName];
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; length > i; i++) {
                    var key = $inject[i];
                    if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            function isClass(func) {
                if (msie || "function" != typeof func) return !1;
                var result = func.$$ngIsClass;
                return isBoolean(result) || (result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func))), 
                result;
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var args = injectionArgs(fn, locals, serviceName);
                return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null), 
                new (Function.prototype.bind.apply(fn, args))()) : fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                return args.unshift(null), new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        };
        var runBlocks = loadModules(modulesToLoad);
        return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi, 
        forEach(runBlocks, function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    return "a" === nodeName_(element) ? (result = element, !0) : void 0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function splitClasses(classes) {
        isString(classes) && (classes = classes.split(" "));
        var obj = createMap();
        return forEach(classes, function(klass) {
            klass.length && (obj[klass] = !0);
        }), obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index);
        }
        function cacheStateAndFireUrlChange() {
            pendingLocation = null, cacheState(), fireUrlChange();
        }
        function cacheState() {
            cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState;
        }
        function fireUrlChange() {
            (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
            try {
                return history.state;
            } catch (e) {}
        } : noop;
        cacheState(), lastHistoryState = cachedState, self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, 
                location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState(), lastHistoryState = cachedState), pendingLocation && (pendingLocation = url), 
                self;
            }
            return pendingLocation || location.href.replace(/%27/g, "'");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (!isUndefined(value)) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = {
                                    key: key
                                });
                                refresh(lruEntry);
                            }
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                            value;
                        }
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        key in data && (delete data[key], size--);
                    },
                    removeAll: function() {
                        data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function UNINITIALIZED_VALUE() {}
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = createMap();
            return forEach(scope, function(definition, scopeName) {
                if (definition in bindingCache) return void (bindings[scopeName] = bindingCache[definition]);
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                }, match[4] && (bindingCache[definition] = bindings[scopeName]);
            }), bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
            bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
        function getDirectiveRequire(directive) {
            var require = directive.require || directive.controller && directive.name;
            return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                var match = value.match(REQUIRE_PREFIX_REGEXP), name = value.substring(match[0].length);
                name || (require[key] = match[0] + key);
            }), require;
        }
        function getDirectiveRestrict(restrict, name) {
            if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            return restrict || "EA";
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
        this.directive = function registerDirective(name, directiveFactory) {
            return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), 
            assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = getDirectiveRequire(directive), directive.restrict = getDirectiveRestrict(directive.restrict, name), 
                        directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.component = function(name, options) {
            function factory($injector) {
                function makeInjectable(fn) {
                    return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                        return $injector.invoke(fn, this, {
                            $element: tElement,
                            $attrs: tAttrs
                        });
                    } : fn;
                }
                var template = options.template || options.templateUrl ? options.template : "", ddo = {
                    controller: controller,
                    controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                return forEach(options, function(val, key) {
                    "$" === key.charAt(0) && (ddo[key] = val);
                }), ddo;
            }
            var controller = options.controller || function() {};
            return forEach(options, function(val, key) {
                "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
            }), factory.$inject = [ "$injector" ], this.directive(name, factory);
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        };
        var preAssignBindingsEnabled = !1;
        this.preAssignBindingsEnabled = function(enabled) {
            return isDefined(enabled) ? (preAssignBindingsEnabled = enabled, this) : preAssignBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            return arguments.length ? (TTL = value, this) : TTL;
        };
        var commentDirectivesEnabledConfig = !0;
        this.commentDirectivesEnabled = function(value) {
            return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = !0;
        this.cssClassDirectivesEnabled = function(value) {
            return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    $rootScope.$apply(function() {
                        for (var errors = [], i = 0, ii = onChangesQueue.length; ii > i; ++i) try {
                            onChangesQueue[i]();
                        } catch (e) {
                            errors.push(e);
                        }
                        if (onChangesQueue = void 0, errors.length) throw errors;
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; l > i; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            }
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                    assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()), 
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; ii > i; ) node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var sibling, node = nodeList[idx], parent = node.parentNode;
                if (node.nodeType === NODE_TYPE_TEXT) for (;;) {
                    if (sibling = parent ? node.nextSibling : nodeList[idx + 1], !sibling || sibling.nodeType !== NODE_TYPE_TEXT) break;
                    node.nodeValue = node.nodeValue + sibling.nodeValue, sibling.parentNode && sibling.parentNode.removeChild(sibling), 
                    notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node), addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = attr.value, ngAttrName = directiveNormalize(name), 
                        isNgAttr = NG_ATTR_BINDING.test(ngAttrName), isNgAttr && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        }));
                        var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                        multiElementMatch && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), 
                    !cssClassDirectivesEnabled) break;
                    if (className = node.className, isObject(className) && (className = className.animVal), 
                    isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                }
                return directives.sort(byPriority), directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]));
                    }
                } catch (e) {}
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                        node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                    return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), 
                    $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, 
                        cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        !slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                        if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                    }
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn, 
                    transcludeFn.isSlotFilled = function(slotName) {
                        return !!boundTranscludeFn.$$slots[slotName];
                    }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective), 
                    scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                        if (preAssignBindingsEnabled) {
                            bindings ? controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective) : controller.bindingInfo = {};
                            var controllerResult = controller();
                            controllerResult !== controller.instance && (controller.instance = controllerResult, 
                            $element.data("$" + controllerDirective.name + "Controller", controllerResult), 
                            controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches(), 
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective));
                        } else controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), 
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                    for (forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                    }), forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) try {
                            controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        if (isFunction(controllerInstance.$onInit)) try {
                            controllerInstance.$onInit();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                            controllerInstance.$doCheck();
                        }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                            controllerInstance.$onDestroy();
                        });
                    }), i = 0, ii = preLinkFns.length; ii > i; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                    });
                }
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, 
                    terminalPriority > directive.priority) break;
                    if (directiveValue = directive.scope, directiveValue && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                            mightHaveMultipleTransclusionError = !0;
                            break;
                        }
                        didScanForMultipleTransclusion = !0;
                    }
                    if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), 
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    $template[0].$$parentNode = $template[0].parentNode, childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }); else {
                        var slots = createMap();
                        if (isObject(directiveValue)) {
                            $template = [];
                            var slotMap = createMap(), filledSlots = createMap();
                            forEach(directiveValue, function(elementSelector, slotName) {
                                var optional = "?" === elementSelector.charAt(0);
                                elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, 
                                slots[slotName] = null, filledSlots[slotName] = optional;
                            }), forEach($compileNode.contents(), function(node) {
                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || [], 
                                slots[slotName].push(node)) : $template.push(node);
                            }), forEach(filledSlots, function(filled, slotName) {
                                if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                            });
                            for (var slotName in slots) slots[slotName] && (slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn));
                        } else $template = jqLite(jqLiteClone(compileNode)).contents();
                        $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                            needsNewScope: directive.$$isolateScope || directive.$$newScope
                        }), childTranscludeFn.$$slots = slots;
                    }
                    if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), 
                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                        var context = directive.$$originalDirective || directive;
                        isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                    if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], 
                    value = value && value.instance), !value) {
                        var dataName = "$" + name + "Controller";
                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                    if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; ii > i; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                }));
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey], locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    }, controller = directive.controller;
                    "@" === controller && (controller = attrs[directive.name]);
                    var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                    if (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), !directive.$$bindings) {
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope);
                    }
                    tDirectives.push(directive), match = directive;
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node === compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                        }
                    }
                    linkQueue = null;
                })["catch"](function(error) {
                    error instanceof Error && $exceptionHandler(error);
                })["catch"](noop), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" === attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                if ("src" === attrNormalizedName || "ngSrc" === attrNormalizedName) {
                    if (-1 === [ "img", "video", "audio", "source", "track" ].indexOf(tag)) return $sce.RESOURCE_URL;
                } else if ("xlinkHref" === attrNormalizedName || "form" === tag && "action" === attrNormalizedName || "link" === tag && "href" === attrNormalizedName) return $sce.RESOURCE_URL;
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var trustedContext = getTrustedContext(node, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                    value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] === firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = window.document.createDocumentFragment();
                for (i = 0; removeCount > i; i++) fragment.appendChild(elementsToRemove[i]);
                for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), 
                jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), 
                i = 1; removeCount > i; i++) delete elementsToRemove[i];
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                function recordChanges(key, currentValue, previousValue) {
                    !isFunction(destination.$onChanges) || currentValue === previousValue || currentValue !== currentValue && previousValue !== previousValue || (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), 
                    onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), 
                    changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes), changes = void 0;
                }
                var changes, removeWatchCollection = [], initialChanges = {};
                return forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                    switch (mode) {
                      case "@":
                        optional || hasOwnProperty.call(attrs, attrName) || (destination[scopeName] = attrs[attrName] = void 0), 
                        removeWatch = attrs.$observe(attrName, function(value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue), destination[scopeName] = value;
                            }
                        }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), 
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                            return a === b || a !== a && b !== b;
                        }, parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        var deepWatch = parentGet.literal, initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatch = scope.$watch(parentGet, function(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) return;
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                        }, deepWatch), removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        if (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop, 
                        parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                }), {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function() {
                        for (var i = 0, ii = removeWatchCollection.length; ii > i; ++i) removeWatchCollection[i]();
                    }
                };
            }
            var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], 
                    attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), 
                    "a" === nodeName && ("href" === key || "xlinkHref" === key) || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key && isDefined(value)) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    writeAttr !== !1 && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile.$$createComment = function(directiveName, comment) {
                var content = "";
                return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), 
                window.document.createComment(content);
            }, compile;
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous, this.currentValue = current;
    }
    function directiveNormalize(name) {
        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1;
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        }, this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.allowGlobals = function() {
            globals = !0;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                    if (match = expression.match(CNTRL_REG), !match) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    if (constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : void 0), 
                    !expression) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    assertArgFn(expression, constructor, !0);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                    extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $$IsDocumentHiddenProvider() {
        this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
            function changeListener() {
                hidden = doc.hidden;
            }
            var doc = $document[0], hidden = doc && doc.hidden;
            return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                $document.off("visibilitychange", changeListener);
            }), function() {
                return hidden;
            };
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) ? forEach(value, function(v) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                function serialize(toSerialize, prefix, topLevel) {
                    null === toSerialize || isUndefined(toSerialize) || (isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                        serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize))));
                }
                if (!params) return "";
                var parts = [];
                return serialize(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData));
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        var i, parsed = createMap();
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            function $http(requestConfig) {
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; ii > i; ) {
                        var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    return interceptors.length = 0, promise;
                }
                function completeOutstandingRequest() {
                    $browser.$$completeOutstandingRequest(noop);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn;
                    }), processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                function serverRequest(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), 
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, 
                $browser.$$incOutstandingRequestCount();
                var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                return forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest), 
                promise = chainInterceptors(promise, responseInterceptors), promise = promise["finally"](completeOutstandingRequest);
            }
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        return forEach(eventHandlers, function(eventHandler, key) {
                            applyHandlers[key] = function(event) {
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                                useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                            };
                        }), applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                if (isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url)), 
                url = buildUrl(url, config.paramSerializer(config.params)), isJsonp && (url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam)), 
                $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), 
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
            }
            function buildUrl(url, serializedParams) {
                return serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams), 
                url;
            }
            function sanitizeJsonpCallbackParam(url, key) {
                if (/[&?][^=]+=JSON_CALLBACK/.test(url)) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                var callbackParamRegex = new RegExp("[&?]" + key + "=");
                if (callbackParamRegex.test(url)) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);
                return url += (-1 === url.indexOf("?") ? "?" : "&") + key + "=JSON_CALLBACK";
            }
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                script.removeEventListener("load", callback), script.removeEventListener("error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, script.addEventListener("load", callback), script.addEventListener("error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                callback(status, response, headersString, statusText);
            }
            if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                var response = 200 === status && callbacks.getResponse(callbackPath);
                completeRequest(callback, status, response, "", text), callbacks.removeCallback(callbackPath);
            }); else {
                var xhr = createXhr(method, url);
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, xhr.ontimeout = requestError, 
                forEach(eventHandlers, function(value, key) {
                    xhr.addEventListener(key, value);
                }), forEach(uploadEventHandlers, function(value, key) {
                    xhr.upload.addEventListener(key, value);
                }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
                if (!text.length || -1 === text.indexOf(startSymbol)) {
                    var constantInterp;
                    if (!mustHaveExpression) {
                        var unescapedText = unescapeText(text);
                        constantInterp = valueFn(unescapedText), constantInterp.exp = text, constantInterp.expressions = [], 
                        constantInterp.$$watchDelegate = constantWatchDelegate;
                    }
                    return constantInterp;
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                    if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, 
                    expressionPositions.push(concat.length), concat.push("");
                }
                if (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                !mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; ii > i; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    }, getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;ii > i; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", "$browser", function($rootScope, $window, $q, $$q, $browser) {
            function interval(fn, delay, count, invokeApply) {
                function callback() {
                    hasParams ? fn.apply(null, args) : fn(iteration);
                }
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.$$intervalId = setInterval(function() {
                    skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), 
                    count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), 
                    delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].promise["catch"](noop), 
                intervals[promise.$$intervalId].reject("canceled"), $window.clearInterval(promise.$$intervalId), 
                delete intervals[promise.$$intervalId], !0) : !1;
            }, interval;
        } ];
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(url, locationObj) {
        if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        var prefixed = "/" !== url.charAt(0);
        prefixed && (url = "/" + url);
        var match = urlResolve(url);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        return startsWith(url, base) ? url.substr(base.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 === index ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl), 
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this), 
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$parseLinkUrl = function(url, relHref) {
            return stripHash(appBase) === stripHash(url) ? (this.$$parse(url), !0) : !1;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "!", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                        var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                        isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                        IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                        $location.absUrl() !== $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0));
                    }
                }
            }), trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                return startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    newUrl = trimEmptyHash(newUrl), $location.$$parse(newUrl), $location.$$state = newState, 
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), void ($rootScope.$$phase || $rootScope.$digest())) : void ($window.location.href = newUrl);
            }), $rootScope.$watch(function() {
                var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                    afterLocationChange(oldUrl, oldState)));
                })), $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function getStringValue(name) {
        return name + "";
    }
    function ifDefined(v, d) {
        return "undefined" != typeof v ? v : d;
    }
    function plusFn(l, r) {
        return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants, argsToWatch, isStatelessFilter;
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter), findConstantAndWatchExpressions(ast.alternate, $filter), 
            findConstantAndWatchExpressions(ast.consequent, $filter), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter), ast.computed && findConstantAndWatchExpressions(ast.property, $filter), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : !1, allConstants = isStatelessFilter, 
            argsToWatch = [], forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter), allConstants = allConstants && property.value.constant && !property.computed, 
                property.value.constant || argsToWatch.push.apply(argsToWatch, property.value.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = !1, ast.toWatch = [];
            break;

          case AST.LocalsExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(body) {
        if (1 === body.length) {
            var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        return 1 === ast.body.length && isAssignable(ast.body[0].expression) ? {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function isLiteral(ast) {
        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var identStart, identContinue, cache = createMap(), literals = {
            "true": !0,
            "false": !1,
            "null": null,
            undefined: void 0
        };
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
            return identStart = identifierStart, identContinue = identifierContinue, this;
        }, this.$get = [ "$filter", function($filter) {
            function $parse(exp, interceptorFn) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    if (exp = exp.trim(), cacheKey = exp, parsedExpression = cache[cacheKey], !parsedExpression) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                        var lexer = new Lexer($parseOptions), parser = new Parser(lexer, $filter, $parseOptions);
                        parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), 
                "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult, inputExpressions = parsedExpression.inputs;
                if (1 === inputExpressions.length) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; ii > i; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), 
                    lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }
                function oneTimeListener(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener(value, old, scope), isDefined(value) && scope.$$postDigest(function() {
                        isDefined(lastValue) && unwatch();
                    });
                }
                var unwatch, lastValue;
                return unwatch = parsedExpression.inputs ? inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression) : scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1);
                    }), allDefined;
                }
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener(value, old, scope), isAllDefined(value) && scope.$$postDigest(function() {
                        isAllDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate, useInputs = !1, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs), result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                return useInputs = !parsedExpression.inputs, parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? (fn.$$watchDelegate = parsedExpression.$$watchDelegate, 
                fn.inputs = parsedExpression.inputs) : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, 
                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ]), 
                fn;
            }
            var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                csp: noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            return $parse;
        } ];
    }
    function $QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function $$QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
        function defer() {
            return new Deferred();
        }
        function Deferred() {
            var promise = this.promise = new Promise();
            this.resolve = function(val) {
                resolvePromise(promise, val);
            }, this.reject = function(reason) {
                rejectPromise(promise, reason);
            }, this.notify = function(progress) {
                notifyPromise(promise, progress);
            };
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = void 0;
            try {
                for (var i = 0, ii = pending.length; ii > i; ++i) {
                    state.pur = !0, promise = pending[i][0], fn = pending[i][state.status];
                    try {
                        isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value);
                    } catch (e) {
                        rejectPromise(promise, e);
                    }
                }
            } finally {
                --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
            }
        }
        function processChecks() {
            for (;!queueSize && checkQueue.length; ) {
                var toCheck = checkQueue.shift();
                if (!toCheck.pur) {
                    toCheck.pur = !0;
                    var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                    toCheck.value instanceof Error ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !errorOnUnhandledRejections || state.pending || 2 !== state.status || state.pur || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), 
            checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, 
            ++queueSize, nextTick(function() {
                processQueue(state);
            }));
        }
        function resolvePromise(promise, val) {
            promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val));
        }
        function $$resolve(promise, val) {
            function doResolve(val) {
                done || (done = !0, $$resolve(promise, val));
            }
            function doReject(val) {
                done || (done = !0, $$reject(promise, val));
            }
            function doNotify(progress) {
                notifyPromise(promise, progress);
            }
            var then, done = !1;
            try {
                (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, 
                then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1, 
                scheduleProcessQueue(promise.$$state));
            } catch (e) {
                doReject(e);
            }
        }
        function rejectPromise(promise, reason) {
            promise.$$state.status || $$reject(promise, reason);
        }
        function $$reject(promise, reason) {
            promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
        }
        function notifyPromise(promise, progress) {
            var callbacks = promise.$$state.pending;
            promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                    result = callbacks[i][0], callback = callbacks[i][3];
                    try {
                        notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                    } catch (e) {
                        exceptionHandler(e);
                    }
                }
            });
        }
        function reject(reason) {
            var result = new Promise();
            return rejectPromise(result, reason), result;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return reject(e);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return resolver(value);
            }, reject) : resolver(value);
        }
        function when(value, callback, errback, progressBack) {
            var result = new Promise();
            return resolvePromise(result, value), result.then(callback, errback, progressBack);
        }
        function all(promises) {
            var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results[key] = value, --counter || resolvePromise(result, results);
                }, function(reason) {
                    rejectPromise(result, reason);
                });
            }), 0 === counter && resolvePromise(result, results), result;
        }
        function race(promises) {
            var deferred = defer();
            return forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            }), deferred.promise;
        }
        function $Q(resolver) {
            function resolveFn(value) {
                resolvePromise(promise, value);
            }
            function rejectFn(reason) {
                rejectPromise(promise, reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            var promise = new Promise();
            return resolver(resolveFn, rejectFn), promise;
        }
        var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                var result = new Promise();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        var resolve = when;
        return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, 
        $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                this.$$ChildScope = null;
            }
            return ChildScope.prototype = parent, ChildScope;
        }
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function cleanUpScope($scope) {
                9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), 
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, 
                this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do current.$$watchersCount += count; while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), 
                    child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = [], 
                    array.$$digestWatchIndex = -1), array.unshift(watcher), array.$$digestWatchIndex++, 
                    incrementWatchersCount(this, 1), function() {
                        var index = arrayRemove(array, watcher);
                        index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), 
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; newLength > i; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, 
                                bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, 
                                oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, fn, get, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        dirty = !1, current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition], asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                if (watch = watchers[watchers.$$digestWatchIndex]) if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                        postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0;
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount);
                        for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this);
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        expression: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event.currentScope = null, event;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function snakeToCamel(name) {
        return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && 8 > msie) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, isChromePackagedApp = $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle), 
            animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                history: !(!hasHistoryPushState || 4 > android || boxee),
                hasEvent: function(event) {
                    if ("input" === event && msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            return val ? (httpOptions = val, this) : httpOptions;
        }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    return ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), 
                    $exceptionHandler(resp)), $q.reject(resp);
                }
                handleRequestFn.totalPendingRequests++, (!isString(tpl) || isUndefined($templateCache.get(tpl))) && (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), 
                $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions))["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data), response.data;
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                            matcher.test(bindingName) && matches.push(binding);
                        } else -1 !== bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].promise["catch"](noop), 
                deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], 
                $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        function safeGetCookie(rawDocument) {
            try {
                return rawDocument.cookie || "";
            } catch (e) {
                return "";
            }
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString, 
            cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
            index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            anyPropertyKey = anyPropertyKey || "$";
            var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var predicateFn, shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return isUndefined(actual) ? !1 : null === actual || null === expected ? actual === expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) ? !1 : (actual = lowercase("" + actual), 
            expected = lowercase("" + expected), -1 !== actual.indexOf(expected));
        }), predicateFn = function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, anyPropertyKey, !1);
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = key === anyPropertyKey, actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                    }
                }
                return !0;
            }
            return comparator(actual, expected);

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), 
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function parse(numStr) {
        var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
        for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), 
        (i = numStr.search(/e/i)) > 0 ? (0 > numberOfIntegerDigits && (numberOfIntegerDigits = i), 
        numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : 0 > numberOfIntegerDigits && (numberOfIntegerDigits = numStr.length), 
        i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
        if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
            for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
            for (numberOfIntegerDigits -= i, digits = [], j = 0; zeros >= i; i++, j++) digits[j] = +numStr.charAt(i);
        }
        return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), 
        exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
            d: digits,
            e: exponent,
            i: numberOfIntegerDigits
        };
    }
    function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i;
        fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i, digit = digits[roundAt];
        if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
        } else {
            fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), 
            digits[0] = 0;
            for (var i = 1; roundAt > i; i++) digits[i] = 0;
        }
        if (digit >= 5) if (0 > roundAt - 1) {
            for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
            digits.unshift(1), parsedNumber.i++;
        } else digits[roundAt - 1]++;
        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
            return d += carry, digits[i] = d % 10, Math.floor(d / 10);
        }, 0);
        carry && (digits.unshift(carry), parsedNumber.i++);
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
        var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
        if (isInfinity) formattedText = ""; else {
            parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
            for (isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, !0); 0 > integerLen; ) digits.unshift(0), integerLen++;
            integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, 
            digits = [ 0 ]);
            var groups = [];
            for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), 
            decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
        }
        return 0 > number && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        for ((0 > num || negWrap && 0 >= num) && (negWrap ? num = -num + 1 : (num = -num, 
        neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12), 
            padNumber(value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
            var value = date["get" + name](), propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : ""), get = uppercase(propPrefix + name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
        };
    }
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), 
            isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), 
            begin = 0 > begin ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input);
        };
    }
    function sliceFn(input, begin, end) {
        return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
    }
    function orderByFilter($parse) {
        function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) get = predicate; else if (isString(predicate) && (("+" === predicate.charAt(0) || "-" === predicate.charAt(0)) && (descending = "-" === predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), 
                get.constant))) {
                    var key = get();
                    get = function(value) {
                        return value[key];
                    };
                }
                return {
                    get: get,
                    descending: descending
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        function objectValue(value) {
            return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), 
            isPrimitive(value)) ? value : value;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            return null === value ? (type = "string", value = "null") : "object" === type && (value = objectValue(value)), 
            {
                value: value,
                type: type,
                index: index
            };
        }
        function defaultCompare(v1, v2) {
            var result = 0, type1 = v1.type, type2 = v2.type;
            if (type1 === type2) {
                var value1 = v1.value, value2 = v2.value;
                "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), 
                isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value2 > value1 ? -1 : 1);
            } else result = type2 > type1 ? -1 : 1;
            return result;
        }
        return function(array, sortPredicate, reverseOrder, compareFn) {
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var i = 0, ii = predicates.length; ii > i; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) return result * predicates[i].descending * descending;
                }
                return compare(v1.tieBreaker, v2.tieBreaker) * descending;
            }
            if (null == array) return array;
            if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
            var predicates = processPredicates(sortPredicate), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, getComparisonObject);
            return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                return item.value;
            });
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, 
        this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, 
        this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, 
        this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, 
        setupValidity(this);
    }
    function setupValidity(instance) {
        instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
    }
    function addSetValidityMethod(context) {
        function createAndSet(ctrl, name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(ctrl, name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
        }
        function cachedToggleClass(ctrl, className, switchValue) {
            switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !1);
        }
        function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === !1);
        }
        var clazz = context.clazz, set = context.set, unset = context.unset;
        clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
            isUndefined(state) ? createAndSet(this, "$pending", validationErrorKey, controller) : unsetAndCleanup(this, "$pending", validationErrorKey, controller), 
            isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), 
            set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, PENDING_CLASS, !0), 
            this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, PENDING_CLASS, !1), 
            this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid));
            var combinedState;
            combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : this.$error[validationErrorKey] ? !1 : this.$$success[validationErrorKey] ? !0 : null, 
            toggleValidationCss(this, validationErrorKey, combinedState), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        };
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var timeout, listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null, input && input.value === origValue || listener(ev);
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value);
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
                var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                timeout = $browser.defer(function() {
                    timeout = null, (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) && listener(ev);
                });
            }
        }), ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            element.val() !== value && element.val(value);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) return parts.shift(), map = date ? {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, forEach(parts, function(part, index) {
                    index < mapping.length && (map[mapping[index]] = +part);
                }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDate(val) || void 0 : val;
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options.getOption("timezone");
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                    parsedDate;
                }
                return void 0;
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                return isValidDate(value) ? (previousDate = value, previousDate && timezone && (previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                $filter("date")(value, format, timezone)) : (previousDate = null, "");
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? void 0 : value;
        });
    }
    function numberFormatterParser(ctrl) {
        ctrl.$$parserName = "number", ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void 0;
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
    }
    function isNumberInteger(num) {
        return (0 | num) === num;
    }
    function countDecimals(num) {
        var numString = num.toString(), decimalSymbolIndex = numString.indexOf(".");
        if (-1 === decimalSymbolIndex) {
            if (num > -1 && 1 > num) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) return Number(match[1]);
            }
            return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
    }
    function isValidForStep(viewValue, stepBase, step) {
        var value = Number(viewValue);
        if (!isNumberInteger(value) || !isNumberInteger(stepBase) || !isNumberInteger(step)) {
            var decimalCount = Math.max(countDecimals(value), countDecimals(stepBase), countDecimals(step)), multiplier = Math.pow(10, decimalCount);
            value *= multiplier, stepBase *= multiplier, step *= multiplier;
        }
        return (value - stepBase) % step === 0;
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var minVal, maxVal;
        if ((isDefined(attr.min) || attr.ngMin) && (ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
        }, attr.$observe("min", function(val) {
            minVal = parseNumberAttrVal(val), ctrl.$validate();
        })), (isDefined(attr.max) || attr.ngMax) && (ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value;
        }, attr.$observe("max", function(val) {
            maxVal = parseNumberAttrVal(val), ctrl.$validate();
        })), isDefined(attr.step) || attr.ngStep) {
            var stepVal;
            ctrl.$validators.step = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            }, attr.$observe("step", function(val) {
                stepVal = parseNumberAttrVal(val), ctrl.$validate();
            });
        }
    }
    function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element.attr(htmlAttrName, attr[htmlAttrName]), attr.$observe(htmlAttrName, changeFn);
        }
        function minChange(val) {
            if (minVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function maxChange(val) {
            if (maxVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                elVal > maxVal && (element.val(maxVal), elVal = minVal > maxVal ? minVal : maxVal), 
                ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function stepChange(val) {
            stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue) || (supportsRange && ctrl.$viewValue !== element.val() ? ctrl.$setViewValue(element.val()) : ctrl.$validate());
        }
        badInputChecker(scope, element, attr, ctrl), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step), originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
            originalRender(), ctrl.$setViewValue(element.val());
        } : originalRender, hasMinAttr && (ctrl.$validators.min = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
        }, setInitialValueAndObserver("min", minChange)), hasMaxAttr && (ctrl.$validators.max = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || maxVal >= viewValue;
        }, setInitialValueAndObserver("max", maxChange)), hasStepAttr && (ctrl.$validators.step = supportsRange ? function() {
            return !validity.stepMismatch;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
        }, setInitialValueAndObserver("step", stepChange));
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "url", ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "email", ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            var value;
            element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
        };
        element.on("click", listener), ctrl.$render = function() {
            var value = attr.value;
            doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value === !1;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length) return [];
            if (!tokens2 || !tokens2.length) return tokens1;
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                values.push(token);
            }
            return values;
        }
        function split(classString) {
            return classString && classString.split(" ");
        }
        function toClassString(classValue) {
            var classString = classValue;
            return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) && (classString = Object.keys(classValue).filter(function(key) {
                return classValue[key];
            }).join(" ")), classString;
        }
        function toFlatValue(classValue) {
            var flatValue = classValue;
            if (isArray(classValue)) flatValue = classValue.map(toFlatValue); else if (isObject(classValue)) {
                var hasUndefined = !1;
                flatValue = Object.keys(classValue).filter(function(key) {
                    var value = classValue[key];
                    return !hasUndefined && isUndefined(value) && (hasUndefined = !0), value;
                }), hasUndefined && flatValue.push(void 0);
            }
            return flatValue;
        }
        name = "ngClass" + name;
        var indexWatchExpression;
        return [ "$parse", function($parse) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classString) {
                        classString = digestClassCounts(split(classString), 1), attr.$addClass(classString);
                    }
                    function removeClasses(classString) {
                        classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                    }
                    function updateClasses(oldClassString, newClassString) {
                        var oldClassArray = split(oldClassString), newClassArray = split(newClassString), toRemoveArray = arrayDifference(oldClassArray, newClassArray), toAddArray = arrayDifference(newClassArray, oldClassArray), toRemoveString = digestClassCounts(toRemoveArray, -1), toAddString = digestClassCounts(toAddArray, 1);
                        attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                    }
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        return forEach(classArray, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), classesToUpdate.join(" ");
                    }
                    function ngClassIndexWatchAction(newModulo) {
                        newModulo === selector ? addClasses(oldClassString) : removeClasses(oldClassString), 
                        oldModulo = newModulo;
                    }
                    function ngClassOneTimeWatchAction(newClassValue) {
                        var newClassString = toClassString(newClassValue);
                        newClassString !== oldClassString && ngClassWatchAction(newClassString);
                    }
                    function ngClassWatchAction(newClassString) {
                        oldModulo === selector && updateClasses(oldClassString, newClassString), oldClassString = newClassString;
                    }
                    var oldClassString, expression = attr[name].trim(), isOneTime = ":" === expression.charAt(0) && ":" === expression.charAt(1), watchInterceptor = isOneTime ? toFlatValue : toClassString, watchExpression = $parse(expression, watchInterceptor), watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction, classCounts = element.data("$classCounts"), oldModulo = !0;
                    classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), 
                    "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", function($index) {
                        return 1 & $index;
                    })), scope.$watch(indexWatchExpression, ngClassIndexWatchAction)), scope.$watch(watchExpression, watchAction, isOneTime);
                }
            };
        } ];
    }
    function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), 
        this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$parsedNgModel = $parse($attr.ngModel), 
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, 
        this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, 
        this.$$currentValidationRunId = 0, this.$$scope = $scope, this.$$attr = $attr, this.$$element = $element, 
        this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, 
        this.$$exceptionHandler = $exceptionHandler, setupValidity(this), setupModelWatcher(this);
    }
    function setupModelWatcher(ctrl) {
        ctrl.$$scope.$watch(function() {
            var modelValue = ctrl.$$ngModelGet(ctrl.$$scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue, ctrl.$$parserValid = void 0;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$$updateEmptyClasses(viewValue), ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, 
                ctrl.$render(), ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop));
            }
            return modelValue;
        });
    }
    function ModelOptions(options) {
        this.$$options = options;
    }
    function defaults(dst, src) {
        forEach(src, function(value, key) {
            isDefined(dst[key]) || (dst[key] = value);
        });
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = window.document.documentMode;
    var isNumberNaN = Number.isNaN || function(num) {
        return num !== num;
    };
    noop.$inject = [], identity.$inject = [];
    var isArray = Array.isArray, TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        function noUnsafeEval() {
            try {
                return new Function(""), !1;
            } catch (e) {
                return !0;
            }
        }
        if (!isDefined(csp.rules)) {
            var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                    noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                };
            } else csp.rules = {
                noUnsafeEval: noUnsafeEval(),
                noInlineStyle: !1
            };
        }
        return csp.rules;
    }, jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el, i, prefix, name, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    }, ALL_COLONS = /:/g, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], isAutoBootstrapAllowed = allowAutoBootstrap(window.document), SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_ATTRIBUTE = 2, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.6.1",
        major: 1,
        minor: 6,
        dot: 1,
        codeName: "promise-rectification"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1;
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(16 & this.compareDocumentPosition(arg));
    }, JQLitePrototype = JQLite.prototype = {
        ready: jqLiteReady,
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = cssKebabToCamel(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var ret, nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                return isDefined(value) ? void (null === value || value === !1 && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value)) : (ret = element.getAttribute(name), 
                isBooleanAttr && null !== ret && (ret = lowercasedName), null === ret ? void 0 : ret);
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                    var eventFns = events[type];
                    eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper, 
                    "$destroy" === type || noEventListener || element.addEventListener(type, handle)), 
                    eventFns.push(fn);
                }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), 
                addHandler(type, void 0, !0)) : addHandler(type);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) {
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; ii > i; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling), index = node;
                }
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return this.defaultPrevented === !0;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return this.immediatePropagationStopped === !0;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        };
    }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off, 
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var $$HashMapProvider = [ function() {
        this.$get = [ function() {
            return HashMap;
        } ];
    } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", $$CoreAnimateJsProvider = function() {
        this.$get = noop;
    }, $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            function updateData(data, classes, value) {
                var changed = !1;
                return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], 
                forEach(classes, function(className) {
                    className && (changed = !0, data[className] = value);
                })), changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                        forEach(data, function(status, className) {
                            var hasClass = !!existing[className];
                            status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                        }), forEach(element, function(elm) {
                            toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                        }), postDigestQueue.remove(element);
                    }
                }), postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                (classesAdded || classesRemoved) && (postDigestQueue.put(element, data), postDigestElements.push(element), 
                1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
            }
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), 
                    options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    var runner = new $$AnimateRunner();
                    return runner.complete(), runner;
                }
            };
        } ];
    }, $AnimateProvider = [ "$provide", function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null, 
            this.$$classNameFilter)) {
                var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
                if (reservedRegex.test(this.$$classNameFilter.toString())) throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
            return this.$$classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                }
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.end && runner.end();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ], $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = [ "$$rAF", function($$rAF) {
            function waitForTick(fn) {
                waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                    waitQueue = [];
                });
            }
            var waitQueue = [];
            return function() {
                var passed = !1;
                return waitForTick(function() {
                    passed = !0;
                }), function(callback) {
                    passed ? callback() : waitForTick(callback);
                };
            };
        } ];
    }, $$AnimateRunnerFactoryProvider = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun(), timeoutTick = function(fn) {
                    $timeout(fn, 0, !1);
                };
                this._doneCallbacks = [], this._tick = function(fn) {
                    $$isDocumentHidden() ? timeoutTick(fn) : rafTick(fn);
                }, this._state = 0;
            }
            var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
            return AnimateRunner.chain = function(chain, callback) {
                function next() {
                    return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                        return response === !1 ? void callback(!1) : (index++, void next());
                    });
                }
                var index = 0;
                next();
            }, AnimateRunner.all = function(runners, callback) {
                function onProgress(response) {
                    status = status && response, ++count === runners.length && callback(status);
                }
                var count = 0, status = !0;
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
            }, AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
                },
                progress: noop,
                getPromise: function() {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function(resolve, reject) {
                            self.done(function(status) {
                                status === !1 ? reject() : resolve();
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                "catch": function(handler) {
                    return this.getPromise()["catch"](handler);
                },
                "finally": function(handler) {
                    return this.getPromise()["finally"](handler);
                },
                pause: function() {
                    this.host.pause && this.host.pause();
                },
                resume: function() {
                    this.host.resume && this.host.resume();
                },
                end: function() {
                    this.host.end && this.host.end(), this._resolve(!0);
                },
                cancel: function() {
                    this.host.cancel && this.host.cancel(), this._resolve(!1);
                },
                complete: function(response) {
                    var self = this;
                    self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._tick(function() {
                        self._resolve(response);
                    }));
                },
                _resolve: function(response) {
                    this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function(fn) {
                        fn(response);
                    }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE);
                }
            }, AnimateRunner;
        } ];
    }, $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                function run() {
                    return $$rAF(function() {
                        applyAnimationContents(), closed || runner.complete(), closed = !0;
                    }), runner;
                }
                function applyAnimationContents() {
                    options.addClass && (element.addClass(options.addClass), options.addClass = null), 
                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), 
                    options.to && (element.css(options.to), options.to = null);
                }
                var options = initialOptions || {};
                options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), 
                options.from && (element.css(options.from), options.from = null);
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
            };
        } ];
    }, $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/, $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                domNode.offsetWidth + 1;
            };
        } ];
    }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http"), $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var $jsonpCallbacksProvider = function() {
        this.$get = [ "$window", function($window) {
            function createCallback(callbackId) {
                var callback = function(data) {
                    callback.data = data, callback.called = !0;
                };
                return callback.id = callbackId, callback;
            }
            var callbacks = $window.angular.callbacks, callbackMap = {};
            return {
                createCallback: function(url) {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = createCallback(callbackId);
                    return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id], delete callbackMap[callbackPath];
                }
            };
        } ];
    }, PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/, locationPrototype = {
        $$absUrl: "",
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" === path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this;
        };
    });
    var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf, OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "" === ch;
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index), peek = this.peek();
            if (!peek) return ch;
            var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
            return cp1 >= 55296 && 56319 >= cp1 && cp2 >= 56320 && 57343 >= cp2 ? ch + peek : ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." === ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) break;
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", 
    AST.prototype = {
        ast: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                type: AST.Literal,
                value: this.options.literals[this.consume().text]
            } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(baseExpression) {
            for (var args = [ baseExpression ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) do args.push(this.filterChain()); while (this.expect(","));
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elements.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                property = {
                    type: AST.Property,
                    kind: "init"
                }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, 
                this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), 
                property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), 
                property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), 
                property.value = this.expression()) : this.throwError("invalid key", this.peek()), 
                properties.push(property);
            } while (this.expect(","));
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        selfReferential: {
            "this": {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    }, ASTCompiler.prototype = {
        compile: function(expression) {
            var self = this, ast = this.astBuilder.ast(expression);
            this.state = {
                nextId: 0,
                filters: {},
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, extra = "";
            if (this.stage = "assign", assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push(fnKey), 
                watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
            return this.state = this.stage = void 0, fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], fns = this.state.inputs, self = this;
            return forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            }), fns.length && result.push("fn.inputs=[" + fns.join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, computed, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, void 0, void 0, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, void 0, void 0, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, void 0, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                        create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.computedMember(left, right), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        forEach(ast.arguments, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument);
                            });
                        }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", 
                        self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.ObjectExpression:
                args = [], computed = !1, forEach(ast.properties, function(property) {
                    property.computed && (computed = !0);
                }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                    property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, 
                    right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                })) : (forEach(ast.properties, function(property) {
                    self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn(intoId || "s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l"), recursionFn(intoId || "l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn(intoId || "v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            return id ? (this.current().body.push(id, "=", value, ";"), id) : void 0;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === !0) alternate(); else {
                var body = this.current().body;
                body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                consequent(), body.push("}"));
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        isNull: function(expression) {
            return expression + "==null";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/, UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === !0) return "true";
            if (value === !1) return "false";
            if (null === value) return "null";
            if ("undefined" == typeof value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(expression) {
            var self = this, ast = this.astBuilder.ast(expression);
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, assign;
            (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
            var inputs, toWatch = getInputs(ast.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return self.identifier(ast.name, context, create);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), 
                ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(void 0, values, inputs);
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                        value = rhs.value.apply(rhs.context, values);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                    return lhs.context[lhs.name] = rhs, context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    property.computed ? args.push({
                        key: self.recurse(property.key),
                        computed: !0,
                        value: self.recurse(property.value)
                    }) : args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        computed: !1,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? +arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? -arg : -0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: void 0,
                    name: void 0,
                    value: value
                } : value;
            };
        },
        identifier: function(name, context, create) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                create && 1 !== create && base && null == base[name] && (base[name] = {});
                var value = base ? base[name] : void 0;
                return context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), 
                create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), 
                context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                var value = null != lhs ? lhs[right] : void 0;
                return context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options, this.ast = new AST(lexer, options), 
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            return this.astCompiler.compile(text);
        }
    };
    var $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g, $templateRequestMinErr = minErr("$compile"), urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
    var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
    currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, !1, !0),
        yy: dateGetter("FullYear", 2, 0, !0, !0),
        y: dateGetter("FullYear", 1, 0, !1, !0),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", !1, !0),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return attr.href || attr.xlinkHref ? void 0 : function(scope, element) {
                if ("a" === element[0].nodeName.toLowerCase()) {
                    var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        element.attr(href) || event.preventDefault();
                    });
                }
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        if ("multiple" !== propName) {
            var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
            "checked" === propName && (linkFn = function(scope, element, attr) {
                attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
            }), ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: linkFn
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, PENDING_CLASS = "ng-pending", SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ], 
    FormController.prototype = {
        $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$rollbackViewValue();
            });
        },
        $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$commitViewValue();
            });
        },
        $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), 
            control.$name && (this[control.$name] = control), control.$$parentForm = this;
        },
        $$renameControl: function(control, newName) {
            var oldName = control.$name;
            this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName;
        },
        $removeControl: function(control) {
            control.$name && this[control.$name] === control && delete this[control.$name], 
            forEach(this.$pending, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$error, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$$success, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
        },
        $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), 
            this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
        },
        $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), 
            this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                control.$setPristine();
            });
        },
        $setUntouched: function() {
            forEach(this.$$controls, function(control) {
                control.$setUntouched();
            });
        },
        $setSubmitted: function() {
            this.$$animate.addClass(this.$$element, SUBMITTED_CLASS), this.$submitted = !0, 
            this.$$parentForm.$setSubmitted();
        }
    }, addSetValidityMethod({
        clazz: FormController,
        set: function(object, property, controller) {
            var list = object[property];
            if (list) {
                var index = list.indexOf(controller);
                -1 === index && list.push(controller);
            } else object[property] = [ controller ];
        },
        unset: function(object, property, controller) {
            var list = object[property];
            list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
        }
    });
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            function getSetter(expression) {
                return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
            }
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault();
                                };
                                formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        formElement[0].removeEventListener("submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), 
                                (setter = getSetter(controller.$name))(scope, controller));
                            })), formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = !0;
    });
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        function updateElementValue(element, attr, value) {
            element.prop("value", value), attr.$set("value", value);
        }
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    var value = scope.$eval(attr.ngValue);
                    updateElementValue(elm, attr, value);
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        updateElementValue(elm, attr, value);
                    });
                };
            }
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                    return $sce.valueOf(val);
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, !0);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).done(function(response) {
                        response !== !1 && (previousElements = null);
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                            response !== !1 && (previousElement = null);
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function(response) {
                            response === !1 || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), 
                            scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return toString.call($element[0]).match(/SVG/) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : void 0;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty", ngModelMinErr = minErr("ngModel");
    NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ], 
    NgModelController.prototype = {
        $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
                var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                this.$$ngModelGet = function($scope) {
                    var modelValue = this.$$parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                }, this.$$ngModelSet = function($scope, newValue) {
                    isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: newValue
                    }) : this.$$parsedNgModelAssign($scope, newValue);
                };
            } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
        },
        $render: noop,
        $isEmpty: function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        },
        $$updateEmptyClasses: function(value) {
            this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS), 
            this.$$animate.addClass(this.$$element, EMPTY_CLASS)) : (this.$$animate.removeClass(this.$$element, EMPTY_CLASS), 
            this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS));
        },
        $setPristine: function() {
            this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), 
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
        },
        $setDirty: function() {
            this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), 
            this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
        },
        $setUntouched: function() {
            this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        },
        $setTouched: function() {
            this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        },
        $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, 
            this.$render();
        },
        $validate: function() {
            if (!isNumberNaN(this.$modelValue)) {
                var viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), that = this;
                this.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, 
                    that.$modelValue !== prevModelValue && that.$$writeModelToScope());
                });
            }
        },
        $$runValidators: function(modelValue, viewValue, doneCallback) {
            function processParseErrors() {
                var errorKey = that.$$parserName || "parse";
                return isUndefined(that.$$parserValid) ? (setValidity(errorKey, null), !0) : (that.$$parserValid || (forEach(that.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                })), setValidity(errorKey, that.$$parserValid), that.$$parserValid);
            }
            function processSyncValidators() {
                var syncValidatorsValid = !0;
                return forEach(that.$validators, function(validator, name) {
                    var result = Boolean(validator(modelValue, viewValue));
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), syncValidatorsValid ? !0 : (forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }
            function processAsyncValidators() {
                var validatorPromises = [], allValid = !0;
                forEach(that.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function() {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }
            function setValidity(name, isValid) {
                localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
            }
            this.$$currentValidationRunId++;
            var localValidationRunId = this.$$currentValidationRunId, that = this;
            return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1);
        },
        $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), 
            this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
        },
        $$parseAndValidate: function() {
            function writeToModelIfNeeded() {
                that.$modelValue !== prevModelValue && that.$$writeModelToScope();
            }
            var viewValue = this.$$lastCommittedViewValue, modelValue = viewValue, that = this;
            if (this.$$parserValid = isUndefined(modelValue) ? void 0 : !0, this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (modelValue = this.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                this.$$parserValid = !1;
                break;
            }
            isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
            var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, 
            writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
            });
        },
        $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    this.$$exceptionHandler(e);
                }
            }, this);
        },
        $setViewValue: function(value, trigger) {
            this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
        },
        $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay["default"]) && (debounceDelay = debounceDelay["default"]), 
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout(function() {
                that.$commitViewValue();
            }, debounceDelay) : this.$$scope.$root.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                that.$commitViewValue();
            });
        }
    }, addSetValidityMethod({
        clazz: NgModelController,
        set: function(object, property) {
            object[property] = !0;
        },
        unset: function(object, property) {
            delete object[property];
        }
    });
    var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                        optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), 
                        formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options.getOption("updateOn") && element.on(modelCtrl.$options.getOption("updateOn"), function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                        }), element.on("blur", function() {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    ModelOptions.prototype = {
        getOption: function(name) {
            return this.$$options[name];
        },
        createChild: function(options) {
            var inheritAll = !1;
            return options = extend({}, options), forEach(options, function(option, key) {
                "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], 
                "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, 
                options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                    return options.updateOnDefault = !0, " ";
                })));
            }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)), 
            defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
        }
    }, defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: !0,
        debounce: 0,
        getterSetter: !1,
        allowInvalid: !1,
        timezone: null
    });
    var ngModelOptionsDirective = function() {
        function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs, this.$$scope = $scope;
        }
        return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
            $onInit: function() {
                var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
        }, {
            restrict: "A",
            priority: 10,
            require: {
                parentCtrl: "?^^ngModelOptions"
            },
            bindToController: !0,
            controller: NgModelOptionsController
        };
    }, ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                }
                return optionValuesKeys;
            }
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                        if (watchedArray.push(selectValue), match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(!1);
                parent.appendChild(optionElement), updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
                var option = options.getOptionFromViewValue(viewValue), element = option && option.element;
                return element && !element.selected && (element.selected = !0), option;
            }
            function updateOptionElement(option, element) {
                option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                element.textContent = option.label), element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) for (var i = options.items.length - 1; i >= 0; i--) {
                    var option = options.items[i];
                    jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element);
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                if (providedEmptyOption && selectElement.prepend(selectCtrl.emptyOption), options.items.forEach(function(option) {
                    var groupElement;
                    isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1), 
                    listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, 
                    groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue(), isNotPrimitive = ngOptions.trackBy || multiple;
                    (isNotPrimitive ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                    ngModelCtrl.$render());
                }
            }
            for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                break;
            }
            var providedEmptyOption = !!selectCtrl.emptyOption, unknownOption = jqLite(optionTemplate.cloneNode(!1));
            unknownOption.val("?");
            var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function(val) {
                return "?";
            }, multiple ? (selectCtrl.writeValue = function(values) {
                var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                options.items.forEach(function(option) {
                    option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                });
            }, selectCtrl.readValue = function() {
                var selectedValues = selectElement.val() || [], selections = [];
                return forEach(selectedValues, function(value) {
                    var option = options.selectValueMap[value];
                    option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                }), selections;
            }, ngOptions.trackBy && scope.$watchCollection(function() {
                return isArray(ngModelCtrl.$viewValue) ? ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                }) : void 0;
            }, function() {
                ngModelCtrl.$render();
            })) : (selectCtrl.writeValue = function(value) {
                var selectedOption = options.selectValueMap[selectElement.val()], option = options.getOptionFromViewValue(value);
                selectedOption && selectedOption.element.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), 
                selectCtrl.unselectEmptyOption(), selectElement[0].value = option.selectValue, option.element.selected = !0), 
                option.element.setAttribute("selected", "selected")) : providedEmptyOption ? selectCtrl.selectEmptyOption() : selectCtrl.unknownOption.parent().length ? selectCtrl.updateUnknownOption(value) : selectCtrl.renderUnknownOption(value);
            }, selectCtrl.readValue = function() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), 
                selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
            }, ngOptions.trackBy && scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            }, function() {
                ngModelCtrl.$render();
            })), providedEmptyOption && (selectCtrl.emptyOption.remove(), $compile(selectCtrl.emptyOption)(scope), 
            selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, 
            selectCtrl.registerOption = function(optionScope, optionEl) {
                "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, 
                selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                    selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0;
                }));
            }) : selectCtrl.emptyOption.removeClass("ng-scope")), selectElement.empty(), updateOptions(), 
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "ngModel" ],
            link: {
                pre: function(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), countIsNaN = isNumberNaN(count);
                    if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                    !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                        watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                        lastCount = count;
                    }
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 === (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: void 0,
                                clone: void 0
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; length > index; index++) elementsToRemove[index][NG_REMOVED] = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, 
                            block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function(response) {
                        response !== !1 && array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                    for (i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                        runner.done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            });
            forEach(cases, function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            terminal: !0,
            compile: function(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                return tElement.empty(), function($scope, $element, $attrs, controller, $transclude) {
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        clone.length && notWhitespace(clone) ? $element.append(clone) : (useFallbackContent(), 
                        transcludedScope.$destroy());
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                    function notWhitespace(nodes) {
                        for (var i = 0, ii = nodes.length; ii > i; i++) {
                            var node = nodes[i];
                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                        }
                    }
                    if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                };
            }
        };
    } ], scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" === attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    }, SelectController = [ "$element", "$scope", function($element, $scope) {
        function scheduleRender() {
            renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                renderScheduled = !1, self.ngModelCtrl.$render();
            }));
        }
        function scheduleViewValueUpdate(renderAfter) {
            updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), 
                renderAfter && self.ngModelCtrl.$render());
            }));
        }
        function setOptionAsSelected(optionEl) {
            optionEl.prop("selected", !0), optionEl.attr("selected", !0);
        }
        var self = this, optionsMap = new HashMap();
        self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, 
        self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, 
        self.emptyOption = void 0, self.renderUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionAsSelected(self.unknownOption), 
            $element.val(unknownVal);
        }, self.updateUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), setOptionAsSelected(self.unknownOption), $element.val(unknownVal);
        }, self.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
        }, self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.selectEmptyOption = function() {
            self.emptyOption && ($element.val(""), setOptionAsSelected(self.emptyOption));
        }, self.unselectEmptyOption = function() {
            self.hasEmptyOption && self.emptyOption.removeAttr("selected");
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.readValue = function() {
            var val = $element.val(), realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
            return self.hasOption(realVal) ? realVal : null;
        }, self.writeValue = function(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption && currentlySelectedOption.removeAttribute("selected"), 
            self.hasOption(value)) {
                self.removeUnknownOption();
                var hashedVal = hashKey(value);
                $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                var selectedOption = $element[0].options[$element[0].selectedIndex];
                setOptionAsSelected(jqLite(selectedOption));
            } else null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
        }, self.addOption = function(value, element) {
            if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, 
                self.emptyOption = element);
                var count = optionsMap.get(value) || 0;
                optionsMap.put(value, count + 1), scheduleRender();
            }
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.remove(value), "" === value && (self.hasEmptyOption = !1, 
            self.emptyOption = void 0)) : optionsMap.put(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
        var renderScheduled = !1, updateScheduled = !1;
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
                var oldVal, hashedVal = NaN;
                optionAttrs.$observe("value", function(newVal) {
                    var removal, previouslySelected = optionElement.prop("selected");
                    isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], 
                    removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, 
                    self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
                });
            } else interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                self.readValue();
                var removal, previouslySelected = optionElement.prop("selected");
                isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, 
                self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
            }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                optionAttrs.$set("value", newVal);
                var previouslySelected = optionElement.prop("selected");
                oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), 
                oldVal && previouslySelected && scheduleViewValueUpdate();
            }) : self.addOption(optionAttrs.value, optionElement);
            optionAttrs.$observe("disabled", function(newVal) {
                ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), 
                self.ngModelCtrl.$render()));
            }), optionElement.on("$destroy", function() {
                var currentValue = self.readValue(), removeValue = optionAttrs.value;
                self.removeOption(removeValue), self.ngModelCtrl.$render(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
            });
        };
    } ], selectDirective = function() {
        function selectPreLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
            if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                selectCtrl.removeUnknownOption(), scope.$apply(function() {
                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                });
            }), attr.multiple) {
                selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                    var array = [];
                    return forEach(element.find("option"), function(option) {
                        if (option.selected && !option.disabled) {
                            var val = option.value;
                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                        }
                    }), array;
                }, selectCtrl.writeValue = function(value) {
                    var items = new HashMap(value);
                    forEach(element.find("option"), function(option) {
                        option.selected = isDefined(items.get(option.value)) || isDefined(items.get(selectCtrl.selectValueMap[option.value]));
                    });
                };
                var lastView, lastViewRef = NaN;
                scope.$watch(function() {
                    lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                    ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                }), ngModelCtrl.$isEmpty = function(value) {
                    return !value || 0 === value.length;
                };
            }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var selectCtrl = ctrls[0];
                ngModelCtrl.$render = function() {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
            }
        }
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: selectPreLink,
                post: selectPostLink
            }
        };
    }, optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var interpolateValueFn, interpolateTextFn;
                return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0), 
                interpolateTextFn || attr.$set("value", element.text()))), function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                };
            }
        };
    } ], requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || void 0, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = toInt(value);
                        maxlength = isNumberNaN(intVal) ? -1 : intVal, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return 0 > maxlength || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = toInt(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    };
    return window.angular.bootstrap ? void (window.console && console.log("WARNING: Tried to load angular more than once.")) : (bindJQuery(), 
    publishExternalAPI(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
        function getDecimals(n) {
            n += "";
            var i = n.indexOf(".");
            return -1 == i ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            void 0 === v && (v = Math.min(getDecimals(n), 3));
            var base = Math.pow(10, v), f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, opt_precision) {
                var i = 0 | n, vf = getVF(n, opt_precision);
                return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER;
            }
        });
    } ]), void jqLite(function() {
        angularInit(window.document, bootstrap);
    }));
}(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), 
function(window, angular) {
    "use strict";
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
        styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1);
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return element;

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        return element.nodeType === ELEMENT_NODE ? jqLite(element) : void 0;
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), 
            options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop;
            }, options.$$prepared = !0;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {}, newOptions = newAnimation.options || {}, toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
        delete newOptions.preparationClasses);
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
        classes.addClass ? target.addClass = classes.addClass : target.addClass = null, 
        classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, 
        oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, 
        target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0);
            }), obj;
        }
        var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
        forEach(toAdd, function(value, key) {
            flags[key] = ADD_CLASS;
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        return forEach(flags, function(val, klass) {
            var prop, allow;
            val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : val === REMOVE_CLASS && (prop = "removeClass", 
            allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), 
            classes[prop] += klass);
        }), classes;
    }
    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element;
    }
    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
        options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), 
        classes.length && (options.preparationClasses = classes, element.addClass(classes));
    }
    function clearGeneratedClasses(element, options) {
        options.preparationClasses && (element.removeClass(options.preparationClasses), 
        options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
        options.activeClasses = null);
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [ prop, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), 
                styles[actualStyleName] = val;
            }
        }), styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function(value) {
            "s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
        }), maxValue;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [ style, value ];
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {
                    total: 1,
                    value: value
                };
            }
        };
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", ACTIVE_CLASS_SUFFIX = "-active", PREPARE_CLASS_SUFFIX = "-prepare", NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren", CSS_PREFIX = "";
    void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? (CSS_PREFIX = "-webkit-", 
    TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
    TRANSITIONEND_EVENT = "transitionend"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? (CSS_PREFIX = "-webkit-", 
    ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
    ANIMATIONEND_EVENT = "animationend");
    var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", TIMING_KEY = "TimingFunction", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", SAFE_FAST_FORWARD_DURATION_VALUE = 9999, ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY, ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY, TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, ngMinErr = angular.$$minErr("ng"), $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick();
        }
        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
        var queue, cancelFn;
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
    } ], $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
        return {
            link: function(scope, element, attrs) {
                function setData(value) {
                    value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value);
                }
                var val = attrs.ngAnimateChildren;
                isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : (setData($interpolate(val)(scope)), 
                attrs.$observe("ngAnimateChildren", setData));
            }
        };
    } ], ANIMATE_TIMER_KEY = "$$animateCss", ONE_SECOND = 1e3, ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode, parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), 
                gcsLookup.put(cacheKey, timings), timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && (stagger = gcsStaggerLookup.get(cacheKey), 
                !stagger)) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), 
                    stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), 
                    $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger);
                }
                return stagger || {};
            }
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, rafWaitQueue = [];
            return function(element, initialOptions) {
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    if (!(animationClosed || animationCompleted && animationPaused)) {
                        animationClosed = !0, animationPaused = !1, options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses), 
                        $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                        blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                            node.style[entry[0]] = "";
                        }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                        Object.keys(restoreStyles).length && forEach(restoreStyles, function(value, prop) {
                            value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                        }), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress);
                        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                        animationTimerData && ($timeout.cancel(animationTimerData[0].timer), element.removeData(ANIMATE_TIMER_KEY)), 
                        runner && runner.complete(!rejected);
                    }
                }
                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                    close());
                }
                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(entry) {
                                var key = entry[0], value = entry[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (fullClassName = node.getAttribute("class") + " " + preparationClasses, cacheKey = gcsHashFn(node, fullClassName), 
                                timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, 0 === maxDuration) return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                            }
                            if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                            maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                            temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = maxDelay * ONE_SECOND, 
                            maxDurationTime = maxDuration * ONE_SECOND, options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([ easeProp, easeVal ]), 
                                node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, 
                                temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now();
                            var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data(ANIMATE_TIMER_KEY) || [], setupFallbackTimer = !0;
                            if (animationsData.length) {
                                var currentTimerData = animationsData[0];
                                setupFallbackTimer = endTime > currentTimerData.expectedEndTime, setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close);
                            }
                            if (setupFallbackTimer) {
                                var timer = $timeout(onAnimationExpired, timerTime, !1);
                                animationsData[0] = {
                                    timer: timer,
                                    expectedEndTime: endTime
                                }, animationsData.push(close), element.data(ANIMATE_TIMER_KEY, animationsData);
                            }
                            events.length && element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                            applyAnimationToStyles(element, options));
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                            element.removeData(ANIMATE_TIMER_KEY);
                        }
                    }
                    if (!animationClosed) {
                        if (!node.parentNode) return void close();
                        var playPause = function(playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                            close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), 
                        runnerHost.resume = function() {
                            playPause(!0);
                        }, runnerHost.pause = function() {
                            playPause(!1);
                        };
                    }
                }
                var options = initialOptions || {};
                options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, startTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options), events = [];
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), fullClassName = classes + " " + preparationClasses, activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX), hasToStyles = styles.to && Object.keys(styles.to).length > 0, containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                if (null != options.delay) {
                    var delayStyle;
                    "boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), maxDelay = Math.max(delayStyle, 0)), 
                    flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                    flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0));
                }
                return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, !1), 
                {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        return animationClosed ? void 0 : (runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner);
                    }
                };
            };
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        function isDocumentFragment(node) {
            return node.parentNode && 11 === node.parentNode.nodeType;
        }
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out", NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                        }
                        styles[key] = Math.floor(value) + "px";
                    }), styles;
                }
                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), 
                clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME), rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut && (animatorIn = prepareInAnimation(), !animatorIn)) return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        function endFn() {
                            currentAnimation && currentAnimation.end();
                        }
                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function() {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), 
                            currentAnimation.done(function() {
                                currentAnimation = null, end(), runner.complete();
                            }), currentAnimation) : (end(), void runner.complete());
                        }), runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                    }
                };
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from, noop), toAnimation = prepareRegularAnimation(to, noop), anchorAnimations = [];
                return forEach(anchors, function(anchor) {
                    var outElement = anchor.out, inElement = anchor["in"], animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                    start: function() {
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                    }
                } : void 0;
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, 
                options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), 
                options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                    flagMap[klass] = !0);
                }
                return matches;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function close() {
                    animationClosed = !0, applyOptions(), applyAnimationStyles(element, options);
                }
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            };
                            return runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                var cancelled = result === !1;
                                onAnimationComplete(cancelled);
                            }), runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                        a && (operations = operations.concat(a)), b && (operations = operations.concat(b));
                    }
                    if (0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
                var animationClosed = !1;
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" === event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                    afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                if (before || after) {
                    var runner;
                    return {
                        $$willAnimate: !0,
                        end: function() {
                            return runner ? runner.end() : (close(), runner = new $$AnimateRunner(), runner.complete(!0)), 
                            runner;
                        },
                        start: function() {
                            function onComplete(success) {
                                close(success), runner.complete(success);
                            }
                            function endAnimations(cancelled) {
                                animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                            }
                            if (runner) return runner;
                            runner = new $$AnimateRunner();
                            var closeActiveAnimations, chain = [];
                            return before && chain.push(function(fn) {
                                closeActiveAnimations = before(fn);
                            }), chain.length ? chain.push(function(fn) {
                                applyOptions(), fn(!0);
                            }) : applyOptions(), after && chain.push(function(fn) {
                                closeActiveAnimations = after(fn);
                            }), runner.setHost({
                                end: function() {
                                    endAnimations();
                                },
                                cancel: function() {
                                    endAnimations(!0);
                                }
                            }), $$AnimateRunner.chain(chain, onComplete), runner;
                        }
                    };
                }
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
            return function(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                        }
                    };
                }
                return prepareAnimation(animationDetails);
            };
        } ];
    } ], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        function makeTruthyCssClassMap(classString) {
            if (!classString) return null;
            var keys = classString.split(ONE_SPACE), map = Object.create(null);
            return forEach(keys, function(key) {
                map[key] = !0;
            }), map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = makeTruthyCssClassMap(currentClassString);
                return newClassString.split(ONE_SPACE).some(function(className) {
                    return currentClassMap[className];
                });
            }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(element, currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(animation, and) {
            var a = (animation.addClass || "").length > 0, b = (animation.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, ONE_SPACE = " ", rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return "leave" === currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            if (currentAnimation.structural) return !1;
            var nA = newAnimation.addClass, nR = newAnimation.removeClass, cA = currentAnimation.addClass, cR = currentAnimation.removeClass;
            return isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR) ? !1 : hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
            function postDigestTaskFactory() {
                var postDigestCalled = !1;
                return function(fn) {
                    postDigestCalled ? fn() : $rootScope.$$postDigest(function() {
                        postDigestCalled = !0, fn();
                    });
                };
            }
            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {});
            }
            function findCallbacks(parent, element, event) {
                var targetNode = getDomNode(element), targetParentNode = getDomNode(parent), matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function(entry) {
                    contains.call(entry.node, targetNode) ? matches.push(entry.callback) : "leave" === event && contains.call(entry.node, targetParentNode) && matches.push(entry.callback);
                }), matches;
            }
            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                    var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                    return !isMatch;
                });
            }
            function cleanupEventListeners(phase, element) {
                "close" !== phase || element[0].parentNode || $animate.off(element);
            }
            function queueAnimation(element, event, initialOptions) {
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function() {
                        var callbacks = findCallbacks(parent, element, event);
                        callbacks.length ? $$rAF(function() {
                            forEach(callbacks, function(callback) {
                                callback(element, phase, data);
                            }), cleanupEventListeners(phase, element);
                        }) : cleanupEventListeners(phase, element);
                    }), runner.progress(event, phase, data);
                }
                function close(reject) {
                    clearGeneratedClasses(element, options), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), runner.complete(!reject);
                }
                var node, parent, options = copy(initialOptions);
                element = stripCommentsFromElement(element), element && (node = getDomNode(element), 
                parent = element.parent()), options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner(), runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), 
                options.addClass && !isString(options.addClass) && (options.addClass = null), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), 
                options.removeClass && !isString(options.removeClass) && (options.removeClass = null), 
                options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null), 
                !node) return close(), runner;
                var className = [ node.getAttribute("class"), options.addClass, options.removeClass ].join(" ");
                if (!isAnimatableClassName(className)) return close(), runner;
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, documentHidden = $$isDocumentHidden(), skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state === PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(element, parent, event)), 
                skipAnimations) return documentHidden && notifyProgress(runner, event, "start"), 
                close(), documentHidden && notifyProgress(runner, event, "close"), runner;
                isStructural && closeChildAnimations(element);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    addClass: options.addClass,
                    removeClass: options.removeClass,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", element, newAnimation, existingAnimation);
                    if (skipAnimationFlag) return existingAnimation.state === RUNNING_STATE ? (close(), 
                    runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                    var cancelAnimationFlag = isAllowed("cancel", element, newAnimation, existingAnimation);
                    if (cancelAnimationFlag) if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end(); else {
                        if (!existingAnimation.structural) return mergeAnimationDetails(element, existingAnimation, newAnimation), 
                        existingAnimation.runner;
                        existingAnimation.close();
                    } else {
                        var joinAnimationFlag = isAllowed("join", element, newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state !== RUNNING_STATE) return applyGeneratedPreparationClasses(element, isStructural ? event : null, options), 
                            event = newAnimation.event = existingAnimation.event, options = mergeAnimationDetails(element, existingAnimation, newAnimation), 
                            existingAnimation.runner;
                            normalizeAnimationDetails(element, newAnimation);
                        }
                    }
                } else normalizeAnimationDetails(element, newAnimation);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation)), 
                !isValidAnimation) return close(), clearElementAnimationState(element), runner;
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation), 
                $rootScope.$$postDigest(function() {
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                    runner.end()), void (isValidAnimation || clearElementAnimationState(element));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, !0) ? "setClass" : animationDetails.event, 
                    markElementAnimationState(element, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    runner.setHost(realRunner), notifyProgress(runner, event, "start", {}), realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(getDomNode(element)), 
                        notifyProgress(runner, event, "close", {});
                    });
                }), runner;
            }
            function closeChildAnimations(element) {
                var node = getDomNode(element), children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10), animationDetails = activeAnimationsLookup.get(child);
                    if (animationDetails) switch (state) {
                      case RUNNING_STATE:
                        animationDetails.runner.end();

                      case PRE_DIGEST_STATE:
                        activeAnimationsLookup.remove(child);
                    }
                });
            }
            function clearElementAnimationState(element) {
                var node = getDomNode(element);
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.remove(node);
            }
            function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
            }
            function areAnimationsAllowed(element, parentElement, event) {
                var animateChildren, bodyElement = jqLite($document[0].body), bodyElementDetected = isMatchingElement(element, bodyElement) || "HTML" === element[0].nodeName, rootElementDetected = isMatchingElement(element, $rootElement), parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(getDomNode(element)), parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentElement = parentHost), parentElement = getDomNode(parentElement); parentElement && (rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement)), 
                parentElement.nodeType === ELEMENT_NODE); ) {
                    var details = activeAnimationsLookup.get(parentElement) || {};
                    if (!parentAnimationDetected) {
                        var parentElementDisabled = disabledElementsLookup.get(parentElement);
                        if (parentElementDisabled === !0 && elementDisabled !== !1) {
                            elementDisabled = !0;
                            break;
                        }
                        parentElementDisabled === !1 && (elementDisabled = !1), parentAnimationDetected = details.structural;
                    }
                    if (isUndefined(animateChildren) || animateChildren === !0) {
                        var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value);
                    }
                    if (parentAnimationDetected && animateChildren === !1) break;
                    if (bodyElementDetected || (bodyElementDetected = isMatchingElement(parentElement, bodyElement)), 
                    bodyElementDetected && rootElementDetected) break;
                    parentElement = rootElementDetected || !(parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA)) ? parentElement.parentNode : getDomNode(parentHost);
                }
                var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== !0;
                return allowAnimation && rootElementDetected && bodyElementDetected;
            }
            function markElementAnimationState(element, state, details) {
                details = details || {}, details.state = state;
                var node = getDomNode(element);
                node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.put(node, newValue);
            }
            var activeAnimationsLookup = new $$HashMap(), disabledElementsLookup = new $$HashMap(), animationsEnabled = null, deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), callbackRegistry = Object.create(null), classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
                return classNameFilter.test(className);
            } : function() {
                return !0;
            }, applyAnimationClasses = applyAnimationClassesFactory($$jqLite), contains = window.Node.prototype.contains || function(arg) {
                return this === arg || !!(16 & this.compareDocumentPosition(arg));
            }, $animate = {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    }), jqLite(container).on("$destroy", function() {
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails || $animate.off(event, container, callback);
                    });
                },
                off: function(event, container, callback) {
                    if (1 !== arguments.length || isString(arguments[0])) {
                        var entries = callbackRegistry[event];
                        entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                    } else {
                        container = arguments[0];
                        for (var eventType in callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                    }
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        var hasElement = isElement(element);
                        if (hasElement) {
                            var node = getDomNode(element);
                            1 === argCount ? bool = !disabledElementsLookup.get(node) : disabledElementsLookup.put(node, !bool);
                        } else bool = animationsEnabled = !!element;
                    }
                    return bool;
                }
            };
            return $animate;
        } ];
    } ], $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
            function sortAnimations(animations) {
                function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode, parentNode = elementNode.parentNode;
                    lookup.put(elementNode, entry);
                    for (var parentEntry; parentNode; ) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    return (parentEntry || tree).children.push(entry), entry;
                }
                function flatten(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        0 >= remainingLevelEntries && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                        result.push(row), row = []), row.push(entry.fn), entry.children.forEach(function(childEntry) {
                            nextLevelEntries++, queue.push(childEntry);
                        }), remainingLevelEntries--;
                    }
                    return row.length && result.push(row), result;
                }
                var i, tree = {
                    children: []
                }, lookup = new $$HashMap();
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.put(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) processNode(animations[i]);
                return flatten(tree);
            }
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node);
                    }), anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else preparedAnimations.push(animation);
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function(operations, key) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void (usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])));
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation));
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            "in": to.element
                        });
                    }), preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                            matches.push(aa);
                            break;
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i], factory = $injector.get(driverName), driver = factory(animationDetails);
                        if (driver) return driver;
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses), 
                    prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null);
                }
                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        var runner = getRunner(element);
                        runner && runner.setHost(newRunner);
                    }
                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected);
                }
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                tempClasses && (classes += " " + tempClasses, options.tempClasses = null);
                var prepareClassName;
                return isStructural && (prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX, 
                $$jqLite.addClass(element, prepareClassName)), animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) ? animations.push(entry) : entry.close();
                    }), animationQueue.length = 0;
                    var groupedAnimations = groupAnimations(animations), toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        toBeSortedAnimations.push({
                            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                            fn: function() {
                                animationEntry.beforeStart();
                                var startAnimationFn, closeFn = animationEntry.close, targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                if (getRunner(targetElement)) {
                                    var operation = invokeFirstDriver(animationEntry);
                                    operation && (startAnimationFn = operation.start);
                                }
                                if (startAnimationFn) {
                                    var animationRunner = startAnimationFn();
                                    animationRunner.done(function(status) {
                                        closeFn(!status);
                                    }), updateAnimationRunners(animationEntry, animationRunner);
                                } else closeFn();
                            }
                        });
                    }), $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                }), runner);
            };
        } ];
    } ], ngAnimateSwapDirective = [ "$animate", "$rootScope", function($animate, $rootScope) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: !0,
            priority: 600,
            link: function(scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function(value) {
                    previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), 
                    previousScope = null), (value || 0 === value) && (previousScope = scope.$new(), 
                    $transclude(previousScope, function(element) {
                        previousElement = element, $animate.enter(element, null, $element);
                    }));
                });
            }
        };
    } ];
    angular.module("ngAnimate", [], function() {
        noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, 
        forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, 
        isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, 
        isFunction = angular.isFunction, isElement = angular.isElement;
    }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), function(window, angular) {
    "use strict";
    function isValidDottedPath(path) {
        return null != path && "" !== path && "hasOwnProperty" !== path && MEMBER_NAME_REGEX.test("." + path);
    }
    function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path)) throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
        for (var keys = path.split("."), i = 0, ii = keys.length; ii > i && angular.isDefined(obj); i++) {
            var key = keys[i];
            obj = null !== obj ? obj[key] : void 0;
        }
        return obj;
    }
    function shallowClearAndCopy(src, dst) {
        dst = dst || {}, angular.forEach(dst, function(value, key) {
            delete dst[key];
        });
        for (var key in src) !src.hasOwnProperty(key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        return dst;
    }
    var $resourceMinErr = angular.$$minErr("$resource"), MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    angular.module("ngResource", [ "ng" ]).provider("$resource", function() {
        var PROTOCOL_AND_IPV6_REGEX = /^https?:\/\/\[[^\]]*][^\/]*/, provider = this;
        this.defaults = {
            stripTrailingSlashes: !0,
            cancellable: !1,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: !0
                },
                remove: {
                    method: "DELETE"
                },
                "delete": {
                    method: "DELETE"
                }
            }
        }, this.$get = [ "$http", "$log", "$q", "$timeout", function($http, $log, $q, $timeout) {
            function Route(template, defaults) {
                this.template = template, this.defaults = extend({}, provider.defaults, defaults), 
                this.urlParams = {};
            }
            function resourceFactory(url, paramDefaults, actions, options) {
                function extractParams(data, actionParams) {
                    var ids = {};
                    return actionParams = extend({}, paramDefaults, actionParams), forEach(actionParams, function(value, key) {
                        isFunction(value) && (value = value(data)), ids[key] = value && value.charAt && "@" === value.charAt(0) ? lookupDottedPath(data, value.substr(1)) : value;
                    }), ids;
                }
                function defaultResponseInterceptor(response) {
                    return response.resource;
                }
                function Resource(value) {
                    shallowClearAndCopy(value || {}, this);
                }
                var route = new Route(url, options);
                return actions = extend({}, provider.defaults.actions, actions), Resource.prototype.toJSON = function() {
                    var data = extend({}, this);
                    return delete data.$promise, delete data.$resolved, data;
                }, forEach(actions, function(action, name) {
                    var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method), numericTimeout = action.timeout, cancellable = isDefined(action.cancellable) ? action.cancellable : route.defaults.cancellable;
                    numericTimeout && !isNumber(numericTimeout) && ($log.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."), 
                    delete action.timeout, numericTimeout = null), Resource[name] = function(a1, a2, a3, a4) {
                        function cancelRequest(value) {
                            promise["catch"](noop), timeoutDeferred.resolve(value);
                        }
                        var data, success, error, params = {};
                        switch (arguments.length) {
                          case 4:
                            error = a4, success = a3;

                          case 3:
                          case 2:
                            if (!isFunction(a2)) {
                                params = a1, data = a2, success = a3;
                                break;
                            }
                            if (isFunction(a1)) {
                                success = a1, error = a2;
                                break;
                            }
                            success = a2, error = a3;

                          case 1:
                            isFunction(a1) ? success = a1 : hasBody ? data = a1 : params = a1;
                            break;

                          case 0:
                            break;

                          default:
                            throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                        }
                        var timeoutDeferred, numericTimeoutPromise, isInstanceCall = this instanceof Resource, value = isInstanceCall ? data : action.isArray ? [] : new Resource(data), httpConfig = {}, responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor, responseErrorInterceptor = action.interceptor && action.interceptor.responseError || void 0, hasError = !!error, hasResponseErrorInterceptor = !!responseErrorInterceptor;
                        forEach(action, function(value, key) {
                            switch (key) {
                              default:
                                httpConfig[key] = copy(value);
                                break;

                              case "params":
                              case "isArray":
                              case "interceptor":
                              case "cancellable":                            }
                        }), !isInstanceCall && cancellable && (timeoutDeferred = $q.defer(), httpConfig.timeout = timeoutDeferred.promise, 
                        numericTimeout && (numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout))), 
                        hasBody && (httpConfig.data = data), route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                        var promise = $http(httpConfig).then(function(response) {
                            var data = response.data;
                            if (data) {
                                if (isArray(data) !== !!action.isArray) throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                if (action.isArray) value.length = 0, forEach(data, function(item) {
                                    "object" == typeof item ? value.push(new Resource(item)) : value.push(item);
                                }); else {
                                    var promise = value.$promise;
                                    shallowClearAndCopy(data, value), value.$promise = promise;
                                }
                            }
                            return response.resource = value, response;
                        });
                        return promise = promise["finally"](function() {
                            value.$resolved = !0, !isInstanceCall && cancellable && (value.$cancelRequest = noop, 
                            $timeout.cancel(numericTimeoutPromise), timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null);
                        }), promise = promise.then(function(response) {
                            var value = responseInterceptor(response);
                            return (success || noop)(value, response.headers, response.status, response.statusText), 
                            value;
                        }, hasError || hasResponseErrorInterceptor ? function(response) {
                            return hasError && error(response), hasResponseErrorInterceptor ? responseErrorInterceptor(response) : $q.reject(response);
                        } : void 0), hasError && !hasResponseErrorInterceptor && promise["catch"](noop), 
                        isInstanceCall ? promise : (value.$promise = promise, value.$resolved = !1, cancellable && (value.$cancelRequest = cancelRequest), 
                        value);
                    }, Resource.prototype["$" + name] = function(params, success, error) {
                        isFunction(params) && (error = success, success = params, params = {});
                        var result = Resource[name].call(this, params, this, success, error);
                        return result.$promise || result;
                    };
                }), Resource.bind = function(additionalParamDefaults) {
                    var extendedParamDefaults = extend({}, paramDefaults, additionalParamDefaults);
                    return resourceFactory(url, extendedParamDefaults, actions, options);
                }, Resource;
            }
            var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isArray = angular.isArray, isDefined = angular.isDefined, isFunction = angular.isFunction, isNumber = angular.isNumber, encodeUriQuery = angular.$$encodeUriQuery, encodeUriSegment = angular.$$encodeUriSegment;
            return Route.prototype = {
                setUrlParams: function(config, params, actionUrl) {
                    var val, encodedVal, self = this, url = actionUrl || self.template, protocolAndIpv6 = "", urlParams = self.urlParams = Object.create(null);
                    forEach(url.split(/\W/), function(param) {
                        if ("hasOwnProperty" === param) throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                        !new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url) && (urlParams[param] = {
                            isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)
                        });
                    }), url = url.replace(/\\:/g, ":"), url = url.replace(PROTOCOL_AND_IPV6_REGEX, function(match) {
                        return protocolAndIpv6 = match, "";
                    }), params = params || {}, forEach(self.urlParams, function(paramInfo, urlParam) {
                        val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam], 
                        isDefined(val) && null !== val ? (encodedVal = paramInfo.isQueryParamValue ? encodeUriQuery(val, !0) : encodeUriSegment(val), 
                        url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                            return encodedVal + p1;
                        })) : url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                            return "/" === tail.charAt(0) ? tail : leadingSlashes + tail;
                        });
                    }), self.defaults.stripTrailingSlashes && (url = url.replace(/\/+$/, "") || "/"), 
                    url = url.replace(/\/\.(?=\w+($|\?))/, "."), config.url = protocolAndIpv6 + url.replace(/\/\\\./, "/."), 
                    forEach(params, function(value, key) {
                        self.urlParams[key] || (config.params = config.params || {}, config.params[key] = value);
                    });
                }
            }, resourceFactory;
        } ];
    });
}(window, window.angular), function(window, angular) {
    "use strict";
    function nodeName_(element) {
        return angular.lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function $TouchProvider($provide, $compileProvider) {
        var ngClickOverrideEnabled = !1, ngClickDirectiveAdded = !1;
        this.ngClickOverrideEnabled = function(enabled) {
            return angular.isDefined(enabled) ? (enabled && !ngClickDirectiveAdded && (ngClickDirectiveAdded = !0, 
            ngTouchClickDirectiveFactory.$$moduleName = "ngTouch", $compileProvider.directive("ngClick", ngTouchClickDirectiveFactory), 
            $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
                if (ngClickOverrideEnabled) $delegate.shift(); else for (var i = $delegate.length - 1; i >= 0; ) {
                    if ("ngTouch" === $delegate[i].$$moduleName) {
                        $delegate.splice(i, 1);
                        break;
                    }
                    i--;
                }
                return $delegate;
            } ])), ngClickOverrideEnabled = enabled, this) : ngClickOverrideEnabled;
        }, this.$get = function() {
            return {
                ngClickOverrideEnabled: function() {
                    return ngClickOverrideEnabled;
                }
            };
        };
    }
    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, [ "$parse", "$swipe", function($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75, MAX_VERTICAL_RATIO = .3, MIN_HORIZONTAL_DISTANCE = 30;
            return function(scope, element, attr) {
                function validSwipe(coords) {
                    if (!startCoords) return !1;
                    var deltaY = Math.abs(coords.y - startCoords.y), deltaX = (coords.x - startCoords.x) * direction;
                    return valid && MAX_VERTICAL_DISTANCE > deltaY && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && MAX_VERTICAL_RATIO > deltaY / deltaX;
                }
                var startCoords, valid, swipeHandler = $parse(attr[directiveName]), pointerTypes = [ "touch" ];
                angular.isDefined(attr.ngSwipeDisableMouse) || pointerTypes.push("mouse"), $swipe.bind(element, {
                    start: function(coords, event) {
                        startCoords = coords, valid = !0;
                    },
                    cancel: function(event) {
                        valid = !1;
                    },
                    end: function(coords, event) {
                        validSwipe(coords) && scope.$apply(function() {
                            element.triggerHandler(eventName), swipeHandler(scope, {
                                $event: event
                            });
                        });
                    }
                }, pointerTypes);
            };
        } ]);
    }
    var ngTouch = angular.module("ngTouch", []);
    ngTouch.provider("$touch", $TouchProvider), $TouchProvider.$inject = [ "$provide", "$compileProvider" ], 
    ngTouch.factory("$swipe", [ function() {
        function getCoordinates(event) {
            var originalEvent = event.originalEvent || event, touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ], e = originalEvent.changedTouches && originalEvent.changedTouches[0] || touches[0];
            return {
                x: e.clientX,
                y: e.clientY
            };
        }
        function getEvents(pointerTypes, eventType) {
            var res = [];
            return angular.forEach(pointerTypes, function(pointerType) {
                var eventName = POINTER_EVENTS[pointerType][eventType];
                eventName && res.push(eventName);
            }), res.join(" ");
        }
        var MOVE_BUFFER_RADIUS = 10, POINTER_EVENTS = {
            mouse: {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            },
            touch: {
                start: "touchstart",
                move: "touchmove",
                end: "touchend",
                cancel: "touchcancel"
            },
            pointer: {
                start: "pointerdown",
                move: "pointermove",
                end: "pointerup",
                cancel: "pointercancel"
            }
        };
        return {
            bind: function(element, eventHandlers, pointerTypes) {
                var totalX, totalY, startCoords, lastPos, active = !1;
                pointerTypes = pointerTypes || [ "mouse", "touch", "pointer" ], element.on(getEvents(pointerTypes, "start"), function(event) {
                    startCoords = getCoordinates(event), active = !0, totalX = 0, totalY = 0, lastPos = startCoords, 
                    eventHandlers.start && eventHandlers.start(startCoords, event);
                });
                var events = getEvents(pointerTypes, "cancel");
                events && element.on(events, function(event) {
                    active = !1, eventHandlers.cancel && eventHandlers.cancel(event);
                }), element.on(getEvents(pointerTypes, "move"), function(event) {
                    if (active && startCoords) {
                        var coords = getCoordinates(event);
                        if (totalX += Math.abs(coords.x - lastPos.x), totalY += Math.abs(coords.y - lastPos.y), 
                        lastPos = coords, !(MOVE_BUFFER_RADIUS > totalX && MOVE_BUFFER_RADIUS > totalY)) return totalY > totalX ? (active = !1, 
                        void (eventHandlers.cancel && eventHandlers.cancel(event))) : (event.preventDefault(), 
                        void (eventHandlers.move && eventHandlers.move(coords, event)));
                    }
                }), element.on(getEvents(pointerTypes, "end"), function(event) {
                    active && (active = !1, eventHandlers.end && eventHandlers.end(getCoordinates(event), event));
                });
            }
        };
    } ]);
    var ngTouchClickDirectiveFactory = [ "$parse", "$timeout", "$rootElement", function($parse, $timeout, $rootElement) {
        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
        }
        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2) if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) return touchCoordinates.splice(i, i + 2), 
            !0;
            return !1;
        }
        function onClick(event) {
            if (!(Date.now() - lastPreventedTime > PREVENT_DURATION)) {
                var touches = event.touches && event.touches.length ? event.touches : [ event ], x = touches[0].clientX, y = touches[0].clientY;
                1 > x && 1 > y || lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y || (lastLabelClickCoordinates && (lastLabelClickCoordinates = null), 
                "label" === nodeName_(event.target) && (lastLabelClickCoordinates = [ x, y ]), checkAllowableRegions(touchCoordinates, x, y) || (event.stopPropagation(), 
                event.preventDefault(), event.target && event.target.blur && event.target.blur()));
            }
        }
        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ], x = touches[0].clientX, y = touches[0].clientY;
            touchCoordinates.push(x, y), $timeout(function() {
                for (var i = 0; i < touchCoordinates.length; i += 2) if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) return void touchCoordinates.splice(i, i + 2);
            }, PREVENT_DURATION, !1);
        }
        function preventGhostClick(x, y) {
            touchCoordinates || ($rootElement[0].addEventListener("click", onClick, !0), $rootElement[0].addEventListener("touchstart", onTouchStart, !0), 
            touchCoordinates = []), lastPreventedTime = Date.now(), checkAllowableRegions(touchCoordinates, x, y);
        }
        var lastPreventedTime, touchCoordinates, lastLabelClickCoordinates, TAP_DURATION = 750, MOVE_TOLERANCE = 12, PREVENT_DURATION = 2500, CLICKBUSTER_THRESHOLD = 25, ACTIVE_CLASS_NAME = "ng-click-active";
        return function(scope, element, attr) {
            function resetState() {
                tapping = !1, element.removeClass(ACTIVE_CLASS_NAME);
            }
            var tapElement, startTime, touchStartX, touchStartY, clickHandler = $parse(attr.ngClick), tapping = !1;
            element.on("touchstart", function(event) {
                tapping = !0, tapElement = event.target ? event.target : event.srcElement, 3 === tapElement.nodeType && (tapElement = tapElement.parentNode), 
                element.addClass(ACTIVE_CLASS_NAME), startTime = Date.now();
                var originalEvent = event.originalEvent || event, touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ], e = touches[0];
                touchStartX = e.clientX, touchStartY = e.clientY;
            }), element.on("touchcancel", function(event) {
                resetState();
            }), element.on("touchend", function(event) {
                var diff = Date.now() - startTime, originalEvent = event.originalEvent || event, touches = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches : originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ], e = touches[0], x = e.clientX, y = e.clientY, dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
                tapping && TAP_DURATION > diff && MOVE_TOLERANCE > dist && (preventGhostClick(x, y), 
                tapElement && tapElement.blur(), angular.isDefined(attr.disabled) && attr.disabled !== !1 || element.triggerHandler("click", [ event ])), 
                resetState();
            }), element.onclick = function(event) {}, element.on("click", function(event, touchend) {
                scope.$apply(function() {
                    clickHandler(scope, {
                        $event: touchend || event
                    });
                });
            }), element.on("mousedown", function(event) {
                element.addClass(ACTIVE_CLASS_NAME);
            }), element.on("mousemove mouseup", function(event) {
                element.removeClass(ACTIVE_CLASS_NAME);
            });
        };
    } ];
    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft"), makeSwipeDirective("ngSwipeRight", 1, "swiperight");
}(window, window.angular), "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(window, angular, undefined) {
    "use strict";
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst.hasOwnProperty(key) || (dst[key] = value);
            });
        }), dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) return Object.keys(object);
        var result = [];
        return forEach(object, function(val, key) {
            result.push(key);
        }), result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) return array.indexOf(value, Number(arguments[2]) || 0);
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        for (from = 0 > from ? Math.ceil(from) : Math.floor(from), 0 > from && (from += len); len > from; from++) if (from in array && array[from] === value) return from;
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parentParams, parents = ancestors($current, $to), inherited = {}, inheritList = [];
        for (var i in parents) if (parents[i] && parents[i].params && (parentParams = objectKeys(parents[i].params), 
        parentParams.length)) for (var j in parentParams) indexOf(inheritList, parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), 
        inherited[parentParams[j]] = currentParams[parentParams[j]]);
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return !1;
        }
        return !0;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        return forEach(keys, function(name) {
            filtered[name] = values[name];
        }), filtered;
    }
    function pick(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return forEach(keys, function(key) {
            key in obj && (copy[key] = obj[key]);
        }), copy;
    }
    function omit(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) -1 == indexOf(keys, key) && (copy[key] = obj[key]);
        return copy;
    }
    function filter(collection, callback) {
        var array = isArray(collection), result = array ? [] : {};
        return forEach(collection, function(val, i) {
            callback(val, i) && (result[array ? result.length : i] = val);
        }), result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        return forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        }), result;
    }
    function silenceUncaughtInPromise(promise) {
        return promise.then(undefined, function() {}) && promise;
    }
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            function visit(value, key) {
                if (visited[key] !== VISIT_DONE) {
                    if (cycle.push(key), visited[key] === VISIT_IN_PROGRESS) throw cycle.splice(0, indexOf(cycle, key)), 
                    new Error("Cyclic dependency: " + cycle.join(" -> "));
                    if (visited[key] = VISIT_IN_PROGRESS, isString(value)) plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES); else {
                        var params = $injector.annotate(value);
                        forEach(params, function(param) {
                            param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param);
                        }), plan.push(key, value, params);
                    }
                    cycle.pop(), visited[key] = VISIT_DONE;
                }
            }
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {}), plan = [], cycle = [], visited = {};
            return forEach(invocables, visit), invocables = cycle = visited = null, function(locals, parent, self) {
                function done() {
                    --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = result.$$promises || !0, 
                    delete result.$$inheritedValues, resolution.resolve(values));
                }
                function fail(reason) {
                    result.$$failure = reason, resolution.reject(reason);
                }
                function invoke(key, invocable, params) {
                    function onfailure(reason) {
                        invocation.reject(reason), fail(reason);
                    }
                    function proceed() {
                        if (!isDefined(result.$$failure)) try {
                            invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                values[key] = result, done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    var invocation = $q.defer(), waitParams = 0;
                    forEach(params, function(dep) {
                        promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                            values[dep] = result, --waitParams || proceed();
                        }, onfailure));
                    }), waitParams || proceed(), promises[key] = invocation.promise;
                }
                if (isResolve(locals) && self === undefined && (self = parent, parent = locals, 
                locals = null), locals) {
                    if (!isObject(locals)) throw new Error("'locals' must be an object");
                } else locals = NO_LOCALS;
                if (parent) {
                    if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else parent = NO_PARENT;
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = !1;
                if (isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                parent.$$inheritedValues && merge(values, omit(parent.$$inheritedValues, invocableKeys)), 
                extend(promises, parent.$$promises), parent.$$values ? (merged = merge(values, omit(parent.$$values, invocableKeys)), 
                result.$$inheritedValues = omit(parent.$$values, invocableKeys), done()) : (parent.$$inheritedValues && (result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)), 
                parent.then(done, fail));
                for (var i = 0, ii = plan.length; ii > i; i += 3) locals.hasOwnProperty(plan[i]) ? done() : invoke(plan[i], plan[i + 1], plan[i + 2]);
                return result;
            };
        }, this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        }, this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, this.fromUrl = function(url, params) {
            return isFunction(url) && (url = url(params)), null == url ? null : $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        }, this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    function UrlMatcher(pattern, config, parentMatcher) {
        function addParameter(id, type, config, location) {
            if (paramNames.push(id), parentParams[id]) return parentParams[id];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            return params[id] = new $$UMFP.Param(id, type, config, location), params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case !1:
                surroundPattern = [ "(", ")" + (optional ? "?" : "") ];
                break;

              case !0:
                result = result.replace(/\/$/, ""), surroundPattern = [ "(?:/(", ")|/)?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg;
            return id = m[2] || m[3], cfg = config.params[id], segment = pattern.substring(last, m.index), 
            regexp = isSearch ? m[4] : m[4] || ("*" == m[1] ? ".*" : null), regexp && (type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
            })), {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var m, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        this.source = pattern;
        for (var p, param, segment; (m = placeholder.exec(pattern)) && (p = matchDetails(m, !1), 
        !(p.segment.indexOf("?") >= 0)); ) param = addParameter(p.id, p.type, p.cfg, "path"), 
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional), 
        segments.push(p.segment), last = placeholder.lastIndex;
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            if (segment = segment.substring(0, i), this.sourcePath = pattern.substring(0, last + i), 
            search.length > 0) for (last = 0; m = searchPlaceholder.exec(search); ) p = matchDetails(m, !0), 
            param = addParameter(p.id, p.type, p.cfg, "search"), last = placeholder.lastIndex;
        } else this.sourcePath = pattern, this.sourceSearch = "";
        compiled += quoteRegExp(segment) + (config.strict === !1 ? "/?" : "") + "$", segments.push(segment), 
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined), this.prefix = segments[0], 
        this.$$paramNames = paramNames;
    }
    function Type(config) {
        extend(this, config);
    }
    function $UrlMatcherFactory() {
        function valToString(val) {
            return null != val ? val.toString().replace(/(~|\/)/g, function(m) {
                return {
                    "~": "~~",
                    "/": "~2F"
                }[m];
            }) : val;
        }
        function valFromString(val) {
            return null != val ? val.toString().replace(/(~~|~2F)/g, function(m) {
                return {
                    "~~": "~",
                    "~2F": "/"
                }[m];
            }) : val;
        }
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        function flushTypeQueue() {
            for (;typeQueue.length; ) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        function ParamSet(params) {
            extend(this, params || {});
        }
        $$UMFP = this;
        var injector, isCaseInsensitive = !1, isStrictMode = !0, defaultSquashPolicy = !1, $types = {}, enqueue = !0, typeQueue = [], defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                    return null == val || !isDefined(val) || "string" == typeof val;
                },
                pattern: /[^\/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return 0 !== parseInt(val, 10);
                },
                is: function(val) {
                    return val === !0 || val === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    return this.is(val) ? [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-") : undefined;
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        }, this.caseInsensitive = function(value) {
            return isDefined(value) && (isCaseInsensitive = value), isCaseInsensitive;
        }, this.strictMode = function(value) {
            return isDefined(value) && (isStrictMode = value), isStrictMode;
        }, this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== !0 && value !== !1 && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return defaultSquashPolicy = value, value;
        }, this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        }, this.isMatcher = function(o) {
            if (!isObject(o)) return !1;
            var result = !0;
            return forEach(UrlMatcher.prototype, function(val, name) {
                isFunction(val) && (result = result && isDefined(o[name]) && isFunction(o[name]));
            }), result;
        }, this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            return $types[name] = new Type(extend({
                name: name
            }, definition)), definitionFn && (typeQueue.push({
                name: name,
                def: definitionFn
            }), enqueue || flushTypeQueue()), this;
        }, forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        }), $types = inherit($types, {}), this.$get = [ "$injector", function($injector) {
            return injector = $injector, enqueue = !1, flushTypeQueue(), forEach(defaultTypes, function(type, name) {
                $types[name] || ($types[name] = new Type(type));
            }), this;
        } ], this.Param = function(id, type, config, location) {
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [], isShorthand = -1 === indexOf(keys, "value") && -1 === indexOf(keys, "type") && -1 === indexOf(keys, "squash") && -1 === indexOf(keys, "array");
                return isShorthand && (config = {
                    value: config
                }), config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                }, config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                return urlType ? urlType : config.type ? angular.isString(config.type) ? $types[config.type] : config.type instanceof Type ? config.type : new Type(config.type) : "config" === location ? $types.any : $types.string;
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: "search" === location ? "auto" : !1
                }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === !1) return !1;
                if (!isDefined(squash) || null == squash) return defaultSquashPolicy;
                if (squash === !0 || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                return replace = isArray(config.replace) ? config.replace : [], isString(squash) && replace.push({
                    from: squash,
                    to: undefined
                }), configuredKeys = map(replace, function(item) {
                    return item.from;
                }), filter(defaultPolicy, function(item) {
                    return -1 === indexOf(configuredKeys, item.from);
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (null !== defaultValue && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                return value = $replace(value), isDefined(value) ? self.type.$normalize(value) : $$getDefaultValue();
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            var self = this;
            config = unwrapShorthand(config), type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, "search" === location) : type, "string" !== type.name || arrayMode || "path" !== location || config.value !== undefined || (config.value = "");
            var isOptional = config.value !== undefined, squash = getSquashPolicy(config, isOptional), replace = getReplace(config, arrayMode, isOptional, squash);
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        }, ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype); parent; ) chain.push(parent), 
                parent = parent.$$parent;
                return chain.reverse(), forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        -1 === indexOf(keys, key) && -1 === indexOf(ignore, key) && keys.push(key);
                    });
                }), keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                return forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                }), values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = !0, self = this;
                return forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    self[key].type.equals(left, right) || (equal = !1);
                }), equal;
            },
            $$validates: function(paramValues) {
                var i, param, rawVal, normalized, encoded, keys = this.$$keys();
                for (i = 0; i < keys.length && (param = this[keys[i]], rawVal = paramValues[keys[i]], 
                rawVal !== undefined && null !== rawVal || !param.isOptional); i++) {
                    if (normalized = param.type.$normalize(rawVal), !param.type.is(normalized)) return !1;
                    if (encoded = param.type.encode(normalized), angular.isString(encoded) && !param.type.pattern.exec(encoded)) return !1;
                }
                return !0;
            },
            $$parent: undefined
        }, this.ParamSet = ParamSet;
    }
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return null != prefix ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match["$" === what ? 0 : Number(what)];
            });
        }
        function handleIfMatch($injector, handler, match) {
            if (!match) return !1;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : !0;
        }
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
            function appendBasePath(url, isHtml5, absolute) {
                return "/" === baseHref ? url : isHtml5 ? baseHref.slice(0, -1) + url : absolute ? baseHref.slice(1) + url : url;
            }
            function update(evt) {
                function check(rule) {
                    var handled = rule($injector, $location);
                    return handled ? (isString(handled) && $location.replace().url(handled), !0) : !1;
                }
                if (!evt || !evt.defaultPrevented) {
                    lastPushedUrl && $location.url() === lastPushedUrl;
                    lastPushedUrl = undefined;
                    var i, n = rules.length;
                    for (i = 0; n > i; i++) if (check(rules[i])) return;
                    otherwise && check(otherwise);
                }
            }
            function listen() {
                return listener = listener || $rootScope.$on("$locationChangeSuccess", update);
            }
            var lastPushedUrl, baseHref = $browser.baseHref(), location = $location.url();
            return interceptDeferred || listen(), {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    return read ? void (location = $location.url()) : void ($location.url() !== location && ($location.url(location), 
                    $location.replace()));
                },
                push: function(urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});
                    null !== url && params && params["#"] && (url += "#" + params["#"]), $location.url(url), 
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined, 
                    options && options.replace && $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    angular.isObject(isHtml5) && (isHtml5 = isHtml5.enabled), isHtml5 = isHtml5 && $sniffer.history;
                    var url = urlMatcher.format(params);
                    if (options = options || {}, isHtml5 || null === url || (url = "#" + $locationProvider.hashPrefix() + url), 
                    null !== url && params && params["#"] && (url += "#" + params["#"]), url = appendBasePath(url, isHtml5, options.absolute), 
                    !options.absolute || !url) return url;
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    return port = 80 === port || 443 === port ? "" : ":" + port, [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
        var listener, rules = [], otherwise = null, interceptDeferred = !1;
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return rules.push(rule), this;
        }, this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return otherwise = rule, this;
        }, this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = [ "$match", function($match) {
                        return redirect.format($match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return handlerIsString && (redirect = handler, handler = [ "$match", function($match) {
                        return interpolate(redirect, $match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            }, check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) if (check[n]) return this.rule(strategies[n](what, handler));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(defer) {
            defer === undefined && (defer = !0), interceptDeferred = defer;
        }, this.$get = $get, $get.$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
    }
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        function isRelative(stateName) {
            return 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^");
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; pathLength > i; i++) if ("" !== rel[i] || 0 !== i) {
                    if ("^" !== rel[i]) break;
                    if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                    current = current.parent;
                } else current = base;
                rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state;
        }
        function queueState(parentName, state) {
            queue[parentName] || (queue[parentName] = []), queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            for (var queued = queue[parentName] || []; queued.length; ) registerState(queued.shift());
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");
            var parentName = -1 !== name.indexOf(".") ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) return queueState(parentName, state.self);
            for (var key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
            return states[name] = state, !state[abstractKey] && state.url && $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                    inherit: !0,
                    location: !1
                });
            } ]), flushQueuedChildren(name), state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            for (var globSegments = glob.split("."), segments = $state.$current.name.split("."), i = 0, l = globSegments.length; l > i; i++) "*" === globSegments[i] && (segments[i] = "*");
            return "**" === globSegments[0] && (segments = segments.slice(indexOf(segments, globSegments[1])), 
            segments.unshift("**")), "**" === globSegments[globSegments.length - 1] && (segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), 
            segments.push("**")), globSegments.length != segments.length ? !1 : segments.join("") === globSegments.join("");
        }
        function decorator(name, func) {
            return isString(name) && !isDefined(func) ? stateBuilder[name] : isFunction(func) && isString(name) ? (stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]), 
            stateBuilder[name] = func, this) : this;
        }
        function state(name, definition) {
            return isObject(name) ? definition = name : definition.name = name, registerState(definition), 
            this;
        }
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) return $urlRouter.update(), TransitionAborted;
                if (!evt.retry) return null;
                if (options.$retry) return $urlRouter.update(), TransitionFailed;
                var retryTransition = $state.transition = $q.when(evt.retry);
                return retryTransition.then(function() {
                    return retryTransition !== $state.transition ? ($rootScope.$broadcast("$stateChangeCancel", redirect.to, redirect.toParams, state, params), 
                    TransitionSuperseded) : (redirect.options.$retry = !0, $state.transitionTo(redirect.to, redirect.toParams, redirect.options));
                }, function() {
                    return TransitionAborted;
                }), $urlRouter.update(), retryTransition;
            }
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                function resolveViews() {
                    var viewsPromises = [];
                    return forEach(state.views, function(view, name) {
                        var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                        injectables.$template = [ function() {
                            return $view.load(name, {
                                view: view,
                                locals: dst.globals,
                                params: $stateParams,
                                notify: options.notify
                            }) || "";
                        } ], viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                var injectLocals = angular.extend({}, injectables, dst.globals);
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                            } else result.$$controller = view.controller;
                            result.$$state = state, result.$$controllerAs = view.controllerAs, result.$$resolveAs = view.resolveAs, 
                            dst[name] = result;
                        }));
                    }), $q.all(viewsPromises).then(function() {
                        return dst.globals;
                    });
                }
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params), locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                return inherited && promises.push(inherited), $q.all(promises).then(resolveViews).then(function(values) {
                    return dst;
                });
            }
            var TransitionSupersededError = new Error("transition superseded"), TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError)), TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error("transition prevented"))), TransitionAborted = silenceUncaughtInPromise($q.reject(new Error("transition aborted"))), TransitionFailed = silenceUncaughtInPromise($q.reject(new Error("transition failed")));
            return root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            }, $state.reload = function(state) {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: state || !0,
                    inherit: !1,
                    notify: !0
                });
            }, $state.go = function(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: !0,
                    relative: $state.$current
                }, options));
            }, $state.transitionTo = function(to, toParams, options) {
                toParams = toParams || {}, options = extend({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, options || {});
                var evt, from = $state.$current, fromParams = $state.params, fromPath = from.path, toState = findState(to, options.relative), hash = toParams["#"];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    }, redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) return redirectResult;
                    if (to = redirect.to, toParams = redirect.toParams, options = redirect.options, 
                    toState = findState(to, options.relative), !isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), 
                !toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams), to = toState;
                var toPath = to.path, keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (options.reload) {
                    if (isString(options.reload) || isObject(options.reload)) {
                        if (isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                        var reloadState = options.reload === !0 ? fromPath[0] : findState(options.reload);
                        if (options.reload && !reloadState) throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                        for (;state && state === fromPath[keep] && state !== reloadState; ) locals = toLocals[keep] = state.locals, 
                        keep++, state = toPath[keep];
                    }
                } else for (;state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams); ) locals = toLocals[keep] = state.locals, 
                keep++, state = toPath[keep];
                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) return hash && (toParams["#"] = hash), 
                $state.params = toParams, copy($state.params, $stateParams), copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams), 
                options.location && to.navigable && to.navigable.url && ($urlRouter.push(to.navigable.url, toParams, {
                    $$avoidResync: !0,
                    replace: "replace" === options.location
                }), $urlRouter.update(!0)), $state.transition = null, $q.when($state.current);
                if (toParams = filterByKeys(to.params.$$keys(), toParams || {}), hash && (toParams["#"] = hash), 
                options.notify && $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams, options).defaultPrevented) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                null == $state.transition && $urlRouter.update(), TransitionPrevented;
                for (var resolved = $q.when(locals), l = keep; l < toPath.length; l++, state = toPath[l]) locals = toLocals[l] = inherit(locals), 
                resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) exiting = fromPath[l], exiting.self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), 
                    exiting.locals = null;
                    for (l = keep; l < toPath.length; l++) entering = toPath[l], entering.locals = toLocals[l], 
                    entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                    return $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded) : ($state.$current = to, $state.current = to.self, $state.params = toParams, 
                    copy($state.params, $stateParams), $state.transition = null, options.location && to.navigable && $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === options.location
                    }), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), 
                    $urlRouter.update(!0), $state.current);
                }).then(null, function(error) {
                    return error === TransitionSupersededError ? TransitionSuperseded : $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                    TransitionSuperseded) : ($state.transition = null, evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error), 
                    evt.defaultPrevented || $urlRouter.update(), $q.reject(error));
                });
                return transition;
            }, $state.is = function(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                return isDefined(state) ? $state.$current !== state ? !1 : params ? equalForKeys(state.params.$$values(params), $stateParams) : !0 : undefined;
            }, $state.includes = function(stateOrName, params, options) {
                if (options = extend({
                    relative: $state.$current
                }, options || {}), isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) return !1;
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return undefined;
                if (!isDefined($state.$current.includes[state.name])) return !1;
                if (!params) return !0;
                for (var keys = objectKeys(params), i = 0; i < keys.length; i++) {
                    var key = keys[i], paramDef = state.params[key];
                    if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) return !1;
                }
                return !0;
            }, $state.href = function(stateOrName, params, options) {
                options = extend({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                options.inherit && (params = inheritParams($stateParams, params || {}, $state.$current, state));
                var nav = state && options.lossy ? state.navigable : state;
                return nav && nav.url !== undefined && null !== nav.url ? $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                    absolute: options.absolute
                }) : null;
            }, $state.get = function(stateOrName, context) {
                if (0 === arguments.length) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            }, $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                function notSearchParam(key) {
                    return "search" != fromAndToState.params[key].location;
                }
                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam), nonQueryParams = pick.apply({}, [ fromAndToState.params ].concat(nonQueryParamKeys)), nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                return nonQueryParamSet.$$equals(fromParams, toParams);
            }
            return !options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === !1 && nonSearchParamsEqual(from, fromParams, toParams)) ? !0 : void 0;
        }
        var root, $state, states = {}, queue = {}, abstractKey = "abstract", stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                return state.parent && state.parent.data && (state.data = state.self.data = inherit(state.parent.data, state.data)), 
                state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1), config) : (state.parent.navigable || root).url.concat(url, config);
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                return forEach(state.params || {}, function(config, id) {
                    params[id] || (params[id] = new $$UMFP.Param(id, null, config, "config"));
                }), params;
            },
            params: function(state) {
                var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                return forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    name.indexOf("@") < 0 && (name += "@" + state.parent.name), view.resolveAs = view.resolveAs || state.resolveAs || "$resolve", 
                    views[name] = view;
                }), views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                return includes[state.name] = !0, includes;
            },
            $delegates: {}
        };
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), root.navigable = null, this.decorator = decorator, this.state = state, this.$get = $get, 
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function $ViewProvider() {
        function $get($rootScope, $templateFactory) {
            return {
                load: function(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return options = extend(defaults, options), options.view && (result = $templateFactory.fromConfig(options.view, options.params, options.locals)), 
                    result;
                }
            };
        }
        this.$get = $get, $get.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function $ViewScrollProvider() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element), cb();
                    },
                    leave: function(element, cb) {
                        element.remove(), cb();
                    }
                };
            };
            if ($animate) return {
                enter: function(element, target, cb) {
                    angular.version.minor > 2 ? $animate.enter(element, null, target).then(cb) : $animate.enter(element, null, target, cb);
                },
                leave: function(element, cb) {
                    angular.version.minor > 2 ? $animate.leave(element).then(cb) : $animate.leave(element, cb);
                }
            };
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target), cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element), cb();
                    }
                };
            }
            return statics();
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate"), directive = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    function cleanupLastView() {
                        if (previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentEl) {
                            var $uiViewData = currentEl.data("$uiViewAnim");
                            renderer.leave(currentEl, function() {
                                $uiViewData.$$animLeave.resolve(), previousEl = null;
                            }), previousEl = currentEl, currentEl = null;
                        }
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (firstTime || previousLocals !== latestLocals) {
                            newScope = scope.$new(), latestLocals = $state.$current.locals[name], newScope.$emit("$viewContentLoading", name);
                            var clone = $transclude(newScope, function(clone) {
                                var animEnter = $q.defer(), animLeave = $q.defer(), viewAnimData = {
                                    $animEnter: animEnter.promise,
                                    $animLeave: animLeave.promise,
                                    $$animLeave: animLeave
                                };
                                clone.data("$uiViewAnim", viewAnimData), renderer.enter(clone, $element, function() {
                                    animEnter.resolve(), currentScope && currentScope.$emit("$viewContentAnimationEnded"), 
                                    (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                                }), cleanupLastView();
                            });
                            currentEl = clone, currentScope = newScope, currentScope.$emit("$viewContentLoaded", name), 
                            currentScope.$eval(onloadExp);
                        }
                    }
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    $element.inheritedData("$uiView");
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
        return directive;
    }
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (locals) {
                        $element.data("$uiView", {
                            name: name,
                            state: locals.$$state
                        }), $element.html(locals.$template ? locals.$template : initial);
                        var resolveData = angular.extend({}, locals);
                        scope[locals.$$resolveAs] = resolveData;
                        var link = $compile($element.contents());
                        if (locals.$$controller) {
                            locals.$scope = scope, locals.$element = $element;
                            var controller = $controller(locals.$$controller, locals);
                            locals.$$controllerAs && (scope[locals.$$controllerAs] = controller, scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData), 
                            isFunction(controller.$onInit) && controller.$onInit(), $element.data("$ngControllerController", controller), 
                            $element.children().data("$ngControllerController", controller);
                        }
                        link(scope);
                    }
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope), uiViewCreatedBy = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (uiViewCreatedBy ? uiViewCreatedBy.state.name : "");
    }
    function parseStateRef(ref, current) {
        var parsed, preparsed = ref.match(/^\s*({[^}]*})\s*$/);
        if (preparsed && (ref = current + "(" + preparsed[1] + ")"), parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        return stateData && stateData.state && stateData.state.name ? stateData.state : void 0;
    }
    function getTypeInfo(el) {
        var isSvg = "[object SVGAnimatedString]" === Object.prototype.toString.call(el.prop("href")), isForm = "FORM" === el[0].nodeName;
        return {
            attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
            isAnchor: "A" === el.prop("tagName").toUpperCase(),
            clickable: !isForm
        };
    }
    function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
            var button = e.which || e.button, target = current();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                var transition = $timeout(function() {
                    $state.go(target.state, target.params, target.options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function() {
                    ignorePreventDefaultCount-- <= 0 && $timeout.cancel(transition);
                };
            }
        };
    }
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: !0
        };
    }
    function $StateRefDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var hookFn, ref = parseStateRef(attrs.uiSref, $state.current.name), def = {
                    state: ref.state,
                    href: null,
                    params: null
                }, type = getTypeInfo(element), active = uiSrefActive[1] || uiSrefActive[0], unlinkInfoFn = null;
                def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                var update = function(val) {
                    val && (def.params = angular.copy(val)), def.href = $state.href(ref.state, def.params, def.options), 
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(ref.state, def.params)), 
                    null !== def.href && attrs.$set(type.attr, def.href);
                };
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(val) {
                    val !== def.params && update(val);
                }, !0), def.params = angular.copy(scope.$eval(ref.paramExpr))), update(), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                    return def;
                }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                    element[element.off ? "off" : "unbind"]("click", hookFn);
                }));
            }
        };
    }
    function $StateRefDynamicDirective($state, $timeout) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                function runStateRefLink(group) {
                    def.state = group[0], def.params = group[1], def.options = group[2], def.href = $state.href(def.state, def.params, def.options), 
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.state, def.params)), 
                    def.href && attrs.$set(type.attr, def.href);
                }
                var hookFn, type = getTypeInfo(element), active = uiSrefActive[1] || uiSrefActive[0], group = [ attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null ], watch = "[" + group.map(function(val) {
                    return val || "null";
                }).join(", ") + "]", def = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                }, unlinkInfoFn = null;
                scope.$watch(watch, runStateRefLink, !0), runStateRefLink(scope.$eval(watch)), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                    return def;
                }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                    element[element.off ? "off" : "unbind"]("click", hookFn);
                }));
            }
        };
    }
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function($scope, $element, $attrs, $timeout) {
                function addState(stateName, stateParams, activeClass) {
                    var state = $state.get(stateName, stateContext($element)), stateHash = createStateHash(stateName, stateParams), stateInfo = {
                        state: state || {
                            name: stateName
                        },
                        params: stateParams,
                        hash: stateHash
                    };
                    return states.push(stateInfo), activeClasses[stateHash] = activeClass, function() {
                        var idx = states.indexOf(stateInfo);
                        -1 !== idx && states.splice(idx, 1);
                    };
                }
                function createStateHash(state, params) {
                    if (!isString(state)) throw new Error("state should be a string");
                    return isObject(params) ? state + toJson(params) : (params = $scope.$eval(params), 
                    isObject(params) ? state + toJson(params) : state);
                }
                function update() {
                    for (var i = 0; i < states.length; i++) anyMatch(states[i].state, states[i].params) ? addClass($element, activeClasses[states[i].hash]) : removeClass($element, activeClasses[states[i].hash]), 
                    exactMatch(states[i].state, states[i].params) ? addClass($element, activeEqClass) : removeClass($element, activeEqClass);
                }
                function addClass(el, className) {
                    $timeout(function() {
                        el.addClass(className);
                    });
                }
                function removeClass(el, className) {
                    el.removeClass(className);
                }
                function anyMatch(state, params) {
                    return $state.includes(state.name, params);
                }
                function exactMatch(state, params) {
                    return $state.is(state.name, params);
                }
                var activeEqClass, uiSrefActive, states = [], activeClasses = {};
                activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", !1)($scope);
                try {
                    uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                } catch (e) {}
                uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", !1)($scope), 
                isObject(uiSrefActive) && forEach(uiSrefActive, function(stateOrName, activeClass) {
                    if (isString(stateOrName)) {
                        var ref = parseStateRef(stateOrName, $state.current.name);
                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                    }
                }), this.$$addStateInfo = function(newState, newParams) {
                    if (!(isObject(uiSrefActive) && states.length > 0)) {
                        var deregister = addState(newState, newParams, uiSrefActive);
                        return update(), deregister;
                    }
                }, $scope.$on("$stateChangeSuccess", update), update();
            } ]
        };
    }
    function $IsStateFilter($state) {
        var isFilter = function(state, params) {
            return $state.is(state, params);
        };
        return isFilter.$stateful = !0, isFilter;
    }
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
            return $state.includes(state, params, options);
        };
        return includesFilter.$stateful = !0, includesFilter;
    }
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, toJson = angular.toJson;
    angular.module("ui.router.util", [ "ng" ]), angular.module("ui.router.router", [ "ui.router.util" ]), 
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), angular.module("ui.router", [ "ui.router.state" ]), 
    angular.module("ui.router.compat", [ "ui.router" ]), $Resolve.$inject = [ "$q", "$injector" ], 
    angular.module("ui.router.util").service("$resolve", $Resolve), $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ], 
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    }, UrlMatcher.prototype.toString = function() {
        return this.source;
    }, UrlMatcher.prototype.exec = function(path, searchParams) {
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/), allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var i, j, paramName, paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {};
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        var param, paramVal;
        for (i = 0; nPath > i; i++) {
            for (paramName = paramNames[i], param = this.params[paramName], paramVal = m[i + 1], 
            j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            paramVal && param.array === !0 && (paramVal = decodePathArray(paramVal)), isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), 
            values[paramName] = param.value(paramVal);
        }
        for (;nTotal > i; i++) {
            for (paramName = paramNames[i], values[paramName] = this.params[paramName].value(searchParams[paramName]), 
            param = this.params[paramName], paramVal = searchParams[paramName], j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), values[paramName] = param.value(paramVal);
        }
        return values;
    }, UrlMatcher.prototype.parameters = function(param) {
        return isDefined(param) ? this.params[param] || null : this.$$paramNames;
    }, UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    }, UrlMatcher.prototype.format = function(values) {
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = !1, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        for (i = 0; nTotal > i; i++) {
            var isPathParam = nPath > i, name = params[i], param = paramset[name], value = param.value(values[name]), isDefaultValue = param.isOptional && param.type.equals(param.value(), value), squash = isDefaultValue ? param.squash : !1, encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1], isFinalPathParam = i + 1 === nPath;
                if (squash === !1) null != encoded && (result += isArray(encoded) ? map(encoded, encodeDashes).join("-") : encodeURIComponent(encoded)), 
                result += nextSegment; else if (squash === !0) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else isString(squash) && (result += squash + nextSegment);
                isFinalPathParam && param.squash === !0 && "/" === result.slice(-1) && (result = result.slice(0, -1));
            } else {
                if (null == encoded || isDefaultValue && squash !== !1) continue;
                if (isArray(encoded) || (encoded = [ encoded ]), 0 === encoded.length) continue;
                encoded = map(encoded, encodeURIComponent).join("&" + name + "="), result += (search ? "&" : "?") + (name + "=" + encoded), 
                search = !0;
            }
        }
        return result;
    }, Type.prototype.is = function(val, key) {
        return !0;
    }, Type.prototype.encode = function(val, key) {
        return val;
    }, Type.prototype.decode = function(val, key) {
        return val;
    }, Type.prototype.equals = function(a, b) {
        return a == b;
    }, Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    }, Type.prototype.pattern = /.*/, Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    }, Type.prototype.$asArray = function(mode, isSearch) {
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return "auto" === mode ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function(val) {
                    if (isArray(val) && 0 === val.length) return val;
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    return allTruthyMode === !0 ? 0 === filter(result, falsey).length : arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return !1;
                    for (var i = 0; i < left.length; i++) if (!callback(left[i], right[i])) return !1;
                    return !0;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode")), this.decode = arrayHandler(bindTo(type, "decode")), 
            this.is = arrayHandler(bindTo(type, "is"), !0), this.equals = arrayEqualsHandler(bindTo(type, "equals")), 
            this.pattern = type.pattern, this.$normalize = arrayHandler(bindTo(type, "$normalize")), 
            this.name = type.name, this.$arrayMode = mode;
        }
        if (!mode) return this;
        if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), 
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]), 
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).constant("$state.runtime", {
        autoinject: !0
    }).provider("$state", $StateProvider).run([ "$injector", function($injector) {
        $injector.get("$state.runtime").autoinject && $injector.get("$state");
    } ]), $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), 
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider), 
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate", "$q" ], 
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    $StateRefDirective.$inject = [ "$state", "$timeout" ], $StateRefDynamicDirective.$inject = [ "$state", "$timeout" ], 
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective).directive("uiState", $StateRefDynamicDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
}(window, window.angular), function(root, factory) {
    "use strict";
    "function" == typeof define && define.amd ? define([ "angular" ], factory) : root.hasOwnProperty("angular") ? factory(root.angular) : "object" == typeof exports && (module.exports = factory(require("angular")));
}(this, function(angular) {
    "use strict";
    function isStorageSupported($window, storageType) {
        var supported;
        try {
            supported = $window[storageType];
        } catch (err) {
            supported = !1;
        }
        if (supported) {
            var key = "__" + Math.round(1e7 * Math.random());
            try {
                $window[storageType].setItem(key, key), $window[storageType].removeItem(key, key);
            } catch (err) {
                supported = !1;
            }
        }
        return supported;
    }
    function _storageProvider(storageType) {
        var providerWebStorage = isStorageSupported(window, storageType);
        return function() {
            var storageKeyPrefix = "ngStorage-";
            this.setKeyPrefix = function(prefix) {
                if ("string" != typeof prefix) throw new TypeError("[ngStorage] - " + storageType + "Provider.setKeyPrefix() expects a String.");
                storageKeyPrefix = prefix;
            };
            var serializer = angular.toJson, deserializer = angular.fromJson;
            this.setSerializer = function(s) {
                if ("function" != typeof s) throw new TypeError("[ngStorage] - " + storageType + "Provider.setSerializer expects a function.");
                serializer = s;
            }, this.setDeserializer = function(d) {
                if ("function" != typeof d) throw new TypeError("[ngStorage] - " + storageType + "Provider.setDeserializer expects a function.");
                deserializer = d;
            }, this.supported = function() {
                return !!providerWebStorage;
            }, this.get = function(key) {
                return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));
            }, this.set = function(key, value) {
                return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));
            }, this.remove = function(key) {
                providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);
            }, this.$get = [ "$rootScope", "$window", "$log", "$timeout", "$document", function($rootScope, $window, $log, $timeout, $document) {
                var _last$storage, _debounce, prefixLength = storageKeyPrefix.length, isSupported = isStorageSupported($window, storageType), webStorage = isSupported || ($log.warn("This browser does not support Web Storage!"), 
                {
                    setItem: angular.noop,
                    getItem: angular.noop,
                    removeItem: angular.noop
                }), $storage = {
                    $default: function(items) {
                        for (var k in items) angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]));
                        return $storage.$sync(), $storage;
                    },
                    $reset: function(items) {
                        for (var k in $storage) "$" === k[0] || delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k);
                        return $storage.$default(items);
                    },
                    $sync: function() {
                        for (var k, i = 0, l = webStorage.length; l > i; i++) (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));
                    },
                    $apply: function() {
                        var temp$storage;
                        if (_debounce = null, !angular.equals($storage, _last$storage)) {
                            temp$storage = angular.copy(_last$storage), angular.forEach($storage, function(v, k) {
                                angular.isDefined(v) && "$" !== k[0] && (webStorage.setItem(storageKeyPrefix + k, serializer(v)), 
                                delete temp$storage[k]);
                            });
                            for (var k in temp$storage) webStorage.removeItem(storageKeyPrefix + k);
                            _last$storage = angular.copy($storage);
                        }
                    },
                    $supported: function() {
                        return !!isSupported;
                    }
                };
                return $storage.$sync(), _last$storage = angular.copy($storage), $rootScope.$watch(function() {
                    _debounce || (_debounce = $timeout($storage.$apply, 100, !1));
                }), $window.addEventListener && $window.addEventListener("storage", function(event) {
                    if (event.key) {
                        var doc = $document[0];
                        doc.hasFocus && doc.hasFocus() || storageKeyPrefix !== event.key.slice(0, prefixLength) || (event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)], 
                        _last$storage = angular.copy($storage), $rootScope.$apply());
                    }
                }), $window.addEventListener && $window.addEventListener("beforeunload", function() {
                    $storage.$apply();
                }), $storage;
            } ];
        };
    }
    return angular = angular && angular.module ? angular : window.angular, angular.module("ngStorage", []).provider("$localStorage", _storageProvider("localStorage")).provider("$sessionStorage", _storageProvider("sessionStorage"));
}), angular.module("fluro.config", [ "ngStorage" ]).provider("Fluro", function() {
    var config = {
        apiURL: "https://apiv2.fluro.io",
        token: null,
        sessionStorage: !1
    };
    return {
        set: function(settings) {
            config = settings;
        },
        $get: function() {
            return config;
        }
    };
}).service("FluroTokenService", [ "$rootScope", "$injector", "$sessionStorage", "$localStorage", "Fluro", function($rootScope, $injector, $sessionStorage, $localStorage, Fluro) {
    var controller = {};
    controller.storageLocation = function() {
        return Fluro.sessionStorage ? $sessionStorage : $localStorage;
    }, controller.set = function(session) {
        var storage = controller.storageLocation();
        storage.session = session, controller.recall();
    }, controller.recall = function() {
        var storage = controller.storageLocation();
        storage.session && ($rootScope.user = storage.session, Fluro.token = storage.session.token, 
        Fluro.tokenExpires = storage.session.expires, Fluro.refreshToken = storage.session.refreshToken);
    }, controller.signup = function(details, options) {
        options || (options = {});
        var autoAuthenticate = !0;
        options.disableAutoAuthenticate && (autoAuthenticate = !1);
        var url = Fluro.apiURL + "/token/signup";
        options.application && (Fluro.appDevelopmentURL && Fluro.appDevelopmentURL.length ? (console.log("Sign up request rerouted to app development url", Fluro.appDevelopmentURL), 
        url = Fluro.appDevelopmentURL + "/fluro/application/signup") : url = "/fluro/application/signup"), 
        options.url && (url = options.url);
        var $http = $injector.get("$http"), storage = controller.storageLocation(), request = $http.post(url, details);
        return request.then(function(res) {
            autoAuthenticate && (storage.session = res.data, controller.recall()), options.success && options.success(res.data);
        }, function(err) {
            options.error && options.error(err.data);
        }), request;
    }, controller.login = function(details, options) {
        options || (options = {});
        var autoAuthenticate = !0;
        options.disableAutoAuthenticate && (autoAuthenticate = !1);
        var url = Fluro.apiURL + "/token/login";
        options.application && (Fluro.appDevelopmentURL && Fluro.appDevelopmentURL.length ? (console.log("Login request rerouted to app development url", Fluro.appDevelopmentURL), 
        url = Fluro.appDevelopmentURL + "/fluro/application/login") : url = "/fluro/application/login"), 
        options.managedAccount && (url = Fluro.apiURL + "/managed/" + options.managedAccount + "/login"), 
        options.url && (url = options.url);
        var $http = $injector.get("$http"), storage = controller.storageLocation(), request = $http.post(url, details);
        return request.then(function(res) {
            autoAuthenticate && (storage.session = res.data, controller.recall()), options.success && options.success(res.data);
        }, function(res) {
            options.error && options.error(res.data);
        }), request;
    }, controller.signInAsPersona = function(personaID, options) {
        options || (options = {});
        var autoAuthenticate = !0;
        options.disableAutoAuthenticate && (autoAuthenticate = !1);
        var $http = $injector.get("$http"), storage = controller.storageLocation(), request = $http.post(Fluro.apiURL + "/token/persona/" + personaID);
        return request.then(function(res) {
            autoAuthenticate && (storage.session = res.data, controller.recall()), options.success && options.success(res.data);
        }, function(res) {
            options.error && options.error(res.data);
        }), request;
    }, controller.getTokenForAccount = function(accountId, options) {
        options || (options = {});
        var autoAuthenticate = !0;
        options.disableAutoAuthenticate && (autoAuthenticate = !1);
        var $http = $injector.get("$http"), storage = controller.storageLocation(), request = $http.post(Fluro.apiURL + "/token/account/" + accountId);
        return request.success(function(res) {
            autoAuthenticate && (storage.session = res.data, controller.recall()), options.success && options.success(res.data);
        }, function(res) {
            options.error && options.error(res.data);
        }), request;
    }, controller.hasExpired = function() {
        var storage = controller.storageLocation();
        if (storage.session) {
            var expiry = new Date(storage.session.expires), now = new Date();
            return expiry.getTime() <= now.getTime();
        }
    };
    var inflightRequest;
    return controller.refresh = function(successCallback, errorCallback) {
        if (inflightRequest) return inflightRequest;
        var storage = controller.storageLocation(), $http = $injector.get("$http"), session = storage.session;
        return session && session.refreshToken ? (inflightRequest = $http.post(Fluro.apiURL + "/token/refresh", {
            refreshToken: session.refreshToken,
            managed: "managed" == session.accountType
        }), inflightRequest.then(function(res) {
            return inflightRequest = null, storage.session.refreshToken = res.data.refreshToken, 
            storage.session.token = res.data.token, storage.session.expires = res.data.expires, 
            controller.recall(), successCallback ? successCallback(res.data) : void 0;
        }, function(err) {
            return inflightRequest = null, "invalid_refresh_token" == err.data && controller.deleteSession(), 
            errorCallback ? errorCallback(err) : void 0;
        }), inflightRequest) : void 0;
    }, controller.deleteSession = function() {
        console.log("delete session");
        var storage = controller.storageLocation();
        storage.session = null, delete $rootScope.user, delete Fluro.token, delete Fluro.tokenExpires, 
        delete Fluro.refreshToken;
    }, controller.logout = function() {
        controller.deleteSession();
    }, controller.recall(), controller;
} ]).service("FluroAuthentication", [ "$q", "Fluro", "FluroTokenService", function($q, Fluro, FluroTokenService) {
    return {
        request: function(config) {
            function startsWith(string) {
                return config.url.slice(0, string.length) === string;
            }
            function refreshSuccess(res) {
                var newToken = res.data;
                config.headers.Authorization = "Bearer " + newToken.token, deferred.resolve(config);
            }
            function refreshFailed(res) {
                FluroTokenService.backup ? (FluroTokenService.backup.token && (Fluro.token = FluroTokenService.backup.token, 
                config.headers.Authorization = "Bearer " + Fluro.token), FluroTokenService.backup.user && ($rootScope.user = FluroTokenService.backup.user), 
                deferred.resolve(config)) : deferred.reject(config);
            }
            if (!startsWith(Fluro.apiURL)) return config;
            var date = new Date();
            if (Fluro.timezoneOffset && String(Fluro.timezoneOffset).length) {
                var websiteOffset = Fluro.timezoneOffset, viewerOffset = -1 * date.getTimezoneOffset(), hoursDifference = websiteOffset - viewerOffset, offsetDifference = 60 * hoursDifference * 1e3;
                date.setTime(date.getTime() + offsetDifference);
            }
            if (config.headers["fluro-request-date"] = date.toUTCString(), config.bypassInterceptor) return config;
            if (-1 != config.url.indexOf("/token/refresh")) return config;
            if (!Fluro.token) return config;
            var deferred = $q.defer();
            if (Fluro.tokenExpires) {
                var expired = FluroTokenService.hasExpired();
                if (expired) {
                    var refreshRequest = FluroTokenService.refresh();
                    refreshRequest.then(refreshSuccess, refreshFailed);
                } else config.headers.Authorization = "Bearer " + Fluro.token, deferred.resolve(config);
            } else config.headers.Authorization = "Bearer " + Fluro.token, deferred.resolve(config);
            return deferred.promise;
        }
    };
} ]).service("FluroTokenStore", [ "$sessionStorage", "$localStorage", "$q", "$injector", "Fluro", "FluroTokenService", function($sessionStorage, $localStorage, $q, $injector, Fluro, FluroTokenService) {
    var storeInstance = function(key) {
        var controller = {};
        controller.defaultStorage = "local", controller.get = function() {
            var storage = controller.storageLocation();
            return storage[key];
        }, controller.set = function(session) {
            controller.storageLocation();
            storagestorage[key] = session;
        }, controller.storageLocation = function() {
            if (controller.storage) return controller.storage;
            switch (controller.defaultStorage) {
              case "session":
                return $sessionStorage;

              default:
                return $localStorage;
            }
        }, controller.login = function(credentials, options) {
            function loginComplete(res) {
                storage[key] = res.data;
            }
            function loginFailed(res) {}
            options || (options = {});
            var storage = controller.storageLocation();
            options.disableAutoAuthenticate = !0;
            var request = FluroTokenService.login(credentials, options);
            return request.then(loginComplete, loginFailed), request;
        }, controller.signup = function(credentials, options) {
            function signupComplete(res) {
                storage[key] = res.data;
            }
            function signupFailed(res) {}
            options || (options = {});
            var storage = controller.storageLocation();
            options.disableAutoAuthenticate = !0;
            var request = FluroTokenService.signup(credentials, options);
            return request.then(signupComplete, signupFailed), request;
        }, controller.hasExpired = function() {
            var storage = controller.storageLocation();
            if (storage[key]) {
                var expiry = new Date(storage[key].expires), now = new Date();
                return expiry.getTime() <= now.getTime();
            }
        }, controller.config = function() {
            function refreshSuccess(res) {
                res.data;
                config.headers.Authorization = "Bearer " + storage[key].token, deferred.resolve(config);
            }
            function refreshFailed(res) {
                deferred.reject(config);
            }
            var deferred = $q.defer(), storage = controller.storageLocation();
            if (!storage[key] || !storage[key].token) return deferred.reject(), deferred.promise;
            var config = {};
            if (config.bypassInterceptor = !0, config.headers = {
                Authorization: "Bearer " + storage[key].token
            }, storage[key].expires) {
                var expired = controller.hasExpired();
                if (expired) {
                    var refreshRequest = controller.refresh();
                    refreshRequest.then(refreshSuccess, refreshFailed);
                } else config.headers.Authorization = "Bearer " + storage[key].token, deferred.resolve(config);
            } else config.headers.Authorization = "Bearer " + storage[key].token, deferred.resolve(config);
            return deferred.promise;
        }, controller.deleteSession = function() {
            var storage = controller.storageLocation();
            delete storage[key];
        };
        var inflightRequest;
        return controller.refresh = function() {
            if (inflightRequest) return inflightRequest;
            var storage = controller.storageLocation(), $http = $injector.get("$http"), storedUser = storage[key];
            return storedUser && storedUser.refreshToken ? (inflightRequest = $http.post(Fluro.apiURL + "/token/refresh", {
                refreshToken: storedUser.refreshToken,
                managed: "managed" == storedUser.accountType
            }), inflightRequest.success(function(res) {
                inflightRequest = null, storage[key].refreshToken = res.data.refreshToken, storage[key].token = res.data.token, 
                storage[key].expires = res.data.expires;
            }, function(err) {
                inflightRequest = null, "invalid_refresh_token" == err.data && controller.deleteSession();
            }), inflightRequest) : void 0;
        }, controller;
    };
    return storeInstance;
} ]), angular.module("fluro.util", [ "fluro.config", "ngStorage" ]), function() {
    Date.shortMonths = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], 
    Date.longMonths = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], 
    Date.shortDays = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], Date.longDays = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
    var replaceChars = {
        d: function() {
            return (this.getDate() < 10 ? "0" : "") + this.getDate();
        },
        D: function() {
            return Date.shortDays[this.getDay()];
        },
        j: function() {
            return this.getDate();
        },
        l: function() {
            return Date.longDays[this.getDay()];
        },
        N: function() {
            return 0 == this.getDay() ? 7 : this.getDay();
        },
        S: function() {
            return this.getDate() % 10 == 1 && 11 != this.getDate() ? "st" : this.getDate() % 10 == 2 && 12 != this.getDate() ? "nd" : this.getDate() % 10 == 3 && 13 != this.getDate() ? "rd" : "th";
        },
        w: function() {
            return this.getDay();
        },
        z: function() {
            var d = new Date(this.getFullYear(), 0, 1);
            return Math.ceil((this - d) / 864e5);
        },
        W: function() {
            var target = new Date(this.valueOf()), dayNr = (this.getDay() + 6) % 7;
            target.setDate(target.getDate() - dayNr + 3);
            var firstThursday = target.valueOf();
            return target.setMonth(0, 1), 4 !== target.getDay() && target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7), 
            1 + Math.ceil((firstThursday - target) / 6048e5);
        },
        F: function() {
            return Date.longMonths[this.getMonth()];
        },
        m: function() {
            return (this.getMonth() < 9 ? "0" : "") + (this.getMonth() + 1);
        },
        M: function() {
            return Date.shortMonths[this.getMonth()];
        },
        n: function() {
            return this.getMonth() + 1;
        },
        t: function() {
            var d = new Date();
            return new Date(d.getFullYear(), d.getMonth(), 0).getDate();
        },
        L: function() {
            var year = this.getFullYear();
            return year % 400 == 0 || year % 100 != 0 && year % 4 == 0;
        },
        o: function() {
            var d = new Date(this.valueOf());
            return d.setDate(d.getDate() - (this.getDay() + 6) % 7 + 3), d.getFullYear();
        },
        Y: function() {
            return this.getFullYear();
        },
        y: function() {
            return ("" + this.getFullYear()).substr(2);
        },
        a: function() {
            return this.getHours() < 12 ? "am" : "pm";
        },
        A: function() {
            return this.getHours() < 12 ? "AM" : "PM";
        },
        B: function() {
            return Math.floor(1e3 * ((this.getUTCHours() + 1) % 24 + this.getUTCMinutes() / 60 + this.getUTCSeconds() / 3600) / 24);
        },
        g: function() {
            return this.getHours() % 12 || 12;
        },
        G: function() {
            return this.getHours();
        },
        h: function() {
            return ((this.getHours() % 12 || 12) < 10 ? "0" : "") + (this.getHours() % 12 || 12);
        },
        H: function() {
            return (this.getHours() < 10 ? "0" : "") + this.getHours();
        },
        i: function() {
            return (this.getMinutes() < 10 ? "0" : "") + this.getMinutes();
        },
        s: function() {
            return (this.getSeconds() < 10 ? "0" : "") + this.getSeconds();
        },
        u: function() {
            var m = this.getMilliseconds();
            return (10 > m ? "00" : 100 > m ? "0" : "") + m;
        },
        e: function() {
            return "Not Yet Supported";
        },
        I: function() {
            for (var DST = null, i = 0; 12 > i; ++i) {
                var d = new Date(this.getFullYear(), i, 1), offset = d.getTimezoneOffset();
                if (null === DST) DST = offset; else {
                    if (DST > offset) {
                        DST = offset;
                        break;
                    }
                    if (offset > DST) break;
                }
            }
            return this.getTimezoneOffset() == DST | 0;
        },
        O: function() {
            return (-this.getTimezoneOffset() < 0 ? "-" : "+") + (Math.abs(this.getTimezoneOffset() / 60) < 10 ? "0" : "") + Math.abs(this.getTimezoneOffset() / 60) + "00";
        },
        P: function() {
            return (-this.getTimezoneOffset() < 0 ? "-" : "+") + (Math.abs(this.getTimezoneOffset() / 60) < 10 ? "0" : "") + Math.abs(this.getTimezoneOffset() / 60) + ":00";
        },
        T: function() {
            return this.toTimeString().replace(/^.+ \(?([^\)]+)\)?$/, "$1");
        },
        Z: function() {
            return 60 * -this.getTimezoneOffset();
        },
        c: function() {
            return this.format("Y-m-d\\TH:i:sP");
        },
        r: function() {
            return this.toString();
        },
        U: function() {
            return this.getTime() / 1e3;
        }
    };
    Date.prototype.format = function(format) {
        var date = this;
        return format.replace(/(\\?)(.)/g, function(_, esc, chr) {
            return "" === esc && replaceChars[chr] ? replaceChars[chr].call(date) : chr;
        });
    };
}.call(this), angular.module("fluro.util").filter("capitalizename", function() {
    return function(text) {
        return text ? text.replace(/\w\S*/g, function(txt) {
            var name = txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            return name = name.replace(/Mc[a-z]/, function(k) {
                return "Mc" + k[2].toUpperCase();
            });
        }) : text;
    };
}), angular.module("fluro.util").filter("divide", function() {
    var func = function(array, chunk) {
        array || (array = []);
        var div = Math.floor(array.length / chunk);
        div || (div = 1);
        var chunked = _.chunk(array, div);
        return chunked;
    };
    return _.memoize(func);
}), angular.module("fluro.util").filter("chunk", function() {
    var func = function(array, chunk) {
        var chunked = _.chunk(array, chunk);
        return chunked;
    };
    return _.memoize(func);
}), angular.module("fluro.util").filter("formatDate", [ "DateTools", function(DateTools) {
    return function(dateString, format) {
        var date = DateTools.localDate(dateString);
        return date.format(format);
    };
} ]), angular.module("fluro.util").filter("plaintext", [ "FluroSanitize", function(FluroSanitize) {
    return function(text) {
        if (text) {
            var lineBreakReg = /<br\s*[\/]?>/gi;
            return text = text.replace(lineBreakReg, "\n"), FluroSanitize.stripTags(text);
        }
        return text;
    };
} ]), angular.module("fluro.util").filter("trusted", [ "$sce", function($sce) {
    return function(text) {
        return $sce.trustAsHtml(text);
    };
} ]).filter("trustedResource", [ "$sce", function($sce) {
    return function(url) {
        return $sce.trustAsResourceUrl(url);
    };
} ]), angular.module("fluro.util").service("CacheManager", [ "$resource", "$cacheFactory", function($resource, $cacheFactory) {
    var controller = {}, _caches = [];
    return controller.get = function(type) {
        var cache = $cacheFactory.get(type + "-list");
        return cache || (cache = $cacheFactory(type + "-list"), _caches.push(cache)), cache;
    }, controller.clear = function(type) {
        var cache = $cacheFactory.get(type + "-list");
        cache && cache.removeAll();
    }, controller.clearAll = function() {
        _.each(_caches, function(cache) {
            cache.removeAll();
        });
    }, controller;
} ]), angular.module("fluro.util").factory("ContentSelection", function() {
    var ContentSelection = function() {
        var controller = this;
        controller.items = [], controller.multiInstance = !1, controller.trackValue = "_id";
        var _minimum = 0, _maximum = 0;
        return controller.contains = function(item) {
            var id = item;
            if (_.isObject(item)) {
                if (!item.hasOwnProperty(controller.trackValue)) return console.log("Undefined track value: ", controller.trackValue, "For item", item), 
                !0;
                id = item[controller.trackValue];
            }
            var result = _.any(controller.items, function(existingItem) {
                return _.isObject(existingItem) ? existingItem.hasOwnProperty(controller.trackValue) ? existingItem[controller.trackValue] == id : existingItem : existingItem == id;
            });
            return result;
        }, controller.toggle = function(item) {
            var alreadySelected = controller.contains(item);
            alreadySelected ? controller.remove(item) : controller.add(item);
        }, controller.add = function(item) {
            return _.isObject(item) && !item.hasOwnProperty(controller.trackValue) ? void console.log("Track value '" + controller.trackValue + "' Not found on proposed item", item) : controller.contains(item) && !controller.multiInstance ? void console.log("Only allowed one instance of item", item) : _maximum && controller.items.length >= _maximum ? void (1 == _maximum && controller.only(item)) : (controller.items.push(item), 
            !0);
        }, controller.removeDuplicates = function() {
            controller.items = _.uniq(controller.items, function(item) {
                return _.isObject(item) && item.hasOwnProperty(controller.trackValue) ? item[controller.trackValue] : item;
            });
        }, controller.addMultiple = function(array) {
            controller.items = controller.items.concat(array), controller.multiInstance || controller.removeDuplicates();
        }, controller.only = function(item) {
            controller.items.length = 0, controller.add(item);
        }, controller.onlyMultiple = function(items) {
            controller.items = items, controller.multiInstance || controller.removeDuplicates();
        }, controller.remove = function(item) {
            var id = item;
            _.isObject(item) && (id = item[controller.trackValue]), _.remove(controller.items, function(existingItem) {
                return _.isObject(existingItem) && existingItem.hasOwnProperty(controller.trackValue) ? existingItem[controller.trackValue] == id : existingItem == id;
            });
        }, controller.removeMultiple = function(array) {
            _.remove(controller.items, function(existingItem) {
                return _.contains(array, existingItem);
            });
        }, Object.defineProperty(controller, "ids", {
            get: function() {
                return _.map(controller.items, function(item) {
                    return _.isObject(item) && item.hasOwnProperty("_id") ? item._id : item;
                });
            }
        }), controller.clear = function() {
            controller.items.length = 0;
        }, Object.defineProperty(controller, "length", {
            get: function() {
                return controller.items.length;
            }
        }), Object.defineProperty(controller, "minimum", {
            get: function() {
                return _minimum;
            },
            set: function(m) {
                _minimum = m;
            }
        }), Object.defineProperty(controller, "maximum", {
            get: function() {
                return _maximum;
            },
            set: function(m) {
                _maximum = m;
            }
        }), controller.set = function(array) {
            controller.items = array;
        }, controller;
    };
    return ContentSelection;
}), angular.module("fluro.util").filter("matchDate", [ "Fluro", "DateTools", function(Fluro, DateTools) {
    return function(items, dateString, style) {
        var date = new Date(dateString);
        return _.reduce(items, function(results, item) {
            var startDate, endDate;
            item.startDate && (startDate = Fluro.timezoneOffset ? DateTools.localDate(item.startDate) : new Date(item.startDate), 
            startDate.setHours(0, 0, 0, 0)), item.endDate && (startDate = Fluro.timezoneOffset ? DateTools.localDate(item.endDate) : new Date(item.endDate)), 
            endDate.setHours(23, 59, 59, 999);
            var checkTimestamp = date.getTime(), startTimestamp = startDate.getTime(), endTimestamp = endDate.getTime();
            switch (style) {
              case "upcoming":
                (startTimestamp >= checkTimestamp || endTimestamp >= checkTimestamp) && results.push(item);
                break;

              default:
                checkTimestamp >= startTimestamp && endTimestamp >= checkTimestamp && results.push(item);
            }
            return results;
        }, []);
    };
} ]).service("DateTools", [ "Fluro", function(Fluro) {
    var controller = {};
    return controller.calculateAge = function(d) {
        var today, birthDate;
        Fluro.timezoneOffset ? (today = controller.localDate(), birthDate = controller.localDate(d)) : (today = new Date(), 
        birthDate = new Date(d));
        var age = today.getFullYear() - birthDate.getFullYear(), m = today.getMonth() - birthDate.getMonth();
        return (0 > m || 0 === m && today.getDate() < birthDate.getDate()) && age--, age;
    }, controller.localDate = function(d) {
        var date;
        date = d ? new Date(d) : new Date();
        var timezoneOffset, browserOffset = date.getTimezoneOffset();
        if (Fluro.timezone) {
            timezoneOffset = moment.tz(date, Fluro.timezone).utcOffset(), browserOffset = moment(date).utcOffset();
            var difference = timezoneOffset - browserOffset, offsetDifference = 60 * difference * 1e3;
            new Date(date);
            date.setTime(date.getTime() + offsetDifference);
        }
        return date;
    }, controller.expired = function(d) {
        var today, checkDate;
        return Fluro.timezoneOffset ? (today = controller.localDate(), checkDate = controller.localDate(d)) : (today = new Date(), 
        checkDate = new Date(d)), today > checkDate;
    }, controller.isValidDate = function(d) {
        return "[object Date]" !== Object.prototype.toString.call(d) ? !1 : !isNaN(d.getTime());
    }, controller.readableDateRange = function(startDate, endDate, options) {
        options || (options = {}), _.isDate(startDate) || (startDate = Fluro.timezoneOffset ? controller.localDate(startDate) : new Date(startDate)), 
        _.isDate(endDate) || (endDate = Fluro.timezoneOffset ? controller.localDate(endDate) : new Date(endDate));
        var today;
        today = Fluro.timezoneOffset ? controller.localDate() : new Date();
        var string = "";
        return startDate.format("d/m/y") != endDate.format("d/m/y") ? (string = startDate.format("M Y") == endDate.format("M Y") ? startDate.format("l j") + " - " + endDate.format("l j F") : startDate.format("l j F") + " until " + endDate.format("l j F"), 
        today.format("Y") != endDate.format("Y") && (string = string + " " + endDate.format("Y"))) : startDate && (string = startDate.format("l j F"), 
        today.format("Y") != startDate.format("Y") && (string = string + " " + startDate.format("Y"))), 
        string;
    }, controller;
} ]), angular.module("fluro.util").service("FluroSanitize", function() {
    var controller = {};
    return controller.stripTags = function(input, allowed) {
        allowed = (((allowed || "") + "").toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join("");
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi, commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi, result = input.replace(commentsAndPhpTags, "").replace(/\u00A0/g, " ").replace(/&nbsp;/g, " ").replace(tags, function($0, $1) {
            return allowed.indexOf("<" + $1.toLowerCase() + ">") > -1 ? $0 : "";
        }), element = $("<div>" + result + "</div>");
        element.find("*").removeAttr("style");
        var htmlString = element.eq(0).html();
        return htmlString;
    }, controller;
}), angular.module("fluro.util").service("FluroStorage", [ "$rootScope", "$localStorage", "$sessionStorage", function($rootScope, $localStorage, $sessionStorage) {
    var controller = {};
    return controller.resetSessionStorage = function() {
        $rootScope.user && ($sessionStorage[$rootScope.user._id] = {});
    }, controller.resetLocalStorage = function() {
        $rootScope.user && ($localStorage[$rootScope.user._id] = {});
    }, controller.sessionStorage = function(key) {
        return $rootScope.user ? ($sessionStorage[$rootScope.user._id] || ($sessionStorage[$rootScope.user._id] = {}), 
        $sessionStorage[$rootScope.user._id][key] || ($sessionStorage[$rootScope.user._id][key] = {}), 
        $sessionStorage[$rootScope.user._id][key]) : void 0;
    }, controller.localStorage = function(key) {
        return $rootScope.user ? ($localStorage[$rootScope.user._id] || ($localStorage[$rootScope.user._id] = {}), 
        $localStorage[$rootScope.user._id][key] || ($localStorage[$rootScope.user._id][key] = {}), 
        $localStorage[$rootScope.user._id][key]) : void 0;
    }, controller;
} ]), angular.module("fluro.util").factory("ObjectSelection", function() {
    var ObjectSelection = function() {
        var controller = {
            items: [],
            item: null
        };
        return controller.multiple = !0, controller.minimum = 0, controller.maximum = 0, 
        controller.select = function(item) {
            controller.multiple ? _.contains(controller.items, item) || controller.items.push(item) : controller.item = item;
        }, controller.deselect = function(item) {
            controller.multiple ? _.pull(controller.items, item) : controller.item = null;
        }, controller.toggle = function(item) {
            controller.multiple ? _.contains(controller.items, item) ? controller.deselect(item) : controller.select(item) : controller.item == item ? controller.item = null : controller.item = item;
        }, controller.contains = function(item) {
            return controller.multiple ? _.contains(controller.items, item) : controller.item == item;
        }, controller;
    };
    return ObjectSelection;
}), angular.module("fluro.util").factory("Playlist", function() {
    function Playlist() {
        var _this = this, _items = [], _index = 0, _loop = !0, _direction = "forwards";
        return this.__defineSetter__("index", function(i) {
            _direction = _index > i ? "backwards" : "forwards", i != _index && (_index = i);
        }), this.__defineGetter__("index", function() {
            return _index;
        }), this.__defineGetter__("direction", function() {
            return _direction;
        }), this.__defineGetter__("currentItem", function() {
            return _items[_index];
        }), this.__defineGetter__("length", function() {
            return _items.length;
        }), this.indexOf = function(object) {
            return _items.indexOf(object);
        }, this.select = function(object) {
            var i = _items.indexOf(object);
            -1 != i && (_this.index = i);
        }, this.__defineGetter__("items", function() {
            return _items;
        }), this.__defineSetter__("items", function(array) {
            _items = array, _index = 0;
        }), this.__defineGetter__("previousEnabled", function() {
            return _loop ? !0 : _index > 0;
        }), this.__defineGetter__("nextEnabled", function() {
            return _loop ? !0 : _index < _items.length - 1;
        }), this.__defineGetter__("loop", function() {
            return _loop;
        }), this.__defineSetter__("loop", function(bol) {
            _loop = bol;
        }), this.next = function() {
            _index < _items.length - 1 ? _this.index = _index + 1 : _loop && (_this.index = 0);
        }, this.previous = function() {
            _index > 0 ? _this.index = _index - 1 : _loop && (_this.index = _items.length - 1);
        }, this.addItem = function(item) {
            return _items.push(item), item;
        }, this.addItemAt = function(item, pos) {
            return _items.splice(pos, 0, item), item;
        }, this.removeItem = function(item) {
            var _itemIndex = _items.indexOf(item), _result = _items[_itemIndex];
            return -1 != _itemIndex && _items.splice(_itemIndex, 1), _result;
        }, this.clear = function() {
            _items = new Array(), _index = 0;
        }, _this;
    }
    return Playlist;
}), function() {
    function addMapEntry(map, pair) {
        return map.set(pair[0], pair[1]), map;
    }
    function addSetEntry(set, value) {
        return set.add(value), set;
    }
    function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
    }
    function arrayEach(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1; ) ;
        return array;
    }
    function arrayEachRight(array, iteratee) {
        for (var length = null == array ? 0 : array.length; length-- && iteratee(array[length], length, array) !== !1; ) ;
        return array;
    }
    function arrayEvery(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (!predicate(array[index], index, array)) return !1;
        return !0;
    }
    function arrayFilter(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
            var value = array[index];
            predicate(value, index, array) && (result[resIndex++] = value);
        }
        return result;
    }
    function arrayIncludes(array, value) {
        var length = null == array ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (comparator(value, array[index])) return !0;
        return !1;
    }
    function arrayMap(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
        return result;
    }
    function arrayPush(array, values) {
        for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
        return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = null == array ? 0 : array.length;
        for (initAccum && length && (accumulator = array[++index]); ++index < length; ) accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = null == array ? 0 : array.length;
        for (initAccum && length && (accumulator = array[--length]); length--; ) accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator;
    }
    function arraySome(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
        return !1;
    }
    function asciiToArray(string) {
        return string.split("");
    }
    function asciiWords(string) {
        return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
        var result;
        return eachFunc(collection, function(value, key, collection) {
            return predicate(value, key, collection) ? (result = key, !1) : void 0;
        }), result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (comparator(array[index], value)) return index;
        return -1;
    }
    function baseIsNaN(value) {
        return value !== value;
    }
    function baseMean(array, iteratee) {
        var length = null == array ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
        return function(object) {
            return null == object ? undefined : object[key];
        };
    }
    function basePropertyOf(object) {
        return function(key) {
            return null == object ? undefined : object[key];
        };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        return eachFunc(collection, function(value, index, collection) {
            accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection);
        }), accumulator;
    }
    function baseSortBy(array, comparer) {
        var length = array.length;
        for (array.sort(comparer); length--; ) array[length] = array[length].value;
        return array;
    }
    function baseSum(array, iteratee) {
        for (var result, index = -1, length = array.length; ++index < length; ) {
            var current = iteratee(array[index]);
            current !== undefined && (result = result === undefined ? current : result + current);
        }
        return result;
    }
    function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
        return result;
    }
    function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
            return [ key, object[key] ];
        });
    }
    function baseUnary(func) {
        return function(value) {
            return func(value);
        };
    }
    function baseValues(object, props) {
        return arrayMap(props, function(key) {
            return object[key];
        });
    }
    function cacheHas(cache, key) {
        return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function countHolders(array, placeholder) {
        for (var length = array.length, result = 0; length--; ) array[length] === placeholder && ++result;
        return result;
    }
    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
        return null == object ? undefined : object[key];
    }
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
        for (var data, result = []; !(data = iterator.next()).done; ) result.push(data.value);
        return result;
    }
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        return map.forEach(function(value, key) {
            result[++index] = [ key, value ];
        }), result;
    }
    function overArg(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }
    function replaceHolders(array, placeholder) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
            var value = array[index];
            (value === placeholder || value === PLACEHOLDER) && (array[index] = PLACEHOLDER, 
            result[resIndex++] = index);
        }
        return result;
    }
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        return set.forEach(function(value) {
            result[++index] = value;
        }), result;
    }
    function setToPairs(set) {
        var index = -1, result = Array(set.size);
        return set.forEach(function(value) {
            result[++index] = [ value, value ];
        }), result;
    }
    function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
        for (var index = fromIndex + 1; index--; ) if (array[index] === value) return index;
        return index;
    }
    function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeSize(string) {
        for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); ) ++result;
        return result;
    }
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
    }
    var undefined, VERSION = "4.17.4", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [ [ "ary", WRAP_ARY_FLAG ], [ "bind", WRAP_BIND_FLAG ], [ "bindKey", WRAP_BIND_KEY_FLAG ], [ "curry", WRAP_CURRY_FLAG ], [ "curryRight", WRAP_CURRY_RIGHT_FLAG ], [ "flip", WRAP_FLIP_FLAG ], [ "partial", WRAP_PARTIAL_FLAG ], [ "partialRight", WRAP_PARTIAL_RIGHT_FLAG ], [ "rearg", WRAP_REARG_FLAG ] ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)", rsOrdUpper = "\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ rsDingbat, rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([ rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [ rsBreak, rsUpper + rsMiscLower, "$" ].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, 
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
    var deburredLetters = {
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
    }, htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    }, htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
    }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
        try {
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {}
    }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, asciiSize = baseProperty("length"), deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes), unescapeHtmlChar = basePropertyOf(htmlUnescapes), runInContext = function runInContext(context) {
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) return value;
                if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, 
            this.__values__ = undefined;
        }
        function LazyWrapper(value) {
            this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, 
            this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
        }
        function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, 
            result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), 
            result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), 
            result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1, result.__filtered__ = !0;
            } else result = this.clone(), result.__dir__ *= -1;
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = 0 > dir, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: for (;length-- && takeCount > resIndex; ) {
                index += dir;
                for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) value = computed; else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) continue outer;
                        break outer;
                    }
                }
                result[resIndex++] = value;
            }
            return result;
        }
        function Hash(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
        }
        function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            return this.size -= result ? 1 : 0, result;
        }
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
            var data = this.__data__;
            return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value, 
            this;
        }
        function ListCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [], this.size = 0;
        }
        function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (0 > index) return !1;
            var lastIndex = data.length - 1;
            return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, 
            !0;
        }
        function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return 0 > index ? undefined : data[index][1];
        }
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return 0 > index ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
            this;
        }
        function MapCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapCacheClear() {
            this.size = 0, this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
            };
        }
        function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            return this.size -= result ? 1 : 0, result;
        }
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
        }
        function SetCache(values) {
            var index = -1, length = null == values ? 0 : values.length;
            for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
        }
        function setCacheAdd(value) {
            return this.__data__.set(value, HASH_UNDEFINED), this;
        }
        function setCacheHas(value) {
            return this.__data__.has(value);
        }
        function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        function stackClear() {
            this.__data__ = new ListCache(), this.size = 0;
        }
        function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            return this.size = data.size, result;
        }
        function stackGet(key) {
            return this.__data__.get(key);
        }
        function stackHas(key) {
            return this.__data__.has(key);
        }
        function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                this.size = ++data.size, this;
                data = this.__data__ = new MapCache(pairs);
            }
            return data.set(key, value), this.size = data.size, this;
        }
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
            return result;
        }
        function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
        }
        function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
            (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) && baseAssignValue(object, key, value);
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
        }
        function assocIndexOf(array, key) {
            for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
            return -1;
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
            return baseEach(collection, function(value, key, collection) {
                setter(accumulator, value, iteratee(value), collection);
            }), accumulator;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
            "__proto__" == key && defineProperty ? defineProperty(object, key, {
                configurable: !0,
                enumerable: !0,
                value: value,
                writable: !0
            }) : object[key] = value;
        }
        function baseAt(object, paths) {
            for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length; ) result[index] = skip ? undefined : get(object, paths[index]);
            return result;
        }
        function baseClamp(number, lower, upper) {
            return number === number && (upper !== undefined && (number = upper >= number ? number : upper), 
            lower !== undefined && (number = number >= lower ? number : lower)), number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), 
            result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
                if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) return cloneBuffer(value, isDeep);
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                } else {
                    if (!cloneableTags[tag]) return object ? value : {};
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined : keysFunc(value);
            return arrayEach(props || value, function(subValue, key) {
                props && (key = subValue, subValue = value[key]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            }), result;
        }
        function baseConforms(source) {
            var props = keys(source);
            return function(object) {
                return baseConformsTo(object, source, props);
            };
        }
        function baseConformsTo(object, source, props) {
            var length = props.length;
            if (null == object) return !length;
            for (object = Object(object); length--; ) {
                var key = props[length], predicate = source[key], value = object[key];
                if (value === undefined && !(key in object) || !predicate(value)) return !1;
            }
            return !0;
        }
        function baseDelay(func, wait, args) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
            if (!length) return result;
            iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, 
            isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, 
            values = new SetCache(values));
            outer: for (;++index < length; ) {
                var value = array[index], computed = null == iteratee ? value : iteratee(value);
                if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                    for (var valuesIndex = valuesLength; valuesIndex--; ) if (values[valuesIndex] === computed) continue outer;
                    result.push(value);
                } else includes(values, computed, comparator) || result.push(value);
            }
            return result;
        }
        function baseEvery(collection, predicate) {
            var result = !0;
            return baseEach(collection, function(value, index, collection) {
                return result = !!predicate(value, index, collection);
            }), result;
        }
        function baseExtremum(array, iteratee, comparator) {
            for (var index = -1, length = array.length; ++index < length; ) {
                var value = array[index], current = iteratee(value);
                if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
            }
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            for (start = toInteger(start), 0 > start && (start = -start > length ? 0 : length + start), 
            end = end === undefined || end > length ? length : toInteger(end), 0 > end && (end += length), 
            end = start > end ? 0 : toLength(end); end > start; ) array[start++] = value;
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            return baseEach(collection, function(value, index, collection) {
                predicate(value, index, collection) && result.push(value);
            }), result;
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
                var value = array[index];
                depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
            }
            return result;
        }
        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
                return isFunction(object[key]);
            });
        }
        function baseGet(object, path) {
            path = castPath(path, object);
            for (var index = 0, length = path.length; null != object && length > index; ) object = object[toKey(path[index++])];
            return index && index == length ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
            return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
            return value > other;
        }
        function baseHas(object, key) {
            return null != object && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
            return null != object && key in Object(object);
        }
        function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee, comparator) {
            for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
                var array = arrays[othIndex];
                othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), 
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer: for (;++index < length && result.length < maxLength; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    for (othIndex = othLength; --othIndex; ) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
                    }
                    seen && seen.push(computed), result.push(value);
                }
            }
            return result;
        }
        function baseInverter(object, setter, iteratee, accumulator) {
            return baseForOwn(object, function(value, key, object) {
                setter(accumulator, iteratee(value), key, object);
            }), accumulator;
        }
        function baseInvoke(object, path, args) {
            path = castPath(path, object), object = parent(object, path);
            var func = null == object ? object : object[toKey(last(path))];
            return null == func ? undefined : apply(func, object, args);
        }
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
            return value === other ? !0 : null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) return !1;
                objIsArr = !0, objIsObj = !1;
            }
            if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                }
            }
            return isSameTag ? (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack)) : !1;
        }
        function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (null == object) return !length;
            for (object = Object(object); index--; ) {
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1;
            }
            for (;++index < length; ) {
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) return !1;
                } else {
                    var stack = new Stack();
                    if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return !1;
                }
            }
            return !0;
        }
        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) return !1;
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
            return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
        }
        function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
            return result;
        }
        function baseKeysIn(object) {
            if (!isObject(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for (var key in object) ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
            return result;
        }
        function baseLt(value, other) {
            return other > value;
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            return baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            }), result;
        }
        function baseMatches(source) {
            var matchData = getMatchData(source);
            return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        function baseMatchesProperty(path, srcValue) {
            return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
            object !== source && baseFor(source, function(srcValue, key) {
                if (isObject(srcValue)) stack || (stack = new Stack()), baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined;
                    newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue);
                }
            }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
            if (stacked) return void assignMergeValue(object, key, stacked);
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined, isCommon = newValue === undefined;
            if (isCommon) {
                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, 
                newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, 
                isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject(objValue) || srcIndex && isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
            }
            isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), 
            stack["delete"](srcValue)), assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
            var length = array.length;
            if (length) return n += 0 > n ? length : 0, isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(iteratees.length ? iteratees : [ identity ], baseUnary(getIteratee()));
            var result = baseMap(collection, function(value, key, collection) {
                var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value);
                });
                return {
                    criteria: criteria,
                    index: ++index,
                    value: value
                };
            });
            return baseSortBy(result, function(object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
                return hasIn(object, path);
            });
        }
        function basePickBy(object, paths, predicate) {
            for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
                var path = paths[index], value = baseGet(object, path);
                predicate(value, path) && baseSet(result, castPath(path, object), value);
            }
            return result;
        }
        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length; ) for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; ) seen !== array && splice.call(seen, fromIndex, 1), 
            splice.call(array, fromIndex, 1);
            return array;
        }
        function basePullAt(array, indexes) {
            for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
                var index = indexes[length];
                if (length == lastIndex || index !== previous) {
                    var previous = index;
                    isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
                }
            }
            return array;
        }
        function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
            for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; ) result[fromRight ? length : ++index] = start, 
            start += step;
            return result;
        }
        function baseRepeat(string, n) {
            var result = "";
            if (!string || 1 > n || n > MAX_SAFE_INTEGER) return result;
            do n % 2 && (result += string), n = nativeFloor(n / 2), n && (string += string); while (n);
            return result;
        }
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
            return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
            if (!isObject(object)) return object;
            path = castPath(path, object);
            for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length; ) {
                var key = toKey(path[index]), newValue = value;
                if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined, newValue === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {});
                }
                assignValue(nested, key, newValue), nested = nested[key];
            }
            return object;
        }
        function baseShuffle(collection) {
            return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            0 > start && (start = -start > length ? 0 : length + start), end = end > length ? length : end, 
            0 > end && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
            for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            return baseEach(collection, function(value, index, collection) {
                return result = predicate(value, index, collection), !result;
            }), !!result;
        }
        function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = null == array ? low : array.length;
            if ("number" == typeof value && value === value && HALF_MAX_ARRAY_LENGTH >= high) {
                for (;high > low; ) {
                    var mid = low + high >>> 1, computed = array[mid];
                    null !== computed && !isSymbol(computed) && (retHighest ? value >= computed : value > computed) ? low = mid + 1 : high = mid;
                }
                return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            for (var low = 0, high = null == array ? 0 : array.length, valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; high > low; ) {
                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = null === computed, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                if (valIsNaN) var setLow = retHighest || othIsReflexive; else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? !1 : retHighest ? value >= computed : value > computed;
                setLow ? low = mid + 1 : high = mid;
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee) {
            for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = 0 === value ? 0 : value;
                }
            }
            return result;
        }
        function baseToNumber(value) {
            return "number" == typeof value ? value : isSymbol(value) ? NAN : +value;
        }
        function baseToString(value) {
            if ("string" == typeof value) return value;
            if (isArray(value)) return arrayMap(value, baseToString) + "";
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
            if (comparator) isCommon = !1, includes = arrayIncludesWith; else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) return setToArray(set);
                isCommon = !1, includes = cacheHas, seen = new SetCache();
            } else seen = iteratee ? [] : result;
            outer: for (;++index < length; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                    for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
                    iteratee && seen.push(computed), result.push(value);
                } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), 
                result.push(value));
            }
            return result;
        }
        function baseUnset(object, path) {
            return path = castPath(path, object), object = parent(object, path), null == object || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); ) ;
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function(result, action) {
                return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
            }, result);
        }
        function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (2 > length) return length ? baseUniq(arrays[0]) : [];
            for (var index = -1, result = Array(length); ++index < length; ) for (var array = arrays[index], othIndex = -1; ++othIndex < length; ) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }
        function baseZipObject(props, values, assignFunc) {
            for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length; ) {
                var value = valsLength > index ? values[index] : undefined;
                assignFunc(result, props[index], value);
            }
            return result;
        }
        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
            return "function" == typeof value ? value : identity;
        }
        function castPath(value, object) {
            return isArray(value) ? value : isKey(value, object) ? [ value ] : stringToPath(toString(value));
        }
        function castSlice(array, start, end) {
            var length = array.length;
            return end = end === undefined ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            return buffer.copy(result), result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            return result.lastIndex = regexp.lastIndex, result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined, valIsNull = null === value, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined, othIsNull = null === other, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                if (!valIsNull && !valIsSymbol && !othIsSymbol && other > value || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
            }
            return 0;
        }
        function compareMultiple(object, other, orders) {
            for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
                var result = compareAscending(objCriteria[index], othCriteria[index]);
                if (result) {
                    if (index >= ordersLength) return result;
                    var order = orders[index];
                    return result * ("desc" == order ? -1 : 1);
                }
            }
            return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; ) result[leftIndex] = partials[leftIndex];
            for (;++argsIndex < holdersLength; ) (isUncurried || argsLength > argsIndex) && (result[holders[argsIndex]] = args[argsIndex]);
            for (;rangeLength--; ) result[leftIndex++] = args[argsIndex++];
            return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; ) result[argsIndex] = args[argsIndex];
            for (var offset = argsIndex; ++rightIndex < rightLength; ) result[offset + rightIndex] = partials[rightIndex];
            for (;++holdersIndex < holdersLength; ) (isUncurried || argsLength > argsIndex) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
            return result;
        }
        function copyArray(source, array) {
            var index = -1, length = source.length;
            for (array || (array = Array(length)); ++index < length; ) array[index] = source[index];
            return array;
        }
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            for (var index = -1, length = props.length; ++index < length; ) {
                var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                newValue === undefined && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
        }
        function createAssigner(assigner) {
            return baseRest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, 
                customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = 3 > length ? undefined : customizer, 
                length = 1), object = Object(object); ++index < length; ) {
                    var source = sources[index];
                    source && assigner(object, source, index, customizer);
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (null == collection) return collection;
                if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== !1; ) ;
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === !1) break;
                }
                return object;
            };
        }
        function createBind(func, bitmask, thisArg) {
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, arguments);
            }
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            return wrapper;
        }
        function createCaseFirst(methodName) {
            return function(string) {
                string = toString(string);
                var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                return chr[methodName]() + trailing;
            };
        }
        function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
        }
        function createCtor(Ctor) {
            return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return new Ctor();

                  case 1:
                    return new Ctor(args[0]);

                  case 2:
                    return new Ctor(args[0], args[1]);

                  case 3:
                    return new Ctor(args[0], args[1], args[2]);

                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);

                  case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                  case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                  case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurry(func, bitmask, arity) {
            function wrapper() {
                for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--; ) args[index] = arguments[index];
                var holders = 3 > length && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                if (length -= holders.length, arity > length) return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return apply(fn, this, args);
            }
            var Ctor = createCtor(func);
            return wrapper;
        }
        function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection), predicate = function(key) {
                        return iteratee(iterable[key], key, iterable);
                    };
                }
                var index = findIndexFunc(collection, predicate, fromIndex);
                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
        }
        function createFlow(fromRight) {
            return flatRest(function(funcs) {
                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                for (fromRight && funcs.reverse(); index--; ) {
                    var func = funcs[index];
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], !0);
                }
                for (index = wrapper ? index : length; ++index < length; ) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                    wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
                return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                    for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length; ) result = funcs[index].call(this, result);
                    return result;
                };
            });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            function wrapper() {
                for (var length = arguments.length, args = Array(length), index = length; index--; ) args[index] = arguments[index];
                if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), 
                length -= holdersCount, isCurried && arity > length) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), 
                isAry && length > ary && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), 
                fn.apply(thisBinding, args);
            }
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
            return wrapper;
        }
        function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {});
            };
        }
        function createMathOperation(operator, defaultValue) {
            return function(value, other) {
                var result;
                if (value === undefined && other === undefined) return defaultValue;
                if (value !== undefined && (result = value), other !== undefined) {
                    if (result === undefined) return other;
                    "string" == typeof value || "string" == typeof other ? (value = baseToString(value), 
                    other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), 
                    result = operator(value, other);
                }
                return result;
            };
        }
        function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
                return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                        return apply(iteratee, thisArg, args);
                    });
                });
            });
        }
        function createPadding(length, chars) {
            chars = chars === undefined ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (2 > charsLength) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
            function wrapper() {
                for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; ) args[leftIndex] = partials[leftIndex];
                for (;argsLength--; ) args[leftIndex++] = arguments[++argsIndex];
                return apply(fn, isBind ? thisArg : this, args);
            }
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            return wrapper;
        }
        function createRange(fromRight) {
            return function(start, end, step) {
                return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined), 
                start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), 
                step = step === undefined ? end > start ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
            };
        }
        function createRelationalOperation(operator) {
            return function(value, other) {
                return ("string" != typeof value || "string" != typeof other) && (value = toNumber(value), 
                other = toNumber(other)), operator(value, other);
            };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), 
            bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
            var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ], result = wrapFunc.apply(undefined, newData);
            return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, 
            setWrapToString(result, func, bitmask);
        }
        function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
                if (number = toNumber(number), precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) {
                    var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                    return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
                }
                return func(number);
            };
        }
        function createToPairs(keysFunc) {
            return function(object) {
                var tag = getTag(object);
                return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
            };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined), 
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity), 
            length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], 
            partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), 
            !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), 
            bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials); else var result = createBind(func, bitmask, thisArg);
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
            return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), 
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack), stack["delete"](srcValue)), 
            objValue;
        }
        function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) return stacked == other;
            var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                var arrValue = array[index], othValue = other[index];
                if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                if (compared !== undefined) {
                    if (compared) continue;
                    result = !1;
                    break;
                }
                if (seen) {
                    if (!arraySome(other, function(othValue, othIndex) {
                        return cacheHas(seen, othIndex) || arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack) ? void 0 : seen.push(othIndex);
                    })) {
                        result = !1;
                        break;
                    }
                } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                    result = !1;
                    break;
                }
            }
            return stack["delete"](array), stack["delete"](other), result;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                object = object.buffer, other = other.buffer;

              case arrayBufferTag:
                return object.byteLength == other.byteLength && equalFunc(new Uint8Array(object), new Uint8Array(other)) ? !0 : !1;

              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case regexpTag:
              case stringTag:
                return object == other + "";

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                var stacked = stack.get(object);
                if (stacked) return stacked == other;
                bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                return stack["delete"](object), result;

              case symbolTag:
                if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
            return !1;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) return !1;
            for (var index = objLength; index--; ) {
                var key = objProps[index];
                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
            }
            var stacked = stack.get(object);
            if (stacked && stack.get(other)) return stacked == other;
            var result = !0;
            stack.set(object, other), stack.set(other, object);
            for (var skipCtor = isPartial; ++index < objLength; ) {
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = !1;
                    break;
                }
                skipCtor || (skipCtor = "constructor" == key);
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
            }
            return stack["delete"](object), stack["delete"](other), result;
        }
        function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + "");
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        function getFuncName(func) {
            for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--; ) {
                var data = array[length], otherFunc = data.func;
                if (null == otherFunc || otherFunc == func) return data.name;
            }
            return result;
        }
        function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
        }
        function getIteratee() {
            var result = lodash.iteratee || iteratee;
            return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
            for (var result = keys(object), length = result.length; length--; ) {
                var key = result[length], value = object[key];
                result[length] = [ key, value, isStrictComparable(value) ];
            }
            return result;
        }
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
        }
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = undefined;
                var unmasked = !0;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
            result;
        }
        function getView(start, end, transforms) {
            for (var index = -1, length = transforms.length; ++index < length; ) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                  case "drop":
                    start += size;
                    break;

                  case "dropRight":
                    end -= size;
                    break;

                  case "take":
                    end = nativeMin(end, start + size);
                    break;

                  case "takeRight":
                    start = nativeMax(start, end - size);
                }
            }
            return {
                start: start,
                end: end
            };
        }
        function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            for (var index = -1, length = path.length, result = !1; ++index < length; ) {
                var key = toKey(path[index]);
                if (!(result = null != object && hasFunc(object, key))) break;
                object = object[key];
            }
            return result || ++index != length ? result : (length = null == object ? 0 : object.length, 
            !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object)));
        }
        function initCloneArray(array) {
            var length = array.length, result = array.constructor(length);
            return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, 
            result.input = array.input), result;
        }
        function initCloneObject(object) {
            return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return cloneMap(object, isDeep, cloneFunc);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return cloneSet(object, isDeep, cloneFunc);

              case symbolTag:
                return cloneSymbol(object);
            }
        }
        function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) return source;
            var lastIndex = length - 1;
            return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), 
            source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
            return length = null == length ? MAX_SAFE_INTEGER : length, !!length && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && length > value;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) return !1;
            var type = typeof index;
            return ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) ? eq(object[index], value) : !1;
        }
        function isKey(value, object) {
            if (isArray(value)) return !1;
            var type = typeof value;
            return "number" == type || "symbol" == type || "boolean" == type || null == value || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object);
        }
        function isKeyable(value) {
            var type = typeof value;
            return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
        }
        function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return !1;
            if (func === other) return !0;
            var data = getData(other);
            return !!data && func === data[0];
        }
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
            return value === proto;
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
            return function(object) {
                return null == object ? !1 : object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
        }
        function memoizeCapped(func) {
            var result = memoize(func, function(key) {
                return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
            }), cache = result.cache;
            return result;
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG) > newBitmask, isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!isCommon && !isCombo) return data;
            srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, 
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], 
            value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), 
            null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, 
            data;
        }
        function nativeKeysIn(object) {
            var result = [];
            if (null != object) for (var key in Object(object)) result.push(key);
            return result;
        }
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform) {
            return start = nativeMax(start === undefined ? func.length - 1 : start, 0), function() {
                for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
                index = -1;
                for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
                return otherArgs[start] = transform(array), apply(func, this, otherArgs);
            };
        }
        function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
            for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                if (lastCalled = stamp, remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(undefined, arguments);
            };
        }
        function shuffleSelf(array, size) {
            var index = -1, length = array.length, lastIndex = length - 1;
            for (size = size === undefined ? length : size; ++index < size; ) {
                var rand = baseRandom(index, lastIndex), value = array[rand];
                array[rand] = array[index], array[index] = value;
            }
            return array.length = size, array;
        }
        function toKey(value) {
            if ("string" == typeof value || isSymbol(value)) return value;
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
            if (null != func) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + "";
                } catch (e) {}
            }
            return "";
        }
        function updateWrapDetails(details, bitmask) {
            return arrayEach(wrapFlags, function(pair) {
                var value = "_." + pair[0];
                bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
            }), details.sort();
        }
        function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, 
            result.__values__ = wrapper.__values__, result;
        }
        function chunk(array, size, guard) {
            size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
            var length = null == array ? 0 : array.length;
            if (!length || 1 > size) return [];
            for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); length > index; ) result[resIndex++] = baseSlice(array, index, index += size);
            return result;
        }
        function compact(array) {
            for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                var value = array[index];
                value && (result[resIndex++] = value);
            }
            return result;
        }
        function concat() {
            var length = arguments.length;
            if (!length) return [];
            for (var args = Array(length - 1), array = arguments[0], index = length; index--; ) args[index - 1] = arguments[index];
            return arrayPush(isArray(array) ? copyArray(array) : [ array ], baseFlatten(args, 1));
        }
        function drop(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, 0 > n ? 0 : n, length)) : [];
        }
        function dropRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, 
            baseSlice(array, 0, 0 > n ? 0 : n)) : [];
        }
        function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
        }
        function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
        }
        function fill(array, value, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, 
            end = length), baseFill(array, value, start, end)) : [];
        }
        function findIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return 0 > index && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length - 1;
            return fromIndex !== undefined && (index = toInteger(fromIndex), index = 0 > fromIndex ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), 
            baseFindIndex(array, getIteratee(predicate, 3), index, !0);
        }
        function flatten(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
            var length = null == array ? 0 : array.length;
            return length ? (depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(array, depth)) : [];
        }
        function fromPairs(pairs) {
            for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
                var pair = pairs[index];
                result[pair[0]] = pair[1];
            }
            return result;
        }
        function head(array) {
            return array && array.length ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return 0 > index && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
        }
        function initial(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
        }
        function join(array, separator) {
            return null == array ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
            var length = null == array ? 0 : array.length;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length;
            return fromIndex !== undefined && (index = toInteger(fromIndex), index = 0 > index ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), 
            value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
        }
        function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }
        function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
        }
        function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
        }
        function remove(array, predicate) {
            var result = [];
            if (!array || !array.length) return result;
            var index = -1, indexes = [], length = array.length;
            for (predicate = getIteratee(predicate, 3); ++index < length; ) {
                var value = array[index];
                predicate(value, index, array) && (result.push(value), indexes.push(index));
            }
            return basePullAt(array, indexes), result;
        }
        function reverse(array) {
            return null == array ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, 
            end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)), 
            baseSlice(array, start, end)) : [];
        }
        function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }
        function sortedIndexOf(array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (length > index && eq(array[index], value)) return index;
            }
            return -1;
        }
        function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, !0);
        }
        function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0);
        }
        function sortedLastIndexOf(array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
                var index = baseSortedIndex(array, value, !0) - 1;
                if (eq(array[index], value)) return index;
            }
            return -1;
        }
        function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
        }
        function tail(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
            return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n), 
            baseSlice(array, 0, 0 > n ? 0 : n)) : [];
        }
        function takeRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, 
            baseSlice(array, 0 > n ? 0 : n, length)) : [];
        }
        function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
        }
        function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }
        function uniqWith(array, comparator) {
            return comparator = "function" == typeof comparator ? comparator : undefined, array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
            if (!array || !array.length) return [];
            var length = 0;
            return array = arrayFilter(array, function(group) {
                return isArrayLikeObject(group) ? (length = nativeMax(group.length, length), !0) : void 0;
            }), baseTimes(length, function(index) {
                return arrayMap(array, baseProperty(index));
            });
        }
        function unzipWith(array, iteratee) {
            if (!array || !array.length) return [];
            var result = unzip(array);
            return null == iteratee ? result : arrayMap(result, function(group) {
                return apply(iteratee, undefined, group);
            });
        }
        function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
        }
        function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
        }
        function chain(value) {
            var result = lodash(value);
            return result.__chain__ = !0, result;
        }
        function tap(value, interceptor) {
            return interceptor(value), value;
        }
        function thru(value, interceptor) {
            return interceptor(value);
        }
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
            this.__values__ === undefined && (this.__values__ = toArray(this.value()));
            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
            return {
                done: done,
                value: value
            };
        }
        function wrapperToIterator() {
            return this;
        }
        function wrapperPlant(value) {
            for (var result, parent = this; parent instanceof baseLodash; ) {
                var clone = wrapperClone(parent);
                clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
                var previous = clone;
                parent = parent.__wrapped__;
            }
            return previous.__wrapped__ = value, result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), 
                wrapped.__actions__.push({
                    func: thru,
                    args: [ reverse ],
                    thisArg: undefined
                }), new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), 
            func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
        }
        function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
        }
        function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
        }
        function flatMapDepth(collection, iteratee, depth) {
            return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth);
        }
        function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
        }
        function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
        }
        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            return 0 > fromIndex && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? length >= fromIndex && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
            return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [ iteratees ]), 
            orders = guard ? undefined : orders, isArray(orders) || (orders = null == orders ? [] : [ orders ]), 
            baseOrderBy(collection, iteratees, orders));
        }
        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
        }
        function sampleSize(collection, n, guard) {
            n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n);
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
        }
        function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
        }
        function size(collection) {
            if (null == collection) return 0;
            if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
            var tag = getTag(collection);
            return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), 
            func(collection, getIteratee(predicate, 3));
        }
        function after(n, func) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n), function() {
                return --n < 1 ? func.apply(this, arguments) : void 0;
            };
        }
        function ary(func, n, guard) {
            return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
            var result;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n), function() {
                return --n > 0 && (result = func.apply(this, arguments)), 1 >= n && (func = undefined), 
                result;
            };
        }
        function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            return result.placeholder = curry.placeholder, result;
        }
        function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            return result.placeholder = curryRight.placeholder, result;
        }
        function debounce(func, wait, options) {
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args);
            }
            function leadingEdge(time) {
                return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === undefined || timeSinceLastCall >= wait || 0 > timeSinceLastCall || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                return shouldInvoke(time) ? trailingEdge(time) : void (timerId = setTimeout(timerExpired, remainingWait(time)));
            }
            function trailingEdge(time) {
                return timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined, 
                result);
            }
            function cancel() {
                timerId !== undefined && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                    if (timerId === undefined) return leadingEdge(lastCallTime);
                    if (maxing) return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                }
                return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result;
            }
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
            maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
            trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
            debounced.flush = flush, debounced;
        }
        function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
            if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function() {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) return cache.get(key);
                var result = func.apply(this, args);
                return memoized.cache = cache.set(key, result) || cache, result;
            };
            return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
        }
        function negate(predicate) {
            if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
            return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return !predicate.call(this);

                  case 1:
                    return !predicate.call(this, args[0]);

                  case 2:
                    return !predicate.call(this, args[0], args[1]);

                  case 3:
                    return !predicate.call(this, args[0], args[1], args[2]);
                }
                return !predicate.apply(this, args);
            };
        }
        function once(func) {
            return before(2, func);
        }
        function rest(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return start = start === undefined ? start : toInteger(start), baseRest(func, start);
        }
        function spread(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
                var array = args[start], otherArgs = castSlice(args, 0, start);
                return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
            });
        }
        function throttle(func, wait, options) {
            var leading = !0, trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, 
            trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                leading: leading,
                maxWait: wait,
                trailing: trailing
            });
        }
        function unary(func) {
            return ary(func, 1);
        }
        function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
        }
        function castArray() {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [ value ];
        }
        function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
            return null == source || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
            return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        function isElement(value) {
            return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value);
        }
        function isEmpty(value) {
            if (null == value) return !0;
            if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for (var key in value) if (hasOwnProperty.call(value, key)) return !1;
            return !0;
        }
        function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
        }
        function isError(value) {
            if (!isObjectLike(value)) return !1;
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value);
        }
        function isFinite(value) {
            return "number" == typeof value && nativeIsFinite(value);
        }
        function isFunction(value) {
            if (!isObject(value)) return !1;
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
            return "number" == typeof value && value == toInteger(value);
        }
        function isLength(value) {
            return "number" == typeof value && value > -1 && value % 1 == 0 && MAX_SAFE_INTEGER >= value;
        }
        function isObject(value) {
            var type = typeof value;
            return null != value && ("object" == type || "function" == type);
        }
        function isObjectLike(value) {
            return null != value && "object" == typeof value;
        }
        function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
            return baseIsNative(value);
        }
        function isNull(value) {
            return null === value;
        }
        function isNil(value) {
            return null == value;
        }
        function isNumber(value) {
            return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
            var proto = getPrototype(value);
            if (null === proto) return !0;
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && MAX_SAFE_INTEGER >= value;
        }
        function isString(value) {
            return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
            return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
            if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
        }
        function toFinite(value) {
            if (!value) return 0 === value ? value : 0;
            if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
                var sign = 0 > value ? -1 : 1;
                return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
        }
        function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
        }
        function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
                var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                value = isObject(other) ? other + "" : other;
            }
            if ("string" != typeof value) return 0 === value ? value : +value;
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0;
        }
        function toString(value) {
            return null == value ? "" : baseToString(value);
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return null == properties ? result : baseAssign(result, properties);
        }
        function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee) {
            return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }
        function forInRight(object, iteratee) {
            return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }
        function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
        }
        function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }
        function functions(object) {
            return null == object ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
            return null == object ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = null == object ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            return null != object && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
            return null != object && hasPath(object, path, baseHasIn);
        }
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                baseAssignValue(result, iteratee(value, key, object), value);
            }), result;
        }
        function mapValues(object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                baseAssignValue(result, key, iteratee(value, key, object));
            }), result;
        }
        function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
        }
        function pickBy(object, predicate) {
            if (null == object) return {};
            var props = arrayMap(getAllKeysIn(object), function(prop) {
                return [ prop ];
            });
            return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path) {
                return predicate(value, path[0]);
            });
        }
        function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            for (length || (length = 1, object = undefined); ++index < length; ) {
                var value = null == object ? undefined : object[toKey(path[index])];
                value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value;
            }
            return object;
        }
        function set(object, path, value) {
            return null == object ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer);
        }
        function transform(object, iteratee, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            if (iteratee = getIteratee(iteratee, 4), null == accumulator) {
                var Ctor = object && object.constructor;
                accumulator = isArrLike ? isArr ? new Ctor() : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            }), accumulator;
        }
        function unset(object, path) {
            return null == object ? !0 : baseUnset(object, path);
        }
        function update(object, path, updater) {
            return null == object ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
            return null == object ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
            return null == object ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
            return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = toNumber(upper), 
            upper = upper === upper ? upper : 0), lower !== undefined && (lower = toNumber(lower), 
            lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
            return start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), 
            number = toNumber(number), baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
            if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined), 
            floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower, 
            lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toFinite(lower), 
            upper === undefined ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
                var temp = lower;
                lower = upper, upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
        }
        function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
            return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
            string = toString(string), target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            return position -= target.length, position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
            return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        function pad(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && length > strLength ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && length > strLength ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt(string, radix, guard) {
            return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
            return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n), 
            baseRepeat(toString(string), n);
        }
        function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        function split(string, separator, limit) {
            return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined), 
            (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string), 
            string && ("string" == typeof separator || null != separator && !isRegExp(separator)) && (separator = baseToString(separator), 
            !separator && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit)) : [];
        }
        function startsWith(string, target, position) {
            return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length), 
            target = baseToString(target), string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
            var settings = lodash.templateSettings;
            guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string), 
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), 
                escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), 
                evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), 
                interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), 
                index = offset + match.length, match;
            }), source += "';\n";
            var variable = options.variable;
            variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), 
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            if (result.source = source, isError(result)) throw result;
            return result;
        }
        function toLower(value) {
            return toString(value).toLowerCase();
        }
        function toUpper(value) {
            return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
            if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrim, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
            if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
            if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrimStart, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = "separator" in options ? options.separator : separator;
                length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length;
            }
            if (length >= strLength) return string;
            var end = length - stringSize(omission);
            if (1 > end) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) return result + omission;
            if (strSymbols && (end += result.length - end), isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")), 
                    separator.lastIndex = 0; match = separator.exec(substring); ) var newEnd = match.index;
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                }
            } else if (string.indexOf(baseToString(separator), end) != end) {
                var index = result.lastIndexOf(separator);
                index > -1 && (result = result.slice(0, index));
            }
            return result + omission;
        }
        function unescape(string) {
            return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
            return string = toString(string), pattern = guard ? undefined : pattern, pattern === undefined ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
        }
        function cond(pairs) {
            var length = null == pairs ? 0 : pairs.length, toIteratee = getIteratee();
            return pairs = length ? arrayMap(pairs, function(pair) {
                if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
                return [ toIteratee(pair[0]), pair[1] ];
            }) : [], baseRest(function(args) {
                for (var index = -1; ++index < length; ) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) return apply(pair[1], this, args);
                }
            });
        }
        function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function defaultTo(value, defaultValue) {
            return null == value || value !== value ? defaultValue : value;
        }
        function identity(value) {
            return value;
        }
        function iteratee(func) {
            return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            null != options || isObject(source) && (methodNames.length || !props.length) || (options = source, 
            source = object, object = this, methodNames = baseFunctions(source, keys(source)));
            var chain = !(isObject(options) && "chain" in options && !options.chain), isFunc = isFunction(object);
            return arrayEach(methodNames, function(methodName) {
                var func = source[methodName];
                object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                        return actions.push({
                            func: func,
                            args: arguments,
                            thisArg: object
                        }), result.__chain__ = chainAll, result;
                    }
                    return func.apply(object, arrayPush([ this.value() ], arguments));
                });
            }), object;
        }
        function noConflict() {
            return root._ === this && (root._ = oldDash), this;
        }
        function noop() {}
        function nthArg(n) {
            return n = toInteger(n), baseRest(function(args) {
                return baseNth(args, n);
            });
        }
        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function(path) {
                return null == object ? undefined : baseGet(object, path);
            };
        }
        function stubArray() {
            return [];
        }
        function stubFalse() {
            return !1;
        }
        function stubObject() {
            return {};
        }
        function stubString() {
            return "";
        }
        function stubTrue() {
            return !0;
        }
        function times(n, iteratee) {
            if (n = toInteger(n), 1 > n || n > MAX_SAFE_INTEGER) return [];
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
            for (var result = baseTimes(length, iteratee); ++index < n; ) iteratee(index);
            return result;
        }
        function toPath(value) {
            return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [ value ] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
        }
        function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }
        function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
        }
        function mean(array) {
            return baseMean(array, identity);
        }
        function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
        }
        function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }
        function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
        }
        function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
        }
        context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
        }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), oldDash = root._, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined, defineProperty = function() {
            try {
                var func = getNative(Object, "defineProperty");
                return func({}, "", {}), func;
            } catch (e) {}
        }(), ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout, nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create"), metaMap = WeakMap && new WeakMap(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined, baseCreate = function() {
            function object() {}
            return function(proto) {
                if (!isObject(proto)) return {};
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object();
                return object.prototype = undefined, result;
            };
        }();
        lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        }, lodash.prototype = baseLodash.prototype, lodash.prototype.constructor = lodash, 
        LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, 
        LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, 
        Hash.prototype.clear = hashClear, Hash.prototype["delete"] = hashDelete, Hash.prototype.get = hashGet, 
        Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, 
        ListCache.prototype["delete"] = listCacheDelete, ListCache.prototype.get = listCacheGet, 
        ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, 
        MapCache.prototype.clear = mapCacheClear, MapCache.prototype["delete"] = mapCacheDelete, 
        MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, 
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, 
        Stack.prototype.clear = stackClear, Stack.prototype["delete"] = stackDelete, Stack.prototype.get = stackGet, 
        Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
        var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0), baseFor = createBaseFor(), baseForRight = createBaseFor(!0), baseSetData = metaMap ? function(func, data) {
            return metaMap.set(func, data), func;
        } : identity, baseSetToString = defineProperty ? function(func, string) {
            return defineProperty(func, "toString", {
                configurable: !0,
                enumerable: !1,
                value: constant(string),
                writable: !0
            });
        } : identity, castRest = baseRest, clearTimeout = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
        }, createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY ? function(values) {
            return new Set(values);
        } : noop, getData = metaMap ? function(func) {
            return metaMap.get(func);
        } : noop, getSymbols = nativeGetSymbols ? function(object) {
            return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
            }));
        } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
            for (var result = []; object; ) arrayPush(result, getSymbols(object)), object = getPrototype(object);
            return result;
        } : stubArray, getTag = baseGetTag;
        (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;

              case mapCtorString:
                return mapTag;

              case promiseCtorString:
                return promiseTag;

              case setCtorString:
                return setTag;

              case weakMapCtorString:
                return weakMapTag;
            }
            return result;
        });
        var isMaskable = coreJsData ? isFunction : stubFalse, setData = shortOut(baseSetData), setTimeout = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
        }, setToString = shortOut(baseSetToString), stringToPath = memoizeCapped(function(string) {
            var result = [];
            return reLeadingDot.test(string) && result.push(""), string.replace(rePropName, function(match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
            }), result;
        }), difference = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : [];
        }), differenceBy = baseRest(function(array, values) {
            var iteratee = last(values);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : [];
        }), differenceWith = baseRest(function(array, values) {
            var comparator = last(values);
            return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : [];
        }), intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        }), intersectionBy = baseRest(function(arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
        }), intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            return comparator = "function" == typeof comparator ? comparator : undefined, comparator && mapped.pop(), 
            mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        }), pull = baseRest(pullAll), pullAt = flatRest(function(array, indexes) {
            var length = null == array ? 0 : array.length, result = baseAt(array, indexes);
            return basePullAt(array, arrayMap(indexes, function(index) {
                return isIndex(index, length) ? +index : index;
            }).sort(compareAscending)), result;
        }), union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
        }), unionBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2));
        }), unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            return comparator = "function" == typeof comparator ? comparator : undefined, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator);
        }), without = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        }), xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
        }), xorBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        }), xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            return comparator = "function" == typeof comparator ? comparator : undefined, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        }), zip = baseRest(unzip), zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            return iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined, 
            unzipWith(arrays, iteratee);
        }), wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                return baseAt(object, paths);
            };
            return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? (value = value.slice(start, +start + (length ? 1 : 0)), 
            value.__actions__.push({
                func: thru,
                args: [ interceptor ],
                thisArg: undefined
            }), new LodashWrapper(value, this.__chain__).thru(function(array) {
                return length && !array.length && array.push(undefined), array;
            })) : this.thru(interceptor);
        }), countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1);
        }), find = createFind(findIndex), findLast = createFind(findLastIndex), groupBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [ value ]);
        }), invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = "function" == typeof path, result = isArrayLike(collection) ? Array(collection.length) : [];
            return baseEach(collection, function(value) {
                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            }), result;
        }), keyBy = createAggregator(function(result, value, key) {
            baseAssignValue(result, key, value);
        }), partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [ [], [] ];
        }), sortBy = baseRest(function(collection, iteratees) {
            if (null == collection) return [];
            var length = iteratees.length;
            return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [ iteratees[0] ]), 
            baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        }), now = ctxNow || function() {
            return root.Date.now();
        }, bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
        }), bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bindKey));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
        }), defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
        }), delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
        });
        memoize.Cache = MapCache;
        var overArgs = castRest(function(func, transforms) {
            transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
                for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; ) args[index] = transforms[index].call(this, args[index]);
                return apply(func, this, args);
            });
        }), partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        }), partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        }), rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        }), gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
            return value >= other;
        }), isArguments = baseIsArguments(function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        }, isArray = Array.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer, isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
            return other >= value;
        }), assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) return void copyObject(source, keys(source), object);
            for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key]);
        }), assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
        }), assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        }), assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
        }), at = flatRest(baseAt), defaults = baseRest(function(args) {
            return args.push(undefined, customDefaultsAssignIn), apply(assignInWith, undefined, args);
        }), defaultsDeep = baseRest(function(args) {
            return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args);
        }), invert = createInverter(function(result, value, key) {
            result[value] = key;
        }, constant(identity)), invertBy = createInverter(function(result, value, key) {
            hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [ key ];
        }, getIteratee), invoke = baseRest(baseInvoke), merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        }), mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        }), omit = flatRest(function(object, paths) {
            var result = {};
            if (null == object) return result;
            var isDeep = !1;
            paths = arrayMap(paths, function(path) {
                return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path;
            }), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
            for (var length = paths.length; length--; ) baseUnset(result, paths[length]);
            return result;
        }), pick = flatRest(function(object, paths) {
            return null == object ? {} : basePick(object, paths);
        }), toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn), camelCase = createCompounder(function(result, word, index) {
            return word = word.toLowerCase(), result + (index ? capitalize(word) : word);
        }), kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        }), lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toLowerCase();
        }), lowerFirst = createCaseFirst("toLowerCase"), snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
        }), startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + upperFirst(word);
        }), upperCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toUpperCase();
        }), upperFirst = createCaseFirst("toUpperCase"), attempt = baseRest(function(func, args) {
            try {
                return apply(func, undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        }), bindAll = flatRest(function(object, methodNames) {
            return arrayEach(methodNames, function(key) {
                key = toKey(key), baseAssignValue(object, key, bind(object[key], object));
            }), object;
        }), flow = createFlow(), flowRight = createFlow(!0), method = baseRest(function(path, args) {
            return function(object) {
                return baseInvoke(object, path, args);
            };
        }), methodOf = baseRest(function(object, args) {
            return function(path) {
                return baseInvoke(object, path, args);
            };
        }), over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome), range = createRange(), rangeRight = createRange(!0), add = createMathOperation(function(augend, addend) {
            return augend + addend;
        }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
        }, 1), floor = createRound("floor"), multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
        }, 1), round = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
        }, 0);
        return lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn, 
        lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at, 
        lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, 
        lodash.castArray = castArray, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact, 
        lodash.concat = concat, lodash.cond = cond, lodash.conforms = conforms, lodash.constant = constant, 
        lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight, 
        lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, 
        lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy, 
        lodash.differenceWith = differenceWith, lodash.drop = drop, lodash.dropRight = dropRight, 
        lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill, 
        lodash.filter = filter, lodash.flatMap = flatMap, lodash.flatMapDeep = flatMapDeep, 
        lodash.flatMapDepth = flatMapDepth, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep, 
        lodash.flattenDepth = flattenDepth, lodash.flip = flip, lodash.flow = flow, lodash.flowRight = flowRight, 
        lodash.fromPairs = fromPairs, lodash.functions = functions, lodash.functionsIn = functionsIn, 
        lodash.groupBy = groupBy, lodash.initial = initial, lodash.intersection = intersection, 
        lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith, 
        lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap, 
        lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn, 
        lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches, 
        lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge, 
        lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf, 
        lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = nthArg, lodash.omit = omit, 
        lodash.omitBy = omitBy, lodash.once = once, lodash.orderBy = orderBy, lodash.over = over, 
        lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome, 
        lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, 
        lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = propertyOf, 
        lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = pullAllBy, lodash.pullAllWith = pullAllWith, 
        lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg, 
        lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.reverse = reverse, 
        lodash.sampleSize = sampleSize, lodash.set = set, lodash.setWith = setWith, lodash.shuffle = shuffle, 
        lodash.slice = slice, lodash.sortBy = sortBy, lodash.sortedUniq = sortedUniq, lodash.sortedUniqBy = sortedUniqBy, 
        lodash.split = split, lodash.spread = spread, lodash.tail = tail, lodash.take = take, 
        lodash.takeRight = takeRight, lodash.takeRightWhile = takeRightWhile, lodash.takeWhile = takeWhile, 
        lodash.tap = tap, lodash.throttle = throttle, lodash.thru = thru, lodash.toArray = toArray, 
        lodash.toPairs = toPairs, lodash.toPairsIn = toPairsIn, lodash.toPath = toPath, 
        lodash.toPlainObject = toPlainObject, lodash.transform = transform, lodash.unary = unary, 
        lodash.union = union, lodash.unionBy = unionBy, lodash.unionWith = unionWith, lodash.uniq = uniq, 
        lodash.uniqBy = uniqBy, lodash.uniqWith = uniqWith, lodash.unset = unset, lodash.unzip = unzip, 
        lodash.unzipWith = unzipWith, lodash.update = update, lodash.updateWith = updateWith, 
        lodash.values = values, lodash.valuesIn = valuesIn, lodash.without = without, lodash.words = words, 
        lodash.wrap = wrap, lodash.xor = xor, lodash.xorBy = xorBy, lodash.xorWith = xorWith, 
        lodash.zip = zip, lodash.zipObject = zipObject, lodash.zipObjectDeep = zipObjectDeep, 
        lodash.zipWith = zipWith, lodash.entries = toPairs, lodash.entriesIn = toPairsIn, 
        lodash.extend = assignIn, lodash.extendWith = assignInWith, mixin(lodash, lodash), 
        lodash.add = add, lodash.attempt = attempt, lodash.camelCase = camelCase, lodash.capitalize = capitalize, 
        lodash.ceil = ceil, lodash.clamp = clamp, lodash.clone = clone, lodash.cloneDeep = cloneDeep, 
        lodash.cloneDeepWith = cloneDeepWith, lodash.cloneWith = cloneWith, lodash.conformsTo = conformsTo, 
        lodash.deburr = deburr, lodash.defaultTo = defaultTo, lodash.divide = divide, lodash.endsWith = endsWith, 
        lodash.eq = eq, lodash.escape = escape, lodash.escapeRegExp = escapeRegExp, lodash.every = every, 
        lodash.find = find, lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast, 
        lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.floor = floor, 
        lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, 
        lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, 
        lodash.get = get, lodash.gt = gt, lodash.gte = gte, lodash.has = has, lodash.hasIn = hasIn, 
        lodash.head = head, lodash.identity = identity, lodash.includes = includes, lodash.indexOf = indexOf, 
        lodash.inRange = inRange, lodash.invoke = invoke, lodash.isArguments = isArguments, 
        lodash.isArray = isArray, lodash.isArrayBuffer = isArrayBuffer, lodash.isArrayLike = isArrayLike, 
        lodash.isArrayLikeObject = isArrayLikeObject, lodash.isBoolean = isBoolean, lodash.isBuffer = isBuffer, 
        lodash.isDate = isDate, lodash.isElement = isElement, lodash.isEmpty = isEmpty, 
        lodash.isEqual = isEqual, lodash.isEqualWith = isEqualWith, lodash.isError = isError, 
        lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isInteger = isInteger, 
        lodash.isLength = isLength, lodash.isMap = isMap, lodash.isMatch = isMatch, lodash.isMatchWith = isMatchWith, 
        lodash.isNaN = isNaN, lodash.isNative = isNative, lodash.isNil = isNil, lodash.isNull = isNull, 
        lodash.isNumber = isNumber, lodash.isObject = isObject, lodash.isObjectLike = isObjectLike, 
        lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isSafeInteger = isSafeInteger, 
        lodash.isSet = isSet, lodash.isString = isString, lodash.isSymbol = isSymbol, lodash.isTypedArray = isTypedArray, 
        lodash.isUndefined = isUndefined, lodash.isWeakMap = isWeakMap, lodash.isWeakSet = isWeakSet, 
        lodash.join = join, lodash.kebabCase = kebabCase, lodash.last = last, lodash.lastIndexOf = lastIndexOf, 
        lodash.lowerCase = lowerCase, lodash.lowerFirst = lowerFirst, lodash.lt = lt, lodash.lte = lte, 
        lodash.max = max, lodash.maxBy = maxBy, lodash.mean = mean, lodash.meanBy = meanBy, 
        lodash.min = min, lodash.minBy = minBy, lodash.stubArray = stubArray, lodash.stubFalse = stubFalse, 
        lodash.stubObject = stubObject, lodash.stubString = stubString, lodash.stubTrue = stubTrue, 
        lodash.multiply = multiply, lodash.nth = nth, lodash.noConflict = noConflict, lodash.noop = noop, 
        lodash.now = now, lodash.pad = pad, lodash.padEnd = padEnd, lodash.padStart = padStart, 
        lodash.parseInt = parseInt, lodash.random = random, lodash.reduce = reduce, lodash.reduceRight = reduceRight, 
        lodash.repeat = repeat, lodash.replace = replace, lodash.result = result, lodash.round = round, 
        lodash.runInContext = runInContext, lodash.sample = sample, lodash.size = size, 
        lodash.snakeCase = snakeCase, lodash.some = some, lodash.sortedIndex = sortedIndex, 
        lodash.sortedIndexBy = sortedIndexBy, lodash.sortedIndexOf = sortedIndexOf, lodash.sortedLastIndex = sortedLastIndex, 
        lodash.sortedLastIndexBy = sortedLastIndexBy, lodash.sortedLastIndexOf = sortedLastIndexOf, 
        lodash.startCase = startCase, lodash.startsWith = startsWith, lodash.subtract = subtract, 
        lodash.sum = sum, lodash.sumBy = sumBy, lodash.template = template, lodash.times = times, 
        lodash.toFinite = toFinite, lodash.toInteger = toInteger, lodash.toLength = toLength, 
        lodash.toLower = toLower, lodash.toNumber = toNumber, lodash.toSafeInteger = toSafeInteger, 
        lodash.toString = toString, lodash.toUpper = toUpper, lodash.trim = trim, lodash.trimEnd = trimEnd, 
        lodash.trimStart = trimStart, lodash.truncate = truncate, lodash.unescape = unescape, 
        lodash.uniqueId = uniqueId, lodash.upperCase = upperCase, lodash.upperFirst = upperFirst, 
        lodash.each = forEach, lodash.eachRight = forEachRight, lodash.first = head, mixin(lodash, function() {
            var source = {};
            return baseForOwn(lodash, function(func, methodName) {
                hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func);
            }), source;
        }(), {
            chain: !1
        }), lodash.VERSION = VERSION, arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        }), arrayEach([ "drop", "take" ], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                    size: nativeMin(n, MAX_ARRAY_LENGTH),
                    type: methodName + (result.__dir__ < 0 ? "Right" : "")
                }), result;
            }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
        }), arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee) {
                var result = this.clone();
                return result.__iteratees__.push({
                    iteratee: getIteratee(iteratee, 3),
                    type: type
                }), result.__filtered__ = result.__filtered__ || isFilter, result;
            };
        }), arrayEach([ "head", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        }), arrayEach([ "initial", "tail" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
        }), LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        }, LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
        }, LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
        }, LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            return "function" == typeof path ? new LazyWrapper(this) : this.map(function(value) {
                return baseInvoke(value, path, args);
            });
        }), LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
        }, LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            return result.__filtered__ && (start > 0 || 0 > end) ? new LazyWrapper(result) : (0 > start ? result = result.takeRight(-start) : start && (result = result.drop(start)), 
            end !== undefined && (end = toInteger(end), result = 0 > end ? result.dropRight(-end) : result.take(end - start)), 
            result);
        }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
        }, LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
        }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            lodashFunc && (lodash.prototype[methodName] = function() {
                var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value), interceptor = function(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                    return isTaker && chainAll ? result[0] : result;
                };
                useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    return result.__actions__.push({
                        func: thru,
                        args: [ interceptor ],
                        thisArg: undefined
                    }), new LodashWrapper(result, chainAll);
                }
                return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), 
                isUnwrapped ? isTaker ? result.value()[0] : result.value() : result);
            });
        }), arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                }
                return this[chainName](function(value) {
                    return func.apply(isArray(value) ? value : [], args);
                });
            };
        }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name + "", names = realNames[key] || (realNames[key] = []);
                names.push({
                    name: methodName,
                    func: lodashFunc
                });
            }
        }), realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [ {
            name: "wrapper",
            func: undefined
        } ], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, 
        LazyWrapper.prototype.value = lazyValue, lodash.prototype.at = wrapperAt, lodash.prototype.chain = wrapperChain, 
        lodash.prototype.commit = wrapperCommit, lodash.prototype.next = wrapperNext, lodash.prototype.plant = wrapperPlant, 
        lodash.prototype.reverse = wrapperReverse, lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue, 
        lodash.prototype.first = lodash.prototype.head, symIterator && (lodash.prototype[symIterator] = wrapperToIterator), 
        lodash;
    }, _ = runInContext();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _, 
    define(function() {
        return _;
    })) : freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _;
}.call(this), angular.module("fluro.content", [ "fluro.util", "ngResource" ]), angular.module("fluro.content").service("FluroContent", [ "$resource", "CacheManager", "Fluro", function($resource, CacheManager, Fluro) {
    var controller = {};
    return controller.resource = function(type, ignoreLoadingBar, noCache) {
        var cache = CacheManager.get(type);
        return noCache && (cache = !1), $resource(Fluro.apiURL + "/content/" + type + "/:id", {}, {
            update: {
                method: "PUT",
                ignoreLoadingBar: ignoreLoadingBar
            },
            save: {
                method: "POST",
                ignoreLoadingBar: ignoreLoadingBar
            },
            query: {
                method: "GET",
                isArray: !0,
                cache: cache,
                ignoreLoadingBar: ignoreLoadingBar
            },
            batch: {
                method: "POST",
                ignoreLoadingBar: ignoreLoadingBar
            }
        });
    }, controller.endpoint = function(path, ignoreLoadingBar, noCache) {
        var cache = CacheManager.get(path);
        return noCache && (cache = !1), $resource(Fluro.apiURL + "/" + path, {}, {
            update: {
                method: "PUT",
                ignoreLoadingBar: ignoreLoadingBar
            },
            save: {
                method: "POST",
                ignoreLoadingBar: ignoreLoadingBar
            },
            query: {
                method: "GET",
                isArray: !0,
                cache: cache,
                ignoreLoadingBar: !0
            },
            batch: {
                method: "POST",
                ignoreLoadingBar: ignoreLoadingBar
            }
        });
    }, controller;
} ]), angular.module("fluro.content").service("FluroContentRetrieval", [ "$cacheFactory", "Fluro", "$q", "$http", function($cacheFactory, Fluro, $q, $http) {
    var controller = {}, cache = {};
    return controller.getItemFromProduct = function(itemID, productID, options) {
        options || (options = {});
        var deferred = $q.defer(), url = Fluro.apiURL + "/content/contained/" + productID + "/" + itemID;
        return options.noCache && (url += "?noCache=true"), $http.get(url).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.getCollection = function(id, noCache) {
        var deferred = $q.defer(), url = Fluro.apiURL + "/content/_collection/" + id;
        return noCache && (url += "?noCache=true"), $http.get(url).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.getMultipleCollections = function(ids, noCache, params) {
        var deferred = $q.defer(), url = Fluro.apiURL + "/content/_collection/multiple", queryParams = _.map(params, function(v, k) {
            return encodeURIComponent(k) + "=" + encodeURIComponent(v);
        }).join("&");
        return (noCache || queryParams) && (url += "?"), queryParams && queryParams.length && (url += queryParams), 
        noCache && (url += "&noCache=true"), $http({
            method: "GET",
            url: url,
            params: {
                ids: ids
            }
        }).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.getQuery = function(id, options, variables) {
        options || (options = {});
        var deferred = $q.defer(), url = Fluro.apiURL + "/content/_query/" + id, queryParams = "";
        return (options.noCache || options.template || variables) && (queryParams = "?"), 
        options.noCache && (queryParams += "&noCache=true"), options.template && (queryParams += "&template=" + options.template), 
        variables && (queryParams += _.map(variables, function(v, k) {
            return "variables[" + k + "]=" + encodeURIComponent(v);
        }).join("&")), queryParams.length && (url += queryParams), $http.get(url).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.query = function(queryDetails, typeName, id, params, variables) {
        var url, deferred = $q.defer();
        params || (params = {}), params && !_.isObject(params) && (params = {
            noCache: !0
        });
        var queryParams = _.map(params, function(v, k) {
            return encodeURIComponent(k) + "=" + encodeURIComponent(v);
        }).join("&");
        return variables && (queryParams += _.map(variables, function(v, k) {
            return "variables[" + k + "]=" + encodeURIComponent(v);
        }).join("&")), id && (url = Fluro.apiURL + "/content/_query/" + id, queryParams.length && (url += "?" + queryParams), 
        $http.get(url).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        })), typeName && typeName.length ? (url = Fluro.apiURL + "/content/" + typeName + "/_query", 
        queryParams.length && (url += "?" + queryParams), $http.post(url, queryDetails).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        })) : (url = Fluro.apiURL + "/content/_query", $http({
            url: url,
            method: "POST",
            params: params,
            data: queryDetails
        }).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        })), deferred.promise;
    }, controller.queryMultiple = function(ids, noCache, variables) {
        var variableParams, deferred = $q.defer(), url = Fluro.apiURL + "/content/_query/multiple";
        return variables && (variableParams = _.map(variables, function(v, k) {
            return "variables[" + k + "]=" + encodeURIComponent(v);
        }).join("&")), (noCache || variableParams) && (url += "?"), variableParams && variableParams.length && (url += variableParams), 
        noCache && (url += "&noCache=true"), $http({
            method: "GET",
            url: url,
            params: {
                ids: ids
            }
        }).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.retrieveMultiple = function(ids, noCache, params) {
        var deferred = $q.defer(), url = Fluro.apiURL + "/content/multiple";
        return noCache && (url += "?noCache=true"), params || (params = {}), params.ids = ids, 
        $http({
            method: "GET",
            url: url,
            params: params
        }).then(function(res) {
            deferred.resolve(res.data);
        }, function(err) {
            deferred.reject(err);
        }), deferred.promise;
    }, controller.populate = function(contentArray, noCache, params) {
        var ids = _.map(contentArray, function(item) {
            return item._id ? item._id : item;
        });
        return controller.get(ids, noCache, params);
    }, controller.populatePartial = function(contentArray, fields, noCache, searchInheritable) {
        var deferred = $q.defer(), ids = _.map(contentArray, function(item) {
            return item._id ? item._id : item;
        });
        return controller.retrieveMultiple(ids, noCache, {
            select: fields,
            searchInheritable: searchInheritable
        }).then(deferred.resolve, deferred.reject), deferred.promise;
    }, controller.get = function(ids, noCache, queryStringParams) {
        function finish() {
            var results = _.map(ids, function(id) {
                return cache[id];
            });
            deferred.resolve(results);
        }
        var requiredIds, deferred = $q.defer();
        return requiredIds = noCache ? ids : _.filter(ids, function(id) {
            return !cache[id];
        }), requiredIds.length ? (queryStringParams || (queryStringParams = {}), controller.retrieveMultiple(requiredIds, noCache, queryStringParams).then(function(res) {
            _.each(res, function(item) {
                cache[item._id] = item;
            }), finish();
        }, function(res) {
            deferred.reject(res);
        })) : finish(), deferred.promise;
    }, controller;
} ]), angular.module("fluro.asset", []), angular.module("fluro.asset").service("Asset", [ "Fluro", "$window", function(Fluro, $window) {
    var controller = {};
    controller.getUrl = function(id, params) {
        if (id) {
            var extension;
            params && _.isString(params) && (extension = params), params || (params = {});
            var url = Fluro.apiURL + "/get/" + id;
            extension && (params.extension = extension), params.extension && params.extension.length && (url += params.filename && params.filename.length ? "/file/" + params.filename + "." + params.extension : "/file/file." + params.extension, 
            delete params.extension), params.withoutToken || !params.access_token && Fluro.token && (params.access_token = Fluro.token);
            var queryParams = _.map(params, function(v, k) {
                return encodeURIComponent(k) + "=" + encodeURIComponent(v);
            }).join("&");
            return queryParams.length && (url += "?" + queryParams), url;
        }
    }, controller.thumbnailUrl = function(id) {
        return controller.getUrl(id, {
            w: 50
        });
    };
    var isRetina = window.devicePixelRatio > 1;
    return console.log("is retina"), controller.imageUrl = function(_id, w, h, params) {
        if (_id) {
            params || (params = {});
            var limitWidth, url = Fluro.apiURL + "/get/" + _id;
            limitWidth = isRetina ? 1920 : 1200, $window.screen.width <= 768 && (limitWidth = isRetina ? 1536 : 768), 
            $window.screen.width <= 320 && (limitWidth = isRetina ? 640 : 320), w || h ? (w && (params.w = w), 
            h && (params.h = h)) : params.w = limitWidth, params.extension && params.extension.length && (url += params.filename && params.filename.length ? "/file/" + params.filename + "." + params.extension : "/file/file." + params.extension, 
            delete params.extension), params.withoutToken || !params.access_token && Fluro.token && (params.access_token = Fluro.token), 
            params.quality || (params.quality = 90);
            var queryParams = _.map(params, function(v, k) {
                return encodeURIComponent(k) + "=" + encodeURIComponent(v);
            }).join("&");
            return queryParams.length && (url += "?" + queryParams), url;
        }
    }, controller.downloadUrl = function(id, params) {
        if (id) {
            params || (params = {});
            var url = Fluro.apiURL + "/download/" + id;
            params.extension && params.extension.length && (url += params.filename && params.filename.length ? "/file/" + params.filename + "." + params.extension : "/file/file." + params.extension, 
            delete params.extension), params.withoutToken || !params.access_token && Fluro.token && (params.access_token = Fluro.token);
            var queryParams = _.map(params, function(v, k) {
                return encodeURIComponent(k) + "=" + encodeURIComponent(v);
            }).join("&");
            return queryParams.length && (url += "?" + queryParams), url;
        }
    }, controller.avatarUrl = function(id, style, params) {
        params || (params = {}), style || (style = "user");
        var url = Fluro.apiURL + "/get/avatar/" + style + "/" + id;
        Fluro.token && (params.access_token = Fluro.token);
        var queryParams = _.map(params, function(v, k) {
            return encodeURIComponent(k) + "=" + encodeURIComponent(v);
        }).join("&");
        return queryParams.length && (url += "?" + queryParams), url;
    }, controller.isAssetType = function(object) {
        switch (object._type) {
          case "asset":
          case "video":
          case "audio":
          case "image":
            return !0;

          default:
            return !1;
        }
    }, controller;
} ]), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.moment = factory();
}(this, function() {
    "use strict";
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
    }
    function isObject(input) {
        return null != input && "[object Object]" === Object.prototype.toString.call(input);
    }
    function isObjectEmpty(obj) {
        var k;
        for (k in obj) return !1;
        return !0;
    }
    function isNumber(input) {
        return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
        return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
    }
    function map(arr, fn) {
        var i, res = [];
        for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
        a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !0).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null
        };
    }
    function getParsingFlags(m) {
        return null == m._pf && (m._pf = defaultParsingFlags()), m._pf;
    }
    function isValid(m) {
        if (null == m._isValid) {
            var flags = getParsingFlags(m), parsedParts = some$1.call(flags.parsedDateParts, function(i) {
                return null != i;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), 
            null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
            m._isValid = isNowValid;
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, 
        m;
    }
    function isUndefined(input) {
        return void 0 === input;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), 
        isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), 
        isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), 
        isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), 
        isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), 
        isUndefined(from._locale) || (to._locale = from._locale), momentProperties.length > 0) for (i in momentProperties) prop = momentProperties[i], 
        val = from[prop], isUndefined(val) || (to[prop] = val);
        return to;
    }
    function Moment(config) {
        copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), 
        this.isValid() || (this._d = new Date(NaN)), updateInProgress === !1 && (updateInProgress = !0, 
        hooks.updateOffset(this), updateInProgress = !1);
    }
    function isMoment(obj) {
        return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
    }
    function absFloor(number) {
        return 0 > number ? Math.ceil(number) || 0 : Math.floor(number);
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), 
        value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
        for (i = 0; len > i; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff;
    }
    function warn(msg) {
        hooks.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function() {
            if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                for (var arg, args = [], i = 0; i < arguments.length; i++) {
                    if (arg = "", "object" == typeof arguments[i]) {
                        arg += "\n[" + i + "] ";
                        for (var key in arguments[0]) arg += key + ": " + arguments[0][key] + ", ";
                        arg = arg.slice(0, -2);
                    } else arg = arguments[i];
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack), 
                firstTime = !1;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), 
        deprecations[name] = !0);
    }
    function isFunction(input) {
        return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    function set(config) {
        var prop, i;
        for (i in config) prop = config[i], isFunction(prop) ? this[i] = prop : this["_" + i] = prop;
        this._config = config, this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var prop, res = extend({}, parentConfig);
        for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, 
        extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
        for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
        return res;
    }
    function Locale(config) {
        null != config && this.set(config);
    }
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar.sameElse;
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        }), this._longDateFormat[key]);
    }
    function invalidDate() {
        return this._invalidDate;
    }
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop), 
        normalizedProp && (normalizedInput[normalizedProp] = inputObject[prop]));
        return normalizedInput;
    }
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) units.push({
            unit: u,
            priority: priorities[u]
        });
        return units.sort(function(a, b) {
            return a.priority - b.priority;
        }), units;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), 
            this) : get(this, unit);
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        mom.isValid() && mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function stringGet(units) {
        return units = normalizeUnits(units), isFunction(this[units]) ? this[units]() : this;
    }
    function stringSet(units, value) {
        if ("object" == typeof units) {
            units = normalizeObjectUnits(units);
            for (var prioritized = getPrioritizedUnits(units), i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit]);
        } else if (units = normalizeUnits(units), isFunction(this[units])) return this[units](value);
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        "string" == typeof callback && (func = function() {
            return this[callback]();
        }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        }), ordinal && (formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        });
    }
    function removeFormattingTokens(input) {
        return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; length > i; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
        return function(mom) {
            var i, output = "";
            for (i = 0; length > i; i++) output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output;
        };
    }
    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), 
        formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        var i = 5;
        for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
        localFormattingTokens.lastIndex = 0, i -= 1;
        return format;
    }
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token));
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function addParseToken(token, callback) {
        var i, func = callback;
        for ("string" == typeof token && (token = [ token ]), isNumber(callback) && (func = function(input, array) {
            array[callback] = toInt(input);
        }), i = 0; i < token.length; i++) tokens[token[i]] = func;
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {}, callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token);
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function localeMonths(m, format) {
        return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : this._months;
    }
    function localeMonthsShort(m, format) {
        return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : this._monthsShort;
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], 
        this._shortMonthsParse = [], i = 0; 12 > i; ++i) mom = createUTC([ 2e3, i ]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), 
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        return strict ? "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        -1 !== ii ? ii : null) : (ii = indexOf$1.call(this._longMonthsParse, llc), -1 !== ii ? ii : null) : "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._longMonthsParse, llc), -1 !== ii ? ii : null)) : (ii = indexOf$1.call(this._longMonthsParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortMonthsParse, llc), -1 !== ii ? ii : null));
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
        i = 0; 12 > i; i++) {
            if (mom = createUTC([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), 
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), 
            strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), 
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
            if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
            if (!strict && this._monthsParse[i].test(monthName)) return i;
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) return mom;
        if ("string" == typeof value) if (/^\d+$/.test(value)) value = toInt(value); else if (value = mom.localeData().monthsParse(value), 
        !isNumber(value)) return mom;
        return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), 
        mom;
    }
    function getSetMonth(value) {
        return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month");
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), 
        this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }
    function monthsRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), 
        this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; 12 > i; i++) mom = createUTC([ 2e3, i ]), shortPieces.push(this.monthsShort(mom, "")), 
        longPieces.push(this.months(mom, "")), mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
        for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), 
        i = 0; 12 > i; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
        for (i = 0; 24 > i; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, 
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        return 100 > y && y >= 0 && isFinite(date.getFullYear()) && date.setFullYear(y), 
        date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return 100 > y && y >= 0 && isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y), 
        date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var resYear, resDayOfYear, localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset;
        return 0 >= dayOfYear ? (resYear = year - 1, resDayOfYear = daysInYear(resYear) + dayOfYear) : dayOfYear > daysInYear(year) ? (resYear = year + 1, 
        resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), 
        {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
        return 1 > week ? (resYear = mom.year() - 1, resWeek = week + weeksInYear(resYear, dow, doy)) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), 
        resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function parseWeekday(input, locale) {
        return "string" != typeof input ? input : isNaN(input) ? (input = locale.weekdaysParse(input), 
        "number" == typeof input ? input : null) : parseInt(input, 10);
    }
    function parseIsoWeekday(input, locale) {
        return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input;
    }
    function localeWeekdays(m, format) {
        return m ? isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"][m.day()] : this._weekdays;
    }
    function localeWeekdaysShort(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], 
        this._minWeekdaysParse = [], i = 0; 7 > i; ++i) mom = createUTC([ 2e3, 1 ]).day(i), 
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), 
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        return strict ? "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : null) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        -1 !== ii ? ii : null) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), -1 !== ii ? ii : null) : "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        -1 !== ii ? ii : null))) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        -1 !== ii ? ii : null))) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), -1 !== ii ? ii : null)));
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], 
        this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; 7 > i; i++) {
            if (mom = createUTC([ 2e3, 1 ]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i"), 
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i"), 
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i")), 
            this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), 
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
            if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day;
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == input ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        }
        return this.day() || 7;
    }
    function weekdaysRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), 
        this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }
    function weekdaysShortRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), 
        this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }
    function weekdaysMinRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), 
        this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; 7 > i; i++) mom = createUTC([ 2e3, 1 ]).day(i), minp = this.weekdaysMin(mom, ""), 
        shortp = this.weekdaysShort(mom, ""), longp = this.weekdays(mom, ""), minPieces.push(minp), 
        shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), mixedPieces.push(shortp), 
        mixedPieces.push(longp);
        for (minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), 
        mixedPieces.sort(cmpLenRev), i = 0; 7 > i; i++) shortPieces[i] = regexEscape(shortPieces[i]), 
        longPieces[i] = regexEscape(longPieces[i]), mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, 
        this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), 
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), 
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    function localeIsPM(input) {
        return "p" === (input + "").toLowerCase().charAt(0);
    }
    function localeMeridiem(hours, minutes, isLower) {
        return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        for (var j, next, locale, split, i = 0; i < names.length; ) {
            for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), 
            next = next ? next.split("-") : null; j > 0; ) {
                if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && "undefined" != typeof module && module && module.exports) try {
            oldLocale = globalLocale._abbr, require("./locale/" + name), getSetGlobalLocale(oldLocale);
        } catch (e) {}
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        return key && (data = isUndefined(values) ? getLocale(key) : defineLocale(key, values), 
        data && (globalLocale = data)), globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (null !== config) {
            var parentConfig = baseConfig;
            if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), 
            parentConfig = locales[name]._config; else if (null != config.parentLocale) {
                if (null == locales[config.parentLocale]) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), 
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                }), null;
                parentConfig = locales[config.parentLocale]._config;
            }
            return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
            }), getSetGlobalLocale(name), locales[name];
        }
        return delete locales[name], null;
    }
    function updateLocale(name, config) {
        if (null != config) {
            var locale, parentConfig = baseConfig;
            null != locales[name] && (parentConfig = locales[name]._config), config = mergeConfigs(parentConfig, config), 
            locale = new Locale(config), locale.parentLocale = locales[name], locales[name] = locale, 
            getSetGlobalLocale(name);
        } else null != locales[name] && (null != locales[name].parentLocale ? locales[name] = locales[name].parentLocale : null != locales[name] && delete locales[name]);
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
        if (!isArray(key)) {
            if (locale = loadLocale(key)) return locale;
            key = [ key ];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys$1(locales);
    }
    function checkOverflow(m) {
        var overflow, a = m._a;
        return a && -2 === getParsingFlags(m).overflow && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, 
        getParsingFlags(m)._overflowDayOfYear && (YEAR > overflow || overflow > DATE) && (overflow = DATE), 
        getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), 
        getParsingFlags(m).overflow = overflow), m;
    }
    function configFromISO(config) {
        var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
        if (match) {
            for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; l > i; i++) if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0], allowTime = isoDates[i][2] !== !1;
                break;
            }
            if (null == dateFormat) return void (config._isValid = !1);
            if (match[3]) {
                for (i = 0, l = isoTimes.length; l > i; i++) if (isoTimes[i][1].exec(match[3])) {
                    timeFormat = (match[2] || " ") + isoTimes[i][0];
                    break;
                }
                if (null == timeFormat) return void (config._isValid = !1);
            }
            if (!allowTime && null != timeFormat) return void (config._isValid = !1);
            if (match[4]) {
                if (!tzRegex.exec(match[4])) return void (config._isValid = !1);
                tzFormat = "Z";
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config);
        } else config._isValid = !1;
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        return null !== matched ? void (config._d = new Date(+matched[1])) : (configFromISO(config), 
        void (config._isValid === !1 && (delete config._isValid, hooks.createFromInputFallback(config))));
    }
    function defaults(a, b, c) {
        return null != a ? a : null != b ? b : c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        return config._useUTC ? [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ] : [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
        var i, date, currentDate, yearToUse, input = [];
        if (!config._d) {
            for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), 
            config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), 
            config._dayOfYear > daysInYear(yearToUse) && (getParsingFlags(config)._overflowDayOfYear = !0), 
            date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
            config._a[DATE] = date.getUTCDate()), i = 0; 3 > i && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
            for (;7 > i; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
            config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), 
            null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
            config._nextDay && (config._a[HOUR] = 24);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        if (w = config._w, null != w.GG || null != w.W || null != w.E) dow = 1, doy = 4, 
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), 
        week = defaults(w.W, 1), weekday = defaults(w.E, 1), (1 > weekday || weekday > 7) && (weekdayOverflow = !0); else {
            dow = config._locale._week.dow, doy = config._locale._week.doy;
            var curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), 
            null != w.d ? (weekday = w.d, (0 > weekday || weekday > 6) && (weekdayOverflow = !0)) : null != w.e ? (weekday = w.e + dow, 
            (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow;
        }
        1 > week || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), 
        config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear);
    }
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) return void configFromISO(config);
        config._a = [], getParsingFlags(config).empty = !0;
        var i, parsedInput, tokens, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], 
        i = 0; i < tokens.length; i++) token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], 
        parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && getParsingFlags(config).unusedInput.push(skipped), 
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
        formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), 
        addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), 
        config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === !0 && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), 
        getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, 
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), 
        configFromArray(config), checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), 
        isPm && 12 > hour && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour;
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, void (config._d = new Date(NaN));
        for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), 
        null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], 
        configFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += getParsingFlags(tempConfig).charsLeftOver, 
        currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, 
        (null == scoreToBeat || scoreToBeat > currentScore) && (scoreToBeat = currentScore, 
        bestMoment = tempConfig));
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (!config._d) {
            var i = normalizeObjectUnits(config._i);
            config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
                return obj && parseInt(obj, 10);
            }), configFromArray(config);
        }
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
            nullInput: !0
        }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
        isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), 
        isValid(config) || (config._d = null), config));
    }
    function configFromInput(config) {
        var input = config._i;
        void 0 === input ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
        }), configFromArray(config)) : "object" == typeof input ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config);
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        return (locale === !0 || locale === !1) && (strict = locale, locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), 
        c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, 
        c._f = format, c._strict = strict, createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !1);
    }
    function pickBy(fn, moments) {
        var res, i;
        if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
        for (res = moments[0], i = 1; i < moments.length; ++i) (!moments[i].isValid() || moments[i][fn](res)) && (res = moments[i]);
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, 
        this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
        this._data = {}, this._locale = getLocale(), this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        return 0 > number ? -1 * Math.round(-1 * number) : Math.round(number);
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(), sign = "+";
            return 0 > offset && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher);
        if (null === matches) return null;
        var chunk = matches[matches.length - 1] || [], parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ], minutes = +(60 * parts[1]) + toInt(parts[2]);
        return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), 
        res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local();
    }
    function getDateOffset(m) {
        return 15 * -Math.round(m._d.getTimezoneOffset() / 15);
    }
    function getSetOffset(input, keepLocalTime) {
        var localAdjust, offset = this._offset || 0;
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            if ("string" == typeof input) {
                if (input = offsetFromString(matchShortOffset, input), null === input) return this;
            } else Math.abs(input) < 16 && (input = 60 * input);
            return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, 
            this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
            hooks.updateOffset(this, !0), this._changeInProgress = null)), this;
        }
        return this._isUTC ? offset : getDateOffset(this);
    }
    function getSetZone(input, keepLocalTime) {
        return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
        this) : -this.utcOffset();
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), 
        this;
    }
    function setOffsetToParsedOffset() {
        if (null != this._tzm) this.utcOffset(this._tzm); else if ("string" == typeof this._i) {
            var tZone = offsetFromString(matchOffset, this._i);
            null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0);
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        return this.isValid() ? (input = input ? createLocal(input).utcOffset() : 0, (this.utcOffset() - input) % 60 === 0) : !1;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
        var c = {};
        if (copyConfig(c, this), c = prepareConfig(c), c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else this._isDSTShifted = !1;
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : !1;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : !1;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && 0 === this._offset : !1;
    }
    function createDuration(input, key) {
        var sign, ret, diffRes, duration = input, match = null;
        return isDuration(input) ? duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        } : isNumber(input) ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
        duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
        }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
        }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), 
        duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), 
        ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
        ret;
    }
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
        base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
        res;
    }
    function momentsDifference(base, other) {
        var res;
        return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), 
        base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), 
        res.milliseconds = -res.milliseconds, res.months = -res.months), res) : {
            milliseconds: 0,
            months: 0
        };
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), 
            tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, 
            dur = createDuration(val, period), addSubtract(this, dur, direction), this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        mom.isValid() && (updateOffset = null == updateOffset ? !0 : updateOffset, milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), 
        days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), months && setMonth(mom, get(mom, "Month") + months * isAdding), 
        updateOffset && hooks.updateOffset(mom, days || months));
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", !0);
        return -6 > diff ? "sameElse" : -1 > diff ? "lastWeek" : 0 > diff ? "lastDay" : 1 > diff ? "sameDay" : 2 > diff ? "nextDay" : 7 > diff ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return this.isValid() && localInput.isValid() ? (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf()) : !1;
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return this.isValid() && localInput.isValid() ? (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf()) : !1;
    }
    function isBetween(from, to, units, inclusivity) {
        return inclusivity = inclusivity || "()", ("(" === inclusivity[0] ? this.isAfter(from, units) : !this.isBefore(from, units)) && (")" === inclusivity[1] ? this.isBefore(to, units) : !this.isAfter(to, units));
    }
    function isSame(input, units) {
        var inputMs, localInput = isMoment(input) ? input : createLocal(input);
        return this.isValid() && localInput.isValid() ? (units = normalizeUnits(units || "millisecond"), 
        "millisecond" === units ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), 
        this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf())) : !1;
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, delta, output;
        return this.isValid() ? (that = cloneWithOffset(input, this), that.isValid() ? (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), 
        units = normalizeUnits(units), "year" === units || "month" === units || "quarter" === units ? (output = monthDiff(this, that), 
        "quarter" === units ? output /= 3 : "year" === units && (output /= 12)) : (delta = this - that, 
        output = "second" === units ? delta / 1e3 : "minute" === units ? delta / 6e4 : "hour" === units ? delta / 36e5 : "day" === units ? (delta - zoneDelta) / 864e5 : "week" === units ? (delta - zoneDelta) / 6048e5 : delta), 
        asFloat ? output : absFloor(output)) : NaN) : NaN;
    }
    function monthDiff(a, b) {
        var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
        return 0 > b - anchor ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), 
        adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), 
        adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust) || 0;
    }
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString() {
        var m = this.clone().utc();
        return 0 < m.year() && m.year() <= 9999 ? isFunction(Date.prototype.toISOString) ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
    }
    function inspect() {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var func = "moment", zone = "";
        this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", 
        zone = "Z");
        var prefix = "[" + func + '("]', year = 0 < this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", datetime = "-MM-DD[T]HH:mm:ss.SSS", suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        return void 0 === key ? this._locale._abbr : (newLocaleData = getLocale(key), null != newLocaleData && (this._locale = newLocaleData), 
        this);
    }
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        switch (units = normalizeUnits(units)) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
          case "date":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        return "week" === units && this.weekday(0), "isoWeek" === units && this.isoWeekday(1), 
        "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this;
    }
    function endOf(units) {
        return units = normalizeUnits(units), void 0 === units || "millisecond" === units ? this : ("date" === units && (units = "day"), 
        this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms"));
    }
    function valueOf() {
        return this._d.valueOf() - 6e4 * (this._offset || 0);
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$1() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        return null == input ? weekOfYear(this, dow, doy).year : (weeksTarget = weeksInYear(input, dow, doy), 
        week > weeksTarget && (week = weeksTarget), setWeekAll.call(this, input, week, weekday, dow, doy));
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), 
        this;
    }
    function getSetQuarter(input) {
        return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(1e3 * ("0." + input));
    }
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    function createUnix(input) {
        return createLocal(1e3 * input);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    function get$1(format, index, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format) && (index = format, format = void 0), format = format || "", 
        null != index) return get$1(format, index, field, "month");
        var i, out = [];
        for (i = 0; 12 > i; i++) out[i] = get$1(format, i, field, "month");
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), 
        format = format || "") : (format = localeSorted, index = format, localeSorted = !1, 
        isNumber(format) && (index = format, format = void 0), format = format || "");
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (null != index) return get$1(format, (index + shift) % 7, field, "day");
        var i, out = [];
        for (i = 0; 7 > i; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    function abs() {
        var data = this._data;
        return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), 
        this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), 
        data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), 
        data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, 
        duration._months += direction * other._months, duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        return 0 > number ? Math.floor(number) : Math.ceil(number);
    }
    function bubble() {
        var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data;
        return milliseconds >= 0 && days >= 0 && months >= 0 || 0 >= milliseconds && 0 >= days && 0 >= months || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), 
        days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), 
        data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, 
        hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), 
        monthsFromDays = absFloor(daysToMonths(days)), months += monthsFromDays, days -= absCeil(monthsToDays(monthsFromDays)), 
        years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, 
        data.years = years, this;
    }
    function daysToMonths(days) {
        return 4800 * days / 146097;
    }
    function monthsToDays(months) {
        return 146097 * months / 4800;
    }
    function as(units) {
        var days, months, milliseconds = this._milliseconds;
        if (units = normalizeUnits(units), "month" === units || "year" === units) return days = this._days + milliseconds / 864e5, 
        months = this._months + daysToMonths(days), "month" === units ? months : months / 12;
        switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
          case "week":
            return days / 7 + milliseconds / 6048e5;

          case "day":
            return days + milliseconds / 864e5;

          case "hour":
            return 24 * days + milliseconds / 36e5;

          case "minute":
            return 1440 * days + milliseconds / 6e4;

          case "second":
            return 86400 * days + milliseconds / 1e3;

          case "millisecond":
            return Math.floor(864e5 * days) + milliseconds;

          default:
            throw new Error("Unknown unit " + units);
        }
    }
    function valueOf$1() {
        return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12);
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    function get$2(units) {
        return units = normalizeUnits(units), this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    function weeks() {
        return absFloor(this.days() / 7);
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), a = seconds < thresholds.s && [ "s", seconds ] || 1 >= minutes && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || 1 >= hours && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || 1 >= days && [ "d" ] || days < thresholds.d && [ "dd", days ] || 1 >= months && [ "M" ] || months < thresholds.M && [ "MM", months ] || 1 >= years && [ "y" ] || [ "yy", years ];
        return a[2] = withoutSuffix, a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        return void 0 === roundingFunction ? round : "function" == typeof roundingFunction ? (round = roundingFunction, 
        !0) : !1;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        return void 0 === thresholds[threshold] ? !1 : void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, 
        !0);
    }
    function humanize(withSuffix) {
        var locale = this.localeData(), output = relativeTime$1(this, !withSuffix, locale);
        return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output);
    }
    function toISOString$1() {
        var minutes, hours, years, seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months);
        minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds %= 60, 
        minutes %= 60, years = absFloor(months / 12), months %= 12;
        var Y = years, M = months, D = days, h = hours, m = minutes, s = seconds, total = this.asSeconds();
        return total ? (0 > total ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "") : "P0D";
    }
    var hookCallback, some;
    some = Array.prototype.some ? Array.prototype.some : function(fun) {
        for (var t = Object(this), len = t.length >>> 0, i = 0; len > i; i++) if (i in t && fun.call(this, t[i], i, t)) return !0;
        return !1;
    };
    var some$1 = some, momentProperties = hooks.momentProperties = [], updateInProgress = !1, deprecations = {};
    hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null;
    var keys;
    keys = Object.keys ? Object.keys : function(obj) {
        var i, res = [];
        for (i in obj) hasOwnProp(obj, i) && res.push(i);
        return res;
    };
    var indexOf, keys$1 = keys, defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    }, defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, defaultInvalidDate = "Invalid date", defaultOrdinal = "%d", defaultOrdinalParse = /\d{1,2}/, defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    }, aliases = {}, priorities = {}, formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {}, match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, regexes = {}, tokens = {}, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
        var i;
        for (i = 0; i < this.length; ++i) if (this[i] === o) return i;
        return -1;
    };
    var indexOf$1 = indexOf;
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    }), addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    }), addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), 
    addRegexToken("MM", match1to2, match2), addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    }), addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    }), addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    }), addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input;
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return 9999 >= y ? "" + y : "+" + y;
    }), addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    }), addFormatToken(0, [ "YYYY", 4 ], 0, "year"), addFormatToken(0, [ "YYYYY", 5 ], 0, "year"), 
    addFormatToken(0, [ "YYYYYY", 6, !0 ], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), 
    addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), 
    addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), 
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR), addParseToken("YYYY", function(input, array) {
        array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
    }), addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    }), addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    }), hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", !0);
    addFormatToken("w", [ "ww", 2 ], "wo", "week"), addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek"), 
    addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), 
    addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), 
    addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    }), addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    }), addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), 
    addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), 
    addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), 
    addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), 
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    }), addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    }), addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    }), addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input;
    }), addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", [ "HH", 2 ], 0, "hour"), addFormatToken("h", [ "hh", 2 ], 0, hFormat), 
    addFormatToken("k", [ "kk", 2 ], 0, kFormat), addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    }), addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    }), addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), 
    addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), 
    addRegexToken("h", match1to2), addRegexToken("HH", match1to2, match2), addRegexToken("hh", match1to2, match2), 
    addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), 
    addRegexToken("Hmmss", match5to6), addParseToken([ "H", "HH" ], HOUR), addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input), config._meridiem = input;
    }), addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), 
        getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0;
    }), addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos));
    }), addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2));
    });
    var globalLocale, defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", !0), baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    }, locales = {}, localeFamilies = {}, extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, !1 ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, !1 ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, !1 ], [ "YYYYDDD", /\d{7}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }), hooks.ISO_8601 = function() {};
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? this > other ? this : other : createInvalid();
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid();
    }), now = function() {
        return Date.now ? Date.now() : +new Date();
    };
    offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), 
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {};
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype;
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        return void 0 === key ? this.localeData() : this.locale(key);
    });
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    }), addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), 
    addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), 
    addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), 
    addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), 
    addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), 
    addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), 
    addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), 
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    }), addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), 
    addRegexToken("Q", match1), addParseToken("Q", function(input, array) {
        array[MONTH] = 3 * (toInt(input) - 1);
    }), addFormatToken("D", [ "DD", 2 ], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), 
    addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    }), addParseToken([ "D", "DD" ], DATE), addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", !0);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), 
    addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), 
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    }), addFormatToken("m", [ "mm", 2 ], 0, "minute"), addUnitAlias("minute", "m"), 
    addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), 
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", !1);
    addFormatToken("s", [ "ss", 2 ], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), 
    addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", !1);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    }), addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    }), addFormatToken(0, [ "SSS", 3 ], 0, "millisecond"), addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return 10 * this.millisecond();
    }), addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return 100 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return 1e3 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return 1e4 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return 1e5 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return 1e6 * this.millisecond();
    }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), 
    addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
    for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
    var getSetMillisecond = makeGetSet("Milliseconds", !1);
    addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
    var proto = Moment.prototype;
    proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, 
    proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, 
    proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, 
    proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, 
    proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, 
    proto.isValid = isValid$1, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, 
    proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, 
    proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, 
    proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, 
    proto.inspect = inspect, proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, 
    proto.valueOf = valueOf, proto.creationData = creationData, proto.year = getSetYear, 
    proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, 
    proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, 
    proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, 
    proto.weeksInYear = getWeeksInYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.date = getSetDayOfMonth, 
    proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, 
    proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, 
    proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, 
    proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, 
    proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, 
    proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, 
    proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, 
    proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), 
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), 
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), 
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), 
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, 
    proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, 
    proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, 
    proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, 
    proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, 
    proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, 
    proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, 
    proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, 
    proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, 
    proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
            return number + output;
        }
    }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), 
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs, asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asYears = makeAs("y"), milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years"), round = Math.round, thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, abs$1 = Math.abs, proto$2 = Duration.prototype;
    return proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, proto$2.as = as, 
    proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, 
    proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, 
    proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, 
    proto$2.get = get$2, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, 
    proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = weeks, 
    proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, proto$2.toISOString = toISOString$1, 
    proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, 
    proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), 
    proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), 
    addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", function(input, array, config) {
        config._d = new Date(1e3 * parseFloat(input, 10));
    }), addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    }), hooks.version = "2.17.1", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, 
    hooks.max = max, hooks.now = now, hooks.utc = createUTC, hooks.unix = createUnix, 
    hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, 
    hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, 
    hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, 
    hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, 
    hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, 
    hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, 
    hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, 
    hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks;
}), function(window, angular, undefined) {
    "use strict";
    function toArray(object) {
        return isArray(object) ? object : Object.keys(object).map(function(key) {
            return object[key];
        });
    }
    function isNull(value) {
        return null === value;
    }
    function objectContains(partial, object) {
        var keys = Object.keys(partial);
        return -1 == keys.map(function(el) {
            return object[el] !== undefined && object[el] == partial[el];
        }).indexOf(!1);
    }
    function hasApproxPattern(word, pattern) {
        function indexOf(word, p, c) {
            for (var j = 0; p + j <= word.length; ) {
                if (word.charAt(p + j) == c) return j;
                j++;
            }
            return -1;
        }
        for (var p = 0, i = 0; i <= pattern.length; i++) {
            var index = indexOf(word, p, pattern.charAt(i));
            if (-1 == index) return !1;
            p += index + 1;
        }
        return !0;
    }
    function getFirstMatches(array, n, expression) {
        var count = 0;
        return array.filter(function(elm) {
            var rest = isDefined(expression) ? n > count && expression(elm) : n > count;
            return count = rest ? count + 1 : count, rest;
        });
    }
    function convertToDecimal(num, decimal) {
        return Math.round(num * Math.pow(10, decimal)) / Math.pow(10, decimal);
    }
    function deepKeys(obj, stack, parent) {
        stack = stack || [];
        var keys = Object.keys(obj);
        return keys.forEach(function(el) {
            if (isObject(obj[el]) && !isArray(obj[el])) {
                var p = parent ? parent + "." + el : parent;
                deepKeys(obj[el], stack, p || el);
            } else {
                var key = parent ? parent + "." + el : el;
                stack.push(key);
            }
        }), stack;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isGreaterThanFilter() {
        return function(input, check) {
            return input > check;
        };
    }
    function isGreaterThanOrEqualToFilter() {
        return function(input, check) {
            return input >= check;
        };
    }
    function isLessThanFilter() {
        return function(input, check) {
            return check > input;
        };
    }
    function isLessThanOrEqualToFilter() {
        return function(input, check) {
            return check >= input;
        };
    }
    function isEqualToFilter() {
        return function(input, check) {
            return input == check;
        };
    }
    function isNotEqualToFilter() {
        return function(input, check) {
            return input != check;
        };
    }
    function isIdenticalToFilter() {
        return function(input, check) {
            return input === check;
        };
    }
    function isNotIdenticalToFilter() {
        return function(input, check) {
            return input !== check;
        };
    }
    function containsFilter($parse) {
        return function(collection, expression) {
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(expression) ? !1 : collection.some(function(elm) {
                return isString(expression) && isObject(elm) || isFunction(expression) ? $parse(expression)(elm) : elm === expression;
            });
        };
    }
    function flatten(array, i) {
        return i = i || 0, i >= array.length ? array : isArray(array[i]) ? flatten(array.slice(0, i).concat(array[i], array.slice(i + 1)), i) : flatten(array, i + 1);
    }
    function uniqFilter($parse) {
        return function(collection, property) {
            function some(array, member) {
                return isUndefined(member) ? !1 : array.some(function(el) {
                    return equals(el, member);
                });
            }
            if (collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection)) return collection;
            var uniqueItems = [], get = $parse(property);
            return isUndefined(property) ? collection.filter(function(elm, pos, self) {
                return self.indexOf(elm) === pos;
            }) : collection.filter(function(elm) {
                var prop = get(elm);
                return some(uniqueItems, prop) ? !1 : (uniqueItems.push(prop), !0);
            });
        };
    }
    function strRepeat(str, n, sep) {
        return n ? str + sep + strRepeat(str, --n, sep) : str;
    }
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isFunction = angular.isFunction, isString = angular.isString, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, equals = angular.equals;
    String.prototype.contains || (String.prototype.contains = function() {
        return -1 !== String.prototype.indexOf.apply(this, arguments);
    }), angular.module("a8m.angular", []).filter("isUndefined", function() {
        return function(input) {
            return angular.isUndefined(input);
        };
    }).filter("isDefined", function() {
        return function(input) {
            return angular.isDefined(input);
        };
    }).filter("isFunction", function() {
        return function(input) {
            return angular.isFunction(input);
        };
    }).filter("isString", function() {
        return function(input) {
            return angular.isString(input);
        };
    }).filter("isNumber", function() {
        return function(input) {
            return angular.isNumber(input);
        };
    }).filter("isArray", function() {
        return function(input) {
            return angular.isArray(input);
        };
    }).filter("isObject", function() {
        return function(input) {
            return angular.isObject(input);
        };
    }).filter("isEqual", function() {
        return function(o1, o2) {
            return angular.equals(o1, o2);
        };
    }), angular.module("a8m.conditions", []).filter({
        isGreaterThan: isGreaterThanFilter,
        ">": isGreaterThanFilter,
        isGreaterThanOrEqualTo: isGreaterThanOrEqualToFilter,
        ">=": isGreaterThanOrEqualToFilter,
        isLessThan: isLessThanFilter,
        "<": isLessThanFilter,
        isLessThanOrEqualTo: isLessThanOrEqualToFilter,
        "<=": isLessThanOrEqualToFilter,
        isEqualTo: isEqualToFilter,
        "==": isEqualToFilter,
        isNotEqualTo: isNotEqualToFilter,
        "!=": isNotEqualToFilter,
        isIdenticalTo: isIdenticalToFilter,
        "===": isIdenticalToFilter,
        isNotIdenticalTo: isNotIdenticalToFilter,
        "!==": isNotIdenticalToFilter
    }), angular.module("a8m.is-null", []).filter("isNull", function() {
        return function(input) {
            return isNull(input);
        };
    }), angular.module("a8m.after-where", []).filter("afterWhere", function() {
        return function(collection, object) {
            if (collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(object)) return collection;
            var index = collection.map(function(elm) {
                return objectContains(object, elm);
            }).indexOf(!0);
            return collection.slice(-1 === index ? 0 : index);
        };
    }), angular.module("a8m.after", []).filter("after", function() {
        return function(collection, count) {
            return collection = isObject(collection) ? toArray(collection) : collection, isArray(collection) ? collection.slice(count) : collection;
        };
    }), angular.module("a8m.before-where", []).filter("beforeWhere", function() {
        return function(collection, object) {
            if (collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(object)) return collection;
            var index = collection.map(function(elm) {
                return objectContains(object, elm);
            }).indexOf(!0);
            return collection.slice(0, -1 === index ? collection.length : ++index);
        };
    }), angular.module("a8m.before", []).filter("before", function() {
        return function(collection, count) {
            return collection = isObject(collection) ? toArray(collection) : collection, isArray(collection) ? collection.slice(0, count ? --count : count) : collection;
        };
    }), angular.module("a8m.chunk-by", [ "a8m.filter-watcher" ]).filter("chunkBy", [ "filterWatcher", function(filterWatcher) {
        return function(array, n, fillVal) {
            function fill(n, val) {
                for (var ret = []; n--; ) ret[n] = val;
                return ret;
            }
            function _chunkBy(array, n, fillVal) {
                return isArray(array) ? array.map(function(el, i, self) {
                    return i *= n, el = self.slice(i, i + n), !isUndefined(fillVal) && el.length < n ? el.concat(fill(n - el.length, fillVal)) : el;
                }).slice(0, Math.ceil(array.length / n)) : array;
            }
            return filterWatcher.isMemoized("chunkBy", arguments) || filterWatcher.memoize("chunkBy", arguments, this, _chunkBy(array, n, fillVal));
        };
    } ]), angular.module("a8m.concat", []).filter("concat", [ function() {
        return function(collection, joined) {
            if (isUndefined(joined)) return collection;
            if (isArray(collection)) return isObject(joined) ? collection.concat(toArray(joined)) : collection.concat(joined);
            if (isObject(collection)) {
                var array = toArray(collection);
                return isObject(joined) ? array.concat(toArray(joined)) : array.concat(joined);
            }
            return collection;
        };
    } ]), angular.module("a8m.contains", []).filter({
        contains: [ "$parse", containsFilter ],
        some: [ "$parse", containsFilter ]
    }), angular.module("a8m.count-by", []).filter("countBy", [ "$parse", function($parse) {
        return function(collection, property) {
            var prop, result = {}, get = $parse(property);
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(property) ? collection : (collection.forEach(function(elm) {
                prop = get(elm), result[prop] || (result[prop] = 0), result[prop]++;
            }), result);
        };
    } ]), angular.module("a8m.defaults", []).filter("defaults", [ "$parse", function($parse) {
        return function(collection, defaults) {
            if (collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || !isObject(defaults)) return collection;
            var keys = deepKeys(defaults);
            return collection.forEach(function(elm) {
                keys.forEach(function(key) {
                    var getter = $parse(key), setter = getter.assign;
                    isUndefined(getter(elm)) && setter(elm, getter(defaults));
                });
            }), collection;
        };
    } ]), angular.module("a8m.every", []).filter("every", [ "$parse", function($parse) {
        return function(collection, expression) {
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(expression) ? !0 : collection.every(function(elm) {
                return isObject(elm) || isFunction(expression) ? $parse(expression)(elm) : elm === expression;
            });
        };
    } ]), angular.module("a8m.filter-by", []).filter("filterBy", [ "$parse", function($parse) {
        return function(collection, properties, search, strict) {
            var comparator;
            return search = isString(search) || isNumber(search) ? String(search).toLowerCase() : undefined, 
            collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(search) ? collection : collection.filter(function(elm) {
                return properties.some(function(prop) {
                    if (~prop.indexOf("+")) {
                        var propList = prop.replace(/\s+/g, "").split("+");
                        comparator = propList.map(function(prop) {
                            return $parse(prop)(elm);
                        }).join(" ");
                    } else comparator = $parse(prop)(elm);
                    return isString(comparator) || isNumber(comparator) ? (comparator = String(comparator).toLowerCase(), 
                    strict ? comparator === search : comparator.contains(search)) : !1;
                });
            });
        };
    } ]), angular.module("a8m.first", []).filter("first", [ "$parse", function($parse) {
        return function(collection) {
            var n, getter, args;
            return collection = isObject(collection) ? toArray(collection) : collection, isArray(collection) ? (args = Array.prototype.slice.call(arguments, 1), 
            n = isNumber(args[0]) ? args[0] : 1, getter = isNumber(args[0]) ? isNumber(args[1]) ? undefined : args[1] : args[0], 
            args.length ? getFirstMatches(collection, n, getter ? $parse(getter) : getter) : collection[0]) : collection;
        };
    } ]), angular.module("a8m.flatten", []).filter("flatten", function() {
        return function(collection, shallow) {
            return shallow = shallow || !1, collection = isObject(collection) ? toArray(collection) : collection, 
            isArray(collection) ? shallow ? [].concat.apply([], collection) : flatten(collection, 0) : collection;
        };
    }), angular.module("a8m.fuzzy-by", []).filter("fuzzyBy", [ "$parse", function($parse) {
        return function(collection, property, search, csensitive) {
            var prop, getter, sensitive = csensitive || !1;
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(property) || isUndefined(search) ? collection : (getter = $parse(property), 
            collection.filter(function(elm) {
                return prop = getter(elm), isString(prop) ? (prop = sensitive ? prop : prop.toLowerCase(), 
                search = sensitive ? search : search.toLowerCase(), hasApproxPattern(prop, search) !== !1) : !1;
            }));
        };
    } ]), angular.module("a8m.fuzzy", []).filter("fuzzy", function() {
        return function(collection, search, csensitive) {
            function _hasApproximateKey(object, search) {
                var prop, flag, properties = Object.keys(object);
                return 0 < properties.filter(function(elm) {
                    return prop = object[elm], flag ? !0 : isString(prop) ? (prop = sensitive ? prop : prop.toLowerCase(), 
                    flag = hasApproxPattern(prop, search) !== !1) : !1;
                }).length;
            }
            var sensitive = csensitive || !1;
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(search) ? collection : (search = sensitive ? search : search.toLowerCase(), 
            collection.filter(function(elm) {
                return isString(elm) ? (elm = sensitive ? elm : elm.toLowerCase(), hasApproxPattern(elm, search) !== !1) : isObject(elm) ? _hasApproximateKey(elm, search) : !1;
            }));
        };
    }), angular.module("a8m.group-by", [ "a8m.filter-watcher" ]).filter("groupBy", [ "$parse", "filterWatcher", function($parse, filterWatcher) {
        return function(collection, property) {
            function _groupBy(collection, getter) {
                var prop, result = {};
                return forEach(collection, function(elm) {
                    prop = getter(elm), result[prop] || (result[prop] = []), result[prop].push(elm);
                }), result;
            }
            return !isObject(collection) || isUndefined(property) ? collection : filterWatcher.isMemoized("groupBy", arguments) || filterWatcher.memoize("groupBy", arguments, this, _groupBy(collection, $parse(property)));
        };
    } ]), angular.module("a8m.is-empty", []).filter("isEmpty", function() {
        return function(collection) {
            return isObject(collection) ? !toArray(collection).length : !collection.length;
        };
    }), angular.module("a8m.join", []).filter("join", function() {
        return function(input, delimiter) {
            return isUndefined(input) || !isArray(input) ? input : (isUndefined(delimiter) && (delimiter = " "), 
            input.join(delimiter));
        };
    }), angular.module("a8m.last", []).filter("last", [ "$parse", function($parse) {
        return function(collection) {
            var n, getter, args, reversed = copy(collection);
            return reversed = isObject(reversed) ? toArray(reversed) : reversed, isArray(reversed) ? (args = Array.prototype.slice.call(arguments, 1), 
            n = isNumber(args[0]) ? args[0] : 1, getter = isNumber(args[0]) ? isNumber(args[1]) ? undefined : args[1] : args[0], 
            args.length ? getFirstMatches(reversed.reverse(), n, getter ? $parse(getter) : getter).reverse() : reversed[reversed.length - 1]) : reversed;
        };
    } ]), angular.module("a8m.map", []).filter("map", [ "$parse", function($parse) {
        return function(collection, expression) {
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(expression) ? collection : collection.map(function(elm) {
                return $parse(expression)(elm);
            });
        };
    } ]), angular.module("a8m.omit", []).filter("omit", [ "$parse", function($parse) {
        return function(collection, expression) {
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(expression) ? collection : collection.filter(function(elm) {
                return !$parse(expression)(elm);
            });
        };
    } ]), angular.module("a8m.pick", []).filter("pick", [ "$parse", function($parse) {
        return function(collection, expression) {
            return collection = isObject(collection) ? toArray(collection) : collection, !isArray(collection) || isUndefined(expression) ? collection : collection.filter(function(elm) {
                return $parse(expression)(elm);
            });
        };
    } ]), angular.module("a8m.range", []).filter("range", function() {
        return function(input, total, start, increment, cb) {
            start = start || 0, increment = increment || 1;
            for (var i = 0; i < parseInt(total); i++) {
                var j = start + i * increment;
                input.push(isFunction(cb) ? cb(j) : j);
            }
            return input;
        };
    }), angular.module("a8m.remove-with", []).filter("removeWith", function() {
        return function(collection, object) {
            return isUndefined(object) ? collection : (collection = isObject(collection) ? toArray(collection) : collection, 
            collection.filter(function(elm) {
                return !objectContains(object, elm);
            }));
        };
    }), angular.module("a8m.remove", []).filter("remove", function() {
        return function(collection) {
            collection = isObject(collection) ? toArray(collection) : collection;
            var args = Array.prototype.slice.call(arguments, 1);
            return isArray(collection) ? collection.filter(function(member) {
                return !args.some(function(nest) {
                    return equals(nest, member);
                });
            }) : collection;
        };
    }), angular.module("a8m.reverse", []).filter("reverse", [ function() {
        return function(input) {
            return input = isObject(input) ? toArray(input) : input, isString(input) ? input.split("").reverse().join("") : isArray(input) ? input.slice().reverse() : input;
        };
    } ]), angular.module("a8m.search-field", []).filter("searchField", [ "$parse", function($parse) {
        return function(collection) {
            var get, field;
            collection = isObject(collection) ? toArray(collection) : collection;
            var args = Array.prototype.slice.call(arguments, 1);
            return isArray(collection) && args.length ? collection.map(function(member) {
                return field = args.map(function(field) {
                    return (get = $parse(field))(member);
                }).join(" "), extend(member, {
                    searchField: field
                });
            }) : collection;
        };
    } ]), angular.module("a8m.to-array", []).filter("toArray", function() {
        return function(collection, addKey) {
            return isObject(collection) ? addKey ? Object.keys(collection).map(function(key) {
                return extend(collection[key], {
                    $key: key
                });
            }) : toArray(collection) : collection;
        };
    }), angular.module("a8m.unique", []).filter({
        unique: [ "$parse", uniqFilter ],
        uniq: [ "$parse", uniqFilter ]
    }), angular.module("a8m.where", []).filter("where", function() {
        return function(collection, object) {
            return isUndefined(object) ? collection : (collection = isObject(collection) ? toArray(collection) : collection, 
            collection.filter(function(elm) {
                return objectContains(object, elm);
            }));
        };
    }), angular.module("a8m.xor", []).filter("xor", [ "$parse", function($parse) {
        return function(col1, col2, expression) {
            function some(el, col) {
                var getter = $parse(expression);
                return col.some(function(dElm) {
                    return expression ? equals(getter(dElm), getter(el)) : equals(dElm, el);
                });
            }
            return expression = expression || !1, col1 = isObject(col1) ? toArray(col1) : col1, 
            col2 = isObject(col2) ? toArray(col2) : col2, isArray(col1) && isArray(col2) ? col1.concat(col2).filter(function(elm) {
                return !(some(elm, col1) && some(elm, col2));
            }) : col1;
        };
    } ]), angular.module("a8m.math.abs", []).filter("abs", function() {
        return function(input) {
            return Math.abs(input);
        };
    }), angular.module("a8m.math.byteFmt", []).filter("byteFmt", function() {
        var compared = [ {
            str: "B",
            val: 1024
        } ];
        return [ "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" ].forEach(function(el, i) {
            compared.push({
                str: el,
                val: 1024 * compared[i].val
            });
        }), function(bytes, decimal) {
            if (isNumber(decimal) && isFinite(decimal) && decimal % 1 === 0 && decimal >= 0 && isNumber(bytes) && isFinite(bytes)) {
                for (var i = 0; i < compared.length - 1 && bytes >= compared[i].val; ) i++;
                return bytes /= i > 0 ? compared[i - 1].val : 1, convertToDecimal(bytes, decimal) + " " + compared[i].str;
            }
            return "NaN";
        };
    }), angular.module("a8m.math.degrees", []).filter("degrees", function() {
        return function(radians, decimal) {
            if (isNumber(decimal) && isFinite(decimal) && decimal % 1 === 0 && decimal >= 0 && isNumber(radians) && isFinite(radians)) {
                var degrees = 180 * radians / Math.PI;
                return Math.round(degrees * Math.pow(10, decimal)) / Math.pow(10, decimal);
            }
            return "NaN";
        };
    }), angular.module("a8m.math.kbFmt", []).filter("kbFmt", function() {
        var compared = [ {
            str: "KB",
            val: 1024
        } ];
        return [ "MB", "GB", "TB", "PB", "EB", "ZB", "YB" ].forEach(function(el, i) {
            compared.push({
                str: el,
                val: 1024 * compared[i].val
            });
        }), function(bytes, decimal) {
            if (isNumber(decimal) && isFinite(decimal) && decimal % 1 === 0 && decimal >= 0 && isNumber(bytes) && isFinite(bytes)) {
                for (var i = 0; i < compared.length - 1 && bytes >= compared[i].val; ) i++;
                return bytes /= i > 0 ? compared[i - 1].val : 1, convertToDecimal(bytes, decimal) + " " + compared[i].str;
            }
            return "NaN";
        };
    }), angular.module("a8m.math.max", []).filter("max", [ "$parse", function($parse) {
        function indexByMax(array, exp) {
            var mappedArray = array.map(function(elm) {
                return $parse(exp)(elm);
            });
            return mappedArray.indexOf(Math.max.apply(Math, mappedArray));
        }
        return function(input, expression) {
            return isArray(input) ? isUndefined(expression) ? Math.max.apply(Math, input) : input[indexByMax(input, expression)] : input;
        };
    } ]), angular.module("a8m.math.min", []).filter("min", [ "$parse", function($parse) {
        function indexByMin(array, exp) {
            var mappedArray = array.map(function(elm) {
                return $parse(exp)(elm);
            });
            return mappedArray.indexOf(Math.min.apply(Math, mappedArray));
        }
        return function(input, expression) {
            return isArray(input) ? isUndefined(expression) ? Math.min.apply(Math, input) : input[indexByMin(input, expression)] : input;
        };
    } ]), angular.module("a8m.math.percent", []).filter("percent", function() {
        return function(input, divided, round) {
            var divider = isString(input) ? Number(input) : input;
            return divided = divided || 100, round = round || !1, !isNumber(divider) || isNaN(divider) ? input : round ? Math.round(divider / divided * 100) : divider / divided * 100;
        };
    }), angular.module("a8m.math.radians", []).filter("radians", function() {
        return function(degrees, decimal) {
            if (isNumber(decimal) && isFinite(decimal) && decimal % 1 === 0 && decimal >= 0 && isNumber(degrees) && isFinite(degrees)) {
                var radians = 3.14159265359 * degrees / 180;
                return Math.round(radians * Math.pow(10, decimal)) / Math.pow(10, decimal);
            }
            return "NaN";
        };
    }), angular.module("a8m.math.radix", []).filter("radix", function() {
        return function(input, radix) {
            var RANGE = /^[2-9]$|^[1-2]\d$|^3[0-6]$/;
            return isNumber(input) && RANGE.test(radix) ? input.toString(radix).toUpperCase() : input;
        };
    }), angular.module("a8m.math.shortFmt", []).filter("shortFmt", function() {
        return function(number, decimal) {
            return isNumber(decimal) && isFinite(decimal) && decimal % 1 === 0 && decimal >= 0 && isNumber(number) && isFinite(number) ? 1e3 > number ? "" + number : 1e6 > number ? convertToDecimal(number / 1e3, decimal) + " K" : 1e9 > number ? convertToDecimal(number / 1e6, decimal) + " M" : convertToDecimal(number / 1e9, decimal) + " B" : "NaN";
        };
    }), angular.module("a8m.math.sum", []).filter("sum", function() {
        return function(input, initial) {
            return isArray(input) ? input.reduce(function(prev, curr) {
                return prev + curr;
            }, initial || 0) : input;
        };
    }), angular.module("a8m.ends-with", []).filter("endsWith", function() {
        return function(input, ends, csensitive) {
            var position, sensitive = csensitive || !1;
            return !isString(input) || isUndefined(ends) ? input : (input = sensitive ? input : input.toLowerCase(), 
            position = input.length - ends.length, -1 !== input.indexOf(sensitive ? ends : ends.toLowerCase(), position));
        };
    }), angular.module("a8m.latinize", []).filter("latinize", [ function() {
        function removeDiacritics(str) {
            return str.replace(/[^\u0000-\u007E]/g, function(a) {
                return diacriticsMap[a] || a;
            });
        }
        for (var defaultDiacriticsRemovalap = [ {
            base: "A",
            letters: "A"
        }, {
            base: "AA",
            letters: ""
        }, {
            base: "AE",
            letters: ""
        }, {
            base: "AO",
            letters: ""
        }, {
            base: "AU",
            letters: ""
        }, {
            base: "AV",
            letters: ""
        }, {
            base: "AY",
            letters: ""
        }, {
            base: "B",
            letters: "B"
        }, {
            base: "C",
            letters: "C"
        }, {
            base: "D",
            letters: "D"
        }, {
            base: "DZ",
            letters: ""
        }, {
            base: "Dz",
            letters: ""
        }, {
            base: "E",
            letters: "E"
        }, {
            base: "F",
            letters: "F"
        }, {
            base: "G",
            letters: "G"
        }, {
            base: "H",
            letters: "H"
        }, {
            base: "I",
            letters: "I"
        }, {
            base: "J",
            letters: "J"
        }, {
            base: "K",
            letters: "K"
        }, {
            base: "L",
            letters: "L"
        }, {
            base: "LJ",
            letters: ""
        }, {
            base: "Lj",
            letters: ""
        }, {
            base: "M",
            letters: "M"
        }, {
            base: "N",
            letters: "N"
        }, {
            base: "NJ",
            letters: ""
        }, {
            base: "Nj",
            letters: ""
        }, {
            base: "O",
            letters: "O"
        }, {
            base: "OI",
            letters: ""
        }, {
            base: "OO",
            letters: ""
        }, {
            base: "OU",
            letters: ""
        }, {
            base: "OE",
            letters: ""
        }, {
            base: "oe",
            letters: ""
        }, {
            base: "P",
            letters: "P"
        }, {
            base: "Q",
            letters: "Q"
        }, {
            base: "R",
            letters: "R"
        }, {
            base: "S",
            letters: "S"
        }, {
            base: "T",
            letters: "T"
        }, {
            base: "TZ",
            letters: ""
        }, {
            base: "U",
            letters: "U"
        }, {
            base: "V",
            letters: "V"
        }, {
            base: "VY",
            letters: ""
        }, {
            base: "W",
            letters: "W"
        }, {
            base: "X",
            letters: "X"
        }, {
            base: "Y",
            letters: "Y"
        }, {
            base: "Z",
            letters: "Z"
        }, {
            base: "a",
            letters: "a"
        }, {
            base: "aa",
            letters: ""
        }, {
            base: "ae",
            letters: ""
        }, {
            base: "ao",
            letters: ""
        }, {
            base: "au",
            letters: ""
        }, {
            base: "av",
            letters: ""
        }, {
            base: "ay",
            letters: ""
        }, {
            base: "b",
            letters: "b"
        }, {
            base: "c",
            letters: "c"
        }, {
            base: "d",
            letters: "d"
        }, {
            base: "dz",
            letters: ""
        }, {
            base: "e",
            letters: "e"
        }, {
            base: "f",
            letters: "f"
        }, {
            base: "g",
            letters: "g"
        }, {
            base: "h",
            letters: "h"
        }, {
            base: "hv",
            letters: ""
        }, {
            base: "i",
            letters: "i"
        }, {
            base: "j",
            letters: "j"
        }, {
            base: "k",
            letters: "k"
        }, {
            base: "l",
            letters: "l"
        }, {
            base: "lj",
            letters: ""
        }, {
            base: "m",
            letters: "m"
        }, {
            base: "n",
            letters: "n"
        }, {
            base: "nj",
            letters: ""
        }, {
            base: "o",
            letters: "o"
        }, {
            base: "oi",
            letters: ""
        }, {
            base: "ou",
            letters: ""
        }, {
            base: "oo",
            letters: ""
        }, {
            base: "p",
            letters: "p"
        }, {
            base: "q",
            letters: "q"
        }, {
            base: "r",
            letters: "r"
        }, {
            base: "s",
            letters: "s"
        }, {
            base: "t",
            letters: "t"
        }, {
            base: "tz",
            letters: ""
        }, {
            base: "u",
            letters: "u"
        }, {
            base: "v",
            letters: "v"
        }, {
            base: "vy",
            letters: ""
        }, {
            base: "w",
            letters: "w"
        }, {
            base: "x",
            letters: "x"
        }, {
            base: "y",
            letters: "y"
        }, {
            base: "z",
            letters: "z"
        } ], diacriticsMap = {}, i = 0; i < defaultDiacriticsRemovalap.length; i++) for (var letters = defaultDiacriticsRemovalap[i].letters.split(""), j = 0; j < letters.length; j++) diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
        return function(input) {
            return isString(input) ? removeDiacritics(input) : input;
        };
    } ]), angular.module("a8m.ltrim", []).filter("ltrim", function() {
        return function(input, chars) {
            var trim = chars || "\\s";
            return isString(input) ? input.replace(new RegExp("^" + trim + "+"), "") : input;
        };
    }), angular.module("a8m.match", []).filter("match", function() {
        return function(input, pattern, flag) {
            var reg = new RegExp(pattern, flag);
            return isString(input) ? input.match(reg) : null;
        };
    }), angular.module("a8m.repeat", []).filter("repeat", [ function() {
        return function(input, n, separator) {
            var times = ~~n;
            return isString(input) && times ? strRepeat(input, --n, separator || "") : input;
        };
    } ]), angular.module("a8m.rtrim", []).filter("rtrim", function() {
        return function(input, chars) {
            var trim = chars || "\\s";
            return isString(input) ? input.replace(new RegExp(trim + "+$"), "") : input;
        };
    }), angular.module("a8m.slugify", []).filter("slugify", [ function() {
        return function(input, sub) {
            var replace = isUndefined(sub) ? "-" : sub;
            return isString(input) ? input.toLowerCase().replace(/\s+/g, replace) : input;
        };
    } ]), angular.module("a8m.starts-with", []).filter("startsWith", function() {
        return function(input, start, csensitive) {
            var sensitive = csensitive || !1;
            return !isString(input) || isUndefined(start) ? input : (input = sensitive ? input : input.toLowerCase(), 
            !input.indexOf(sensitive ? start : start.toLowerCase()));
        };
    }), angular.module("a8m.stringular", []).filter("stringular", function() {
        return function(input) {
            var args = Array.prototype.slice.call(arguments, 1);
            return input.replace(/{(\d+)}/g, function(match, number) {
                return isUndefined(args[number]) ? match : args[number];
            });
        };
    }), angular.module("a8m.strip-tags", []).filter("stripTags", function() {
        return function(input) {
            return isString(input) ? input.replace(/<\S[^><]*>/g, "") : input;
        };
    }), angular.module("a8m.test", []).filter("test", function() {
        return function(input, pattern, flag) {
            var reg = new RegExp(pattern, flag);
            return isString(input) ? reg.test(input) : input;
        };
    }), angular.module("a8m.trim", []).filter("trim", function() {
        return function(input, chars) {
            var trim = chars || "\\s";
            return isString(input) ? input.replace(new RegExp("^" + trim + "+|" + trim + "+$", "g"), "") : input;
        };
    }), angular.module("a8m.truncate", []).filter("truncate", function() {
        return function(input, length, suffix, preserve) {
            return length = isUndefined(length) ? input.length : length, preserve = preserve || !1, 
            suffix = suffix || "", !isString(input) || input.length <= length ? input : input.substring(0, preserve ? -1 === input.indexOf(" ", length) ? input.length : input.indexOf(" ", length) : length) + suffix;
        };
    }), angular.module("a8m.ucfirst", []).filter("ucfirst", [ function() {
        return function(input) {
            return isString(input) ? input.split(" ").map(function(ch) {
                return ch.charAt(0).toUpperCase() + ch.substring(1);
            }).join(" ") : input;
        };
    } ]), angular.module("a8m.uri-component-encode", []).filter("uriComponentEncode", [ "$window", function($window) {
        return function(input) {
            return isString(input) ? $window.encodeURIComponent(input) : input;
        };
    } ]), angular.module("a8m.uri-encode", []).filter("uriEncode", [ "$window", function($window) {
        return function(input) {
            return isString(input) ? $window.encodeURI(input) : input;
        };
    } ]), angular.module("a8m.wrap", []).filter("wrap", function() {
        return function(input, wrap, ends) {
            return isString(input) && isDefined(wrap) ? [ wrap, input, ends || wrap ].join("") : input;
        };
    }), angular.module("a8m.filter-watcher", []).provider("filterWatcher", function() {
        this.$get = [ "$window", "$rootScope", function($window, $rootScope) {
            function getHashKey(fName, args) {
                function replacerFactory() {
                    var cache = [];
                    return function(key, val) {
                        if (isObject(val) && !isNull(val)) {
                            if (~cache.indexOf(val)) return "[Circular]";
                            cache.push(val);
                        }
                        return $window == val ? "$WINDOW" : $window.document == val ? "$DOCUMENT" : isScope(val) ? "$SCOPE" : val;
                    };
                }
                return [ fName, JSON.stringify(args, replacerFactory()) ].join("#").replace(/"/g, "");
            }
            function removeCache(event) {
                var id = event.targetScope.$id;
                forEach($$listeners[id], function(key) {
                    delete $$cache[key];
                }), delete $$listeners[id];
            }
            function cleanStateless() {
                $$timeout(function() {
                    $rootScope.$$phase || ($$cache = {});
                }, 2e3);
            }
            function addListener(scope, hashKey) {
                var id = scope.$id;
                return isUndefined($$listeners[id]) && (scope.$on("$destroy", removeCache), $$listeners[id] = []), 
                $$listeners[id].push(hashKey);
            }
            function $$isMemoized(filterName, args) {
                var hashKey = getHashKey(filterName, args);
                return $$cache[hashKey];
            }
            function $$memoize(filterName, args, scope, result) {
                var hashKey = getHashKey(filterName, args);
                return $$cache[hashKey] = result, isScope(scope) ? addListener(scope, hashKey) : cleanStateless(), 
                result;
            }
            var $$cache = {}, $$listeners = {}, $$timeout = $window.setTimeout;
            return {
                isMemoized: $$isMemoized,
                memoize: $$memoize
            };
        } ];
    }), angular.module("angular.filter", [ "a8m.ucfirst", "a8m.uri-encode", "a8m.uri-component-encode", "a8m.slugify", "a8m.latinize", "a8m.strip-tags", "a8m.stringular", "a8m.truncate", "a8m.starts-with", "a8m.ends-with", "a8m.wrap", "a8m.trim", "a8m.ltrim", "a8m.rtrim", "a8m.repeat", "a8m.test", "a8m.match", "a8m.to-array", "a8m.concat", "a8m.contains", "a8m.unique", "a8m.is-empty", "a8m.after", "a8m.after-where", "a8m.before", "a8m.before-where", "a8m.defaults", "a8m.where", "a8m.reverse", "a8m.remove", "a8m.remove-with", "a8m.group-by", "a8m.count-by", "a8m.chunk-by", "a8m.search-field", "a8m.fuzzy-by", "a8m.fuzzy", "a8m.omit", "a8m.pick", "a8m.every", "a8m.filter-by", "a8m.xor", "a8m.map", "a8m.first", "a8m.last", "a8m.flatten", "a8m.join", "a8m.range", "a8m.math.max", "a8m.math.min", "a8m.math.abs", "a8m.math.percent", "a8m.math.radix", "a8m.math.sum", "a8m.math.degrees", "a8m.math.radians", "a8m.math.byteFmt", "a8m.math.kbFmt", "a8m.math.shortFmt", "a8m.angular", "a8m.conditions", "a8m.is-null", "a8m.filter-watcher" ]);
}(window, window.angular), angular.module("youtube-embed", [ "ng" ]).service("youtubeEmbedUtils", [ "$window", "$rootScope", function($window, $rootScope) {
    function contains(str, substr) {
        return str.indexOf(substr) > -1;
    }
    var Service = {}, youtubeRegexp = /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\S*[^\w\s-])([\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/gi, timeRegexp = /t=(\d+)[ms]?(\d+)?s?/;
    return Service.getIdFromURL = function(url) {
        var id = url.replace(youtubeRegexp, "$1");
        if (contains(id, ";")) {
            var pieces = id.split(";");
            if (contains(pieces[1], "%")) {
                var uriComponent = decodeURIComponent(id.split(";")[1]);
                id = ("http://youtube.com" + uriComponent).replace(youtubeRegexp, "$1");
            } else id = pieces[0];
        } else contains(id, "#") && (id = id.split("#")[0]);
        return id;
    }, Service.getTimeFromURL = function(url) {
        url = url || "";
        var times = url.match(timeRegexp);
        if (!times) return 0;
        var full = times[0], minutes = times[1], seconds = times[2];
        return "undefined" != typeof seconds ? (seconds = parseInt(seconds, 10), minutes = parseInt(minutes, 10)) : contains(full, "m") ? (minutes = parseInt(minutes, 10), 
        seconds = 0) : (seconds = parseInt(minutes, 10), minutes = 0), seconds + 60 * minutes;
    }, function() {
        var tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName("script")[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }(), Service.ready = !1, $window.onYouTubeIframeAPIReady = function() {
        $rootScope.$apply(function() {
            Service.ready = !0;
        });
    }, Service;
} ]).directive("youtubeVideo", [ "youtubeEmbedUtils", function(youtubeEmbedUtils) {
    var uniqId = 1, stateNames = {
        "-1": "unstarted",
        0: "ended",
        1: "playing",
        2: "paused",
        3: "buffering",
        5: "queued"
    }, eventPrefix = "youtube.player.";
    return {
        restrict: "EA",
        scope: {
            videoId: "=?",
            videoUrl: "=?",
            player: "=?",
            playerVars: "=?",
            playerHeight: "=?",
            playerWidth: "=?"
        },
        link: function(scope, element, attrs) {
            function applyBroadcast() {
                var args = Array.prototype.slice.call(arguments);
                scope.$apply(function() {
                    scope.$emit.apply(scope, args);
                });
            }
            function onPlayerStateChange(event) {
                var state = stateNames[event.data];
                "undefined" != typeof state && applyBroadcast(eventPrefix + state, scope.player, event), 
                scope.$apply(function() {
                    scope.player.currentState = state;
                });
            }
            function onPlayerReady(event) {
                applyBroadcast(eventPrefix + "ready", scope.player, event);
            }
            function onPlayerError(event) {
                applyBroadcast(eventPrefix + "error", scope.player, event);
            }
            function createPlayer() {
                var playerVars = angular.copy(scope.playerVars);
                playerVars.start = playerVars.start || scope.urlStartTime;
                var player = new YT.Player(playerId, {
                    height: scope.playerHeight,
                    width: scope.playerWidth,
                    videoId: scope.videoId,
                    playerVars: playerVars,
                    events: {
                        onReady: onPlayerReady,
                        onStateChange: onPlayerStateChange,
                        onError: onPlayerError
                    }
                });
                return player.id = playerId, player;
            }
            function loadPlayer() {
                (scope.videoId || scope.playerVars.list) && (scope.player && scope.player.d && "function" == typeof scope.player.destroy && scope.player.destroy(), 
                scope.player = createPlayer());
            }
            scope.utils = youtubeEmbedUtils;
            var playerId = attrs.playerId || element[0].id || "unique-youtube-embed-id-" + uniqId++;
            element[0].id = playerId, scope.playerHeight = scope.playerHeight || 390, scope.playerWidth = scope.playerWidth || 640, 
            scope.playerVars = scope.playerVars || {};
            var stopWatchingReady = scope.$watch(function() {
                return scope.utils.ready && ("undefined" != typeof scope.videoUrl || "undefined" != typeof scope.videoId || "undefined" != typeof scope.playerVars.list);
            }, function(ready) {
                ready && (stopWatchingReady(), "undefined" != typeof scope.videoUrl ? scope.$watch("videoUrl", function(url) {
                    scope.videoId = scope.utils.getIdFromURL(url), scope.urlStartTime = scope.utils.getTimeFromURL(url), 
                    loadPlayer();
                }) : "undefined" != typeof scope.videoId ? scope.$watch("videoId", function() {
                    scope.urlStartTime = null, loadPlayer();
                }) : scope.$watch("playerVars.list", function() {
                    scope.urlStartTime = null, loadPlayer();
                }));
            });
            scope.$watchCollection([ "playerHeight", "playerWidth" ], function() {
                scope.player && scope.player.setSize(scope.playerWidth, scope.playerHeight);
            }), scope.$on("$destroy", function() {
                scope.player && scope.player.destroy();
            });
        }
    };
} ]), angular.module("fluro.video", [ "fluro.config", "fluro.util", "youtube-embed" ]), 
angular.module("fluro.video").directive("fluroVideo", [ "$compile", "Fluro", function($compile, Fluro) {
    return {
        restrict: "E",
        replace: !0,
        template: '<div class="fluro-video video-{{model.assetType}}"></div>',
        controller: "FluroVideoController",
        scope: {
            model: "=ngModel",
            ngParams: "&"
        },
        link: function($scope, $element, $attrs) {
            $scope.$watch("model", function() {
                $scope.params = $scope.ngParams(), $scope.params || ($scope.params = {
                    controls: 0,
                    autoplay: 0,
                    modestbranding: 1,
                    playsinline: 1,
                    showinfo: 0,
                    theme: "light",
                    byline: 0,
                    portrait: 0,
                    title: 0
                });
                var template;
                switch ($element.empty(), $scope.model.assetType) {
                  case "youtube":
                    template = '<div class="embed-responsive embed-responsive-16by9"><youtube-video class="embed-responsive-item" video-url="model.external.youtube" player-vars="params"/></div>';
                    break;

                  case "embed":
                    template = '<div class="embed-responsive embed-responsive-16by9">' + $scope.model.external.embed + "</div>";
                    break;

                  case "vimeo":
                    template = '<div class="embed-responsive embed-responsive-16by9"><vimeo-video class="embed-responsive-item" video-url="model.external.vimeo" player-vars="params"/></div>';
                    break;

                  case "upload":
                    $scope.playUrl = Fluro.apiURL + "/get/" + $scope.model._id, template = '<div class="embed-responsive embed-responsive-16by9"><video class="embed-responsive-item" controls><source ng-src="{{playUrl | trustfluro}}" type="{{model.mimetype}}"></video></div>';
                }
                if (template) {
                    var cTemplate = $compile(template)($scope);
                    $element.append(cTemplate);
                }
            });
        }
    };
} ]), angular.module("fluro.video").filter("trustfluro", [ "$sce", function($sce) {
    return function(val) {
        return $sce.trustAsResourceUrl(val);
    };
} ]), angular.module("fluro.video").controller("FluroVideoController", [ "$scope", function($scope) {} ]), 
angular.module("fluro.video").service("VideoTools", [ "$http", function($http) {
    var controller = {}, cache = {};
    return controller.getVideoThumbnail = function(item) {
        if (item && item._id) {
            if (cache[item._id]) return cache[item._id];
            switch (item.assetType) {
              case "youtube":
                var details = controller.parseVideoURL(item.external.youtube);
                cache[item._id] = "https://img.youtube.com/vi/" + details.id + "/mqdefault.jpg";
                break;

              case "vimeo":
                controller.getVimeoID(item.external.vimeo);
                return;

              case "upload":
                return;
            }
            return cache[item._id];
        }
    }, controller.getVimeoID = function(url) {
        var reg = /https?:\/\/(?:www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|)(\d+)(?:$|\/|\?)/, match = url.match(reg);
        return match ? match[3] : void 0;
    }, controller.parseVideoURL = function(url) {
        function contains(str, substr) {
            return str.indexOf(substr) > -1;
        }
        function getParm(url, base) {
            var re = new RegExp("(\\?|&)" + base + "\\=([^&]*)(&|$)"), matches = url.match(re);
            return matches ? matches[2] : "";
        }
        var matches, retVal = {};
        if (-1 != url.indexOf("youtube.com/watch")) retVal.provider = "youtube", retVal.id = getParm(url, "v"); else if (matches = url.match(/vimeo.com\/(\d+)/)) retVal.provider = "vimeo", 
        retVal.id = matches[1]; else {
            var youtubeRegexp = /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\S*[^\w\s-])([\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/gi, YoutubeID = url.replace(youtubeRegexp, "$1");
            if (contains(YoutubeID, ";")) {
                var pieces = YoutubeID.split(";");
                if (contains(pieces[1], "%")) {
                    var uriComponent = decodeURIComponent(YoutubeID.split(";")[1]);
                    YoutubeID = ("http://youtube.com" + uriComponent).replace(youtubeRegexp, "$1");
                } else YoutubeID = pieces[0];
            } else contains(YoutubeID, "#") && (YoutubeID = YoutubeID.split("#")[0]);
            retVal.provider = "youtube", retVal.id = YoutubeID;
        }
        return retVal;
    }, controller;
} ]), angular.module("fluro.video").directive("videoThumbnail", function() {
    return {
        restrict: "E",
        replace: !0,
        scope: {
            model: "=ngModel"
        },
        template: '<span><img ng-src="{{thumbnailUrl}}"/></span>',
        controller: [ "$scope", "$http", "VideoTools", function($scope, $http, VideoTools) {
            $scope.$watch("model", function(model) {
                model && ($scope.thumbnailUrl = VideoTools.getVideoThumbnail(model));
            });
        } ]
    };
}), angular.module("fluro.video").service("VimeoEmbedSettings", [ "$http", function($http) {
    var controller = {};
    return controller.getVideoInformation = function(vimeoID) {
        return $http.get("http://vimeo.com/api/v2/video/" + vimeoID + ".output");
    }, controller;
} ]), angular.module("fluro.video").directive("vimeoVideo", [ "$compile", "VimeoEmbedSettings", function($compile, VimeoEmbedSettings) {
    return {
        restrict: "E",
        scope: {
            videoId: "=",
            videoUrl: "=",
            playerVars: "="
        },
        link: function($scope, $element, $attrs) {
            function getVimeoID(url) {
                var reg = /https?:\/\/(?:www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|)(\d+)(?:$|\/|\?)/, match = url.match(reg);
                return match ? match[3] : void 0;
            }
            $scope.getVideoInformation = function() {
                return $scope.videoId ? VimeoEmbedSettings.getVideoInformation($scope.videoId) : void 0;
            }, $scope.$watch("videoId + videoUrl + playerVars", function() {
                var VideoID;
                $scope.videoId ? VideoID = $scope.videoId : $scope.videoUrl && (VideoID = getVimeoID($scope.videoUrl));
                var params = "";
                if ($scope.playerVars) for (var key in $scope.playerVars) params += "&" + key + "=" + $scope.playerVars[key];
                $scope.vimeoEmbedURL = "//player.vimeo.com/video/" + VideoID + "?player_id=" + VideoID + params;
            });
            var template = '<iframe ng-src="{{vimeoEmbedURL | trustVimeo}}" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>', cTemplate = $compile(template)($scope);
            $element.replaceWith(cTemplate);
        }
    };
} ]), angular.module("fluro.video").filter("trustVimeo", [ "$sce", function($sce) {
    return function(val) {
        return $sce.trustAsResourceUrl(val);
    };
} ]), angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", [ "$animate", "$q", "$parse", "$injector", function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has("$animateCss") ? $injector.get("$animateCss") : null;
    return {
        link: function(scope, element, attrs) {
            function init() {
                horizontal = !!("horizontal" in attrs), horizontal ? (css = {
                    width: ""
                }, cssTo = {
                    width: "0"
                }) : (css = {
                    height: ""
                }, cssTo = {
                    height: "0"
                }), scope.$eval(attrs.uibCollapse) || element.addClass("in").addClass("collapse").attr("aria-expanded", !0).attr("aria-hidden", !1).css(css);
            }
            function getScrollFromElement(element) {
                return horizontal ? {
                    width: element.scrollWidth + "px"
                } : {
                    height: element.scrollHeight + "px"
                };
            }
            function expand() {
                element.hasClass("collapse") && element.hasClass("in") || $q.resolve(expandingExpr(scope)).then(function() {
                    element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), 
                    $animateCss ? $animateCss(element, {
                        addClass: "in",
                        easing: "ease",
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).start()["finally"](expandDone) : $animate.addClass(element, "in", {
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).then(expandDone);
                }, angular.noop);
            }
            function expandDone() {
                element.removeClass("collapsing").addClass("collapse").css(css), expandedExpr(scope);
            }
            function collapse() {
                return element.hasClass("collapse") || element.hasClass("in") ? void $q.resolve(collapsingExpr(scope)).then(function() {
                    element.css(getScrollFromElement(element[0])).removeClass("collapse").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), 
                    $animateCss ? $animateCss(element, {
                        removeClass: "in",
                        to: cssTo
                    }).start()["finally"](collapseDone) : $animate.removeClass(element, "in", {
                        to: cssTo
                    }).then(collapseDone);
                }, angular.noop) : collapseDone();
            }
            function collapseDone() {
                element.css(cssTo), element.removeClass("collapsing").addClass("collapse"), collapsedExpr(scope);
            }
            var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed), horizontal = !1, css = {}, cssTo = {};
            init(), scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.tabindex", []).directive("uibTabindexToggle", function() {
    return {
        restrict: "A",
        link: function(scope, elem, attrs) {
            attrs.$observe("disabled", function(disabled) {
                attrs.$set("tabindex", disabled ? -1 : null);
            });
        }
    };
}), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse", "ui.bootstrap.tabindex" ]).constant("uibAccordionConfig", {
    closeOthers: !0
}).controller("UibAccordionController", [ "$scope", "$attrs", "uibAccordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("uibAccordion", function() {
    return {
        controller: "UibAccordionController",
        controllerAs: "accordion",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion.html";
        }
    };
}).directive("uibAccordionGroup", function() {
    return {
        require: "^uibAccordion",
        transclude: !0,
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            panelClass: "@?",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            element.addClass("panel"), accordionCtrl.addGroup(scope), scope.openClass = attrs.openClass || "panel-open", 
            scope.panelClass = attrs.panelClass || "panel-default", scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, !!value), value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function($event) {
                scope.isDisabled || $event && 32 !== $event.which || (scope.isOpen = !scope.isOpen);
            };
            var id = "accordiongroup-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            scope.headingId = id + "-tab", scope.panelId = id + "-panel";
        }
    };
}).directive("uibAccordionHeading", function() {
    return {
        transclude: !0,
        template: "",
        replace: !0,
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
}).directive("uibAccordionTransclude", function() {
    function getHeaderSelectors() {
        return "uib-accordion-header,data-uib-accordion-header,x-uib-accordion-header,uib\\:accordion-header,[uib-accordion-header],[data-uib-accordion-header],[x-uib-accordion-header]";
    }
    return {
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, controller) {
            scope.$watch(function() {
                return controller[attrs.uibAccordionTransclude];
            }, function(heading) {
                if (heading) {
                    var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                    elem.html(""), elem.append(heading);
                }
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("UibAlertController", [ "$scope", "$element", "$attrs", "$interpolate", "$timeout", function($scope, $element, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close, $element.addClass("alert"), $attrs.$set("role", "alert"), 
    $scope.closeable && $element.addClass("alert-dismissible");
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    dismissOnTimeout && $timeout(function() {
        $scope.close();
    }, parseInt(dismissOnTimeout, 10));
} ]).directive("uibAlert", function() {
    return {
        controller: "UibAlertController",
        controllerAs: "alert",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/alert/alert.html";
        },
        transclude: !0,
        scope: {
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.buttons", []).constant("uibButtonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("UibButtonsController", [ "uibButtonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("uibBtnRadio", [ "$parse", function($parse) {
    return {
        require: [ "uibBtnRadio", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1], uncheckableExpr = $parse(attrs.uibUncheckable);
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                if (!attrs.disabled) {
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio)), ngModelCtrl.$render();
                    });
                }
            }), attrs.uibUncheckable && scope.$watch(uncheckableExpr, function(uncheckable) {
                attrs.$set("uncheckable", uncheckable ? "" : void 0);
            });
        }
    };
} ]).directive("uibBtnCheckbox", function() {
    return {
        require: [ "uibBtnCheckbox", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                attrs.disabled || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", []).controller("UibCarouselController", [ "$scope", "$element", "$interval", "$timeout", "$animate", function($scope, $element, $interval, $timeout, $animate) {
    function setActive(index) {
        for (var i = 0; i < slides.length; i++) slides[i].slide.active = i === index;
    }
    function goNext(slide, index, direction) {
        if (!destroyed) {
            if (angular.extend(slide, {
                direction: direction
            }), angular.extend(slides[currentIndex].slide || {}, {
                direction: direction
            }), $animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();
                angular.isNumber(currentIdx) && slides[currentIdx].element && slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction), 
                $scope.$currentTransition = !0, $animate.on("addClass", slides[index].element, function(element, phase) {
                    "close" === phase && ($scope.$currentTransition = null, $animate.off("addClass", element));
                });
            }
            $scope.active = slide.index, currentIndex = slide.index, setActive(index), restartTimer();
        }
    }
    function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide === slide) return i;
    }
    function resetTimer() {
        currentInterval && ($interval.cancel(currentInterval), currentInterval = null);
    }
    function resetTransition(slides) {
        slides.length || ($scope.$currentTransition = null);
    }
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval));
    }
    function timerFn() {
        var interval = +$scope.interval;
        isPlaying && !isNaN(interval) && interval > 0 && slides.length ? $scope.next() : $scope.pause();
    }
    var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = "uib-slideDirection", currentIndex = $scope.active, destroyed = !1;
    $element.addClass("carousel"), self.addSlide = function(slide, element) {
        slides.push({
            slide: slide,
            element: element
        }), slides.sort(function(a, b) {
            return +a.slide.index - +b.slide.index;
        }), (slide.index === $scope.active || 1 === slides.length && !angular.isNumber($scope.active)) && ($scope.$currentTransition && ($scope.$currentTransition = null), 
        currentIndex = slide.index, $scope.active = slide.index, setActive(currentIndex), 
        self.select(slides[findSlideIndex(slide)]), 1 === slides.length && $scope.play());
    }, self.getCurrentIndex = function() {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === currentIndex) return i;
    }, self.next = $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        return 0 === newIndex && $scope.noWrap() ? void $scope.pause() : self.select(slides[newIndex], "next");
    }, self.prev = $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        return $scope.noWrap() && newIndex === slides.length - 1 ? void $scope.pause() : self.select(slides[newIndex], "prev");
    }, self.removeSlide = function(slide) {
        var index = findSlideIndex(slide);
        slides.splice(index, 1), slides.length > 0 && currentIndex === index ? index >= slides.length ? (currentIndex = slides.length - 1, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[slides.length - 1])) : (currentIndex = index, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[index])) : currentIndex > index && (currentIndex--, 
        $scope.active = currentIndex), 0 === slides.length && (currentIndex = null, $scope.active = null);
    }, self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        void 0 === direction && (direction = nextIndex > self.getCurrentIndex() ? "next" : "prev"), 
        nextSlide.slide.index === currentIndex || $scope.$currentTransition || goNext(nextSlide.slide, nextIndex, direction);
    }, $scope.indexOfSlide = function(slide) {
        return +slide.slide.index;
    }, $scope.isActive = function(slide) {
        return $scope.active === slide.slide.index;
    }, $scope.isPrevDisabled = function() {
        return 0 === $scope.active && $scope.noWrap();
    }, $scope.isNextDisabled = function() {
        return $scope.active === slides.length - 1 && $scope.noWrap();
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $element.on("mouseenter", $scope.pause), $element.on("mouseleave", $scope.play), 
    $scope.$on("$destroy", function() {
        destroyed = !0, resetTimer();
    }), $scope.$watch("noTransition", function(noTransition) {
        $animate.enabled($element, !noTransition);
    }), $scope.$watch("interval", restartTimer), $scope.$watchCollection("slides", resetTransition), 
    $scope.$watch("active", function(index) {
        if (angular.isNumber(index) && currentIndex !== index) {
            for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === index) {
                index = i;
                break;
            }
            var slide = slides[index];
            slide && (setActive(index), self.select(slides[index]), currentIndex = index);
        }
    });
} ]).directive("uibCarousel", function() {
    return {
        transclude: !0,
        controller: "UibCarouselController",
        controllerAs: "carousel",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/carousel.html";
        },
        scope: {
            active: "=",
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        }
    };
}).directive("uibSlide", [ "$animate", function($animate) {
    return {
        require: "^uibCarousel",
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/slide.html";
        },
        scope: {
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            element.addClass("item"), carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                $animate[active ? "addClass" : "removeClass"](element, "active");
            });
        }
    };
} ]).animation(".item", [ "$animateCss", function($animateCss) {
    function removeClass(element, className, callback) {
        element.removeClass(className), callback && callback();
    }
    var SLIDE_DIRECTION = "uib-slideDirection";
    return {
        beforeAddClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass + " " + direction, done);
                return element.addClass(direction), $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        },
        beforeRemoveClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass, done);
                return $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        }
    };
} ]), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", [ "$log", "$locale", "dateFilter", "orderByFilter", "filterFilter", function($log, $locale, dateFilter, orderByFilter, filterFilter) {
    function getFormatCodeToRegex(key) {
        return filterFilter(formatCodeToRegex, {
            key: key
        }, !0)[0];
    }
    function createParser(format) {
        var map = [], regex = format.split(""), quoteIndex = format.indexOf("'");
        if (quoteIndex > -1) {
            var inLiteral = !1;
            format = format.split("");
            for (var i = quoteIndex; i < format.length; i++) inLiteral ? ("'" === format[i] && (i + 1 < format.length && "'" === format[i + 1] ? (format[i + 1] = "$", 
            regex[i + 1] = "") : (regex[i] = "", inLiteral = !1)), format[i] = "$") : "'" === format[i] && (format[i] = "$", 
            regex[i] = "", inLiteral = !0);
            format = format.join("");
        }
        return angular.forEach(formatCodeToRegex, function(data) {
            var index = format.indexOf(data.key);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + data.key.length; n > i; i++) regex[i] = "", 
                format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    key: data.key,
                    apply: data.apply,
                    matcher: data.regex
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }
    function createFormatter(format) {
        for (var formatter, literalIdx, formatters = [], i = 0; i < format.length; ) if (angular.isNumber(literalIdx)) {
            if ("'" === format.charAt(i)) (i + 1 >= format.length || "'" !== format.charAt(i + 1)) && (formatters.push(constructLiteralFormatter(format, literalIdx, i)), 
            literalIdx = null); else if (i === format.length) for (;literalIdx < format.length; ) formatter = constructFormatterFromIdx(format, literalIdx), 
            formatters.push(formatter), literalIdx = formatter.endIdx;
            i++;
        } else "'" !== format.charAt(i) ? (formatter = constructFormatterFromIdx(format, i), 
        formatters.push(formatter.parser), i = formatter.endIdx) : (literalIdx = i, i++);
        return formatters;
    }
    function constructLiteralFormatter(format, literalIdx, endIdx) {
        return function() {
            return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
        };
    }
    function constructFormatterFromIdx(format, i) {
        for (var currentPosStr = format.substr(i), j = 0; j < formatCodeToRegex.length; j++) if (new RegExp("^" + formatCodeToRegex[j].key).test(currentPosStr)) {
            var data = formatCodeToRegex[j];
            return {
                endIdx: i + data.key.length,
                parser: data.formatter
            };
        }
        return {
            endIdx: i + 1,
            parser: function() {
                return currentPosStr.charAt(0);
            }
        };
    }
    function isValid(year, month, date) {
        return 1 > date ? !1 : 1 === month && date > 28 ? 29 === date && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) : 3 === month || 5 === month || 8 === month || 10 === month ? 31 > date : !0;
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }
    function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, !0) : date;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset(), timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    var localeId, formatCodeToRegex, SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    this.init = function() {
        localeId = $locale.id, this.parsers = {}, this.formatters = {}, formatCodeToRegex = [ {
            key: "yyyy",
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yyyy");
            }
        }, {
            key: "yy",
            regex: "\\d{2}",
            apply: function(value) {
                value = +value, this.year = 69 > value ? value + 2e3 : value + 1900;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yy");
            }
        }, {
            key: "y",
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "y");
            }
        }, {
            key: "M!",
            regex: "0?[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                var value = date.getMonth();
                return /^[0-9]$/.test(value) ? dateFilter(date, "MM") : dateFilter(date, "M");
            }
        }, {
            key: "MMMM",
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMMM");
            }
        }, {
            key: "MMM",
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMM");
            }
        }, {
            key: "MM",
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "MM");
            }
        }, {
            key: "M",
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "M");
            }
        }, {
            key: "d!",
            regex: "[0-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                var value = date.getDate();
                return /^[1-9]$/.test(value) ? dateFilter(date, "dd") : dateFilter(date, "d");
            }
        }, {
            key: "dd",
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "dd");
            }
        }, {
            key: "d",
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "d");
            }
        }, {
            key: "EEEE",
            regex: $locale.DATETIME_FORMATS.DAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEEE");
            }
        }, {
            key: "EEE",
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEE");
            }
        }, {
            key: "HH",
            regex: "(?:0|1)[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "HH");
            }
        }, {
            key: "hh",
            regex: "0[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "hh");
            }
        }, {
            key: "H",
            regex: "1?[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "H");
            }
        }, {
            key: "h",
            regex: "[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "h");
            }
        }, {
            key: "mm",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "mm");
            }
        }, {
            key: "m",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "m");
            }
        }, {
            key: "sss",
            regex: "[0-9][0-9][0-9]",
            apply: function(value) {
                this.milliseconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "sss");
            }
        }, {
            key: "ss",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "ss");
            }
        }, {
            key: "s",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "s");
            }
        }, {
            key: "a",
            regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
            apply: function(value) {
                12 === this.hours && (this.hours = 0), "PM" === value && (this.hours += 12);
            },
            formatter: function(date) {
                return dateFilter(date, "a");
            }
        }, {
            key: "Z",
            regex: "[+-]\\d{4}",
            apply: function(value) {
                var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                this.hours += toInt(sign + hours), this.minutes += toInt(sign + minutes);
            },
            formatter: function(date) {
                return dateFilter(date, "Z");
            }
        }, {
            key: "ww",
            regex: "[0-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "ww");
            }
        }, {
            key: "w",
            regex: "[0-9]|[1-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "w");
            }
        }, {
            key: "GGGG",
            regex: $locale.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g, "\\s"),
            formatter: function(date) {
                return dateFilter(date, "GGGG");
            }
        }, {
            key: "GGG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GGG");
            }
        }, {
            key: "GG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GG");
            }
        }, {
            key: "G",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "G");
            }
        } ], angular.version.major >= 1 && angular.version.minor > 4 && formatCodeToRegex.push({
            key: "LLLL",
            regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "LLLL");
            }
        });
    }, this.init(), this.getParser = function(key) {
        var f = getFormatCodeToRegex(key);
        return f && f.apply || null;
    }, this.overrideParser = function(key, parser) {
        var f = getFormatCodeToRegex(key);
        f && angular.isFunction(parser) && (this.parsers = {}, f.apply = parser);
    }.bind(this), this.filter = function(date, format) {
        if (!angular.isDate(date) || isNaN(date) || !format) return "";
        format = $locale.DATETIME_FORMATS[format] || format, $locale.id !== localeId && this.init(), 
        this.formatters[format] || (this.formatters[format] = createFormatter(format));
        var formatters = this.formatters[format];
        return formatters.reduce(function(str, formatter) {
            return str + formatter(date);
        }, "");
    }, this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) return input;
        format = $locale.DATETIME_FORMATS[format] || format, format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&"), 
        $locale.id !== localeId && this.init(), this.parsers[format] || (this.parsers[format] = createParser(format, "apply"));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = !1;
        if (results && results.length) {
            var fields, dt;
            angular.isDate(baseDate) && !isNaN(baseDate.getTime()) ? fields = {
                year: baseDate.getFullYear(),
                month: baseDate.getMonth(),
                date: baseDate.getDate(),
                hours: baseDate.getHours(),
                minutes: baseDate.getMinutes(),
                seconds: baseDate.getSeconds(),
                milliseconds: baseDate.getMilliseconds()
            } : (baseDate && $log.warn("dateparser:", "baseDate is not a valid date"), fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0,
                minutes: 0,
                seconds: 0,
                milliseconds: 0
            });
            for (var i = 1, n = results.length; n > i; i++) {
                var mapper = map[i - 1];
                "Z" === mapper.matcher && (tzOffset = !0), mapper.apply && mapper.apply.call(fields, results[i]);
            }
            var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear, timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
            return isValid(fields.year, fields.month, fields.date) && (!angular.isDate(baseDate) || isNaN(baseDate.getTime()) || tzOffset ? (dt = new Date(0), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0)) : (dt = new Date(baseDate), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds))), 
            dt;
        }
    }, this.toTimezone = toTimezone, this.fromTimezone = fromTimezone, this.timezoneToOffset = timezoneToOffset, 
    this.addDateMinutes = addDateMinutes, this.convertTimezoneToLocal = convertTimezoneToLocal;
} ]), angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", [ "$animate", function($animate) {
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/, IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            function linkFn(scope, element, attrs) {
                linkedScopes.push(scope), instances.push({
                    scope: scope,
                    element: element
                }), exps.forEach(function(exp, k) {
                    addForExp(exp, scope);
                }), scope.$on("$destroy", removeScope);
            }
            function addForExp(exp, scope) {
                var matches = exp.match(IS_REGEXP), clazz = scope.$eval(matches[1]), compareWithExp = matches[2], data = expToData[exp];
                if (!data) {
                    var watchFn = function(compareWithVal) {
                        var newActivated = null;
                        instances.some(function(instance) {
                            var thisVal = instance.scope.$eval(onExp);
                            return thisVal === compareWithVal ? (newActivated = instance, !0) : void 0;
                        }), data.lastActivated !== newActivated && (data.lastActivated && $animate.removeClass(data.lastActivated.element, clazz), 
                        newActivated && $animate.addClass(newActivated.element, clazz), data.lastActivated = newActivated);
                    };
                    expToData[exp] = data = {
                        lastActivated: null,
                        scope: scope,
                        watchFn: watchFn,
                        compareWithExp: compareWithExp,
                        watcher: scope.$watch(compareWithExp, watchFn)
                    };
                }
                data.watchFn(scope.$eval(compareWithExp));
            }
            function removeScope(e) {
                var removedScope = e.targetScope, index = linkedScopes.indexOf(removedScope);
                if (linkedScopes.splice(index, 1), instances.splice(index, 1), linkedScopes.length) {
                    var newWatchScope = linkedScopes[0];
                    angular.forEach(expToData, function(data) {
                        data.scope === removedScope && (data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn), 
                        data.scope = newWatchScope);
                    });
                } else expToData = {};
            }
            var linkedScopes = [], instances = [], expToData = {}, onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP), onExp = onExpMatches[2], expsStr = onExpMatches[1], exps = expsStr.split(",");
            return linkFn;
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.isClass" ]).value("$datepickerSuppressError", !1).value("$datepickerLiteralWarning", !0).constant("uibDatepickerConfig", {
    datepickerMode: "day",
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    maxDate: null,
    maxMode: "year",
    minDate: null,
    minMode: "day",
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: !1,
    showWeeks: !0,
    yearColumns: 5,
    yearRows: 4
}).controller("UibDatepickerController", [ "$scope", "$element", "$attrs", "$parse", "$interpolate", "$locale", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerLiteralWarning", "$datepickerSuppressError", "uibDateParser", function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
    function setMode(mode) {
        $scope.datepickerMode = mode, $scope.datepickerOptions.datepickerMode = mode;
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        if (angular.version.minor < 6) ngModelOptions = ngModelCtrl.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions || {}, 
        ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }; else {
            var timezone = ngModelCtrl.$options.getOption("timezone") || ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) || (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);
            ngModelOptions = ngModelCtrl.$options.createChild(datepickerConfig.ngModelOptions).createChild($scope.datepickerOptions.ngModelOptions).createChild(ngModelCtrl.$options).createChild({
                timezone: timezone
            });
        }
        return ngModelOptions;
    }
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, ngModelOptions = {}, watchListeners = [];
    $element.addClass("uib-datepicker"), $attrs.$set("role", "application"), $scope.datepickerOptions || ($scope.datepickerOptions = {}), 
    this.modes = [ "day", "month", "year" ], [ "customClass", "dateDisabled", "datepickerMode", "formatDay", "formatDayHeader", "formatDayTitle", "formatMonth", "formatMonthTitle", "formatYear", "maxDate", "maxMode", "minDate", "minMode", "monthColumns", "showWeeks", "shortcutPropagation", "startingDay", "yearColumns", "yearRows" ].forEach(function(key) {
        switch (key) {
          case "customClass":
          case "dateDisabled":
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;

          case "datepickerMode":
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;

          case "formatDay":
          case "formatDayHeader":
          case "formatDayTitle":
          case "formatMonth":
          case "formatMonthTitle":
          case "formatYear":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;

          case "monthColumns":
          case "showWeeks":
          case "shortcutPropagation":
          case "yearColumns":
          case "yearRows":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;

          case "startingDay":
            angular.isDefined($scope.datepickerOptions.startingDay) ? self.startingDay = $scope.datepickerOptions.startingDay : angular.isNumber(datepickerConfig.startingDay) ? self.startingDay = datepickerConfig.startingDay : self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            break;

          case "maxDate":
          case "minDate":
            $scope.$watch("datepickerOptions." + key, function(value) {
                value ? angular.isDate(value) ? self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption("timezone")) : ($datepickerLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
                self[key] = new Date(dateFilter(value, "medium"))) : self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption("timezone")) : null, 
                self.refreshView();
            });
            break;

          case "maxMode":
          case "minMode":
            $scope.datepickerOptions[key] ? $scope.$watch(function() {
                return $scope.datepickerOptions[key];
            }, function(value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key], 
                ("minMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || "maxMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) && ($scope.datepickerMode = self[key], 
                $scope.datepickerOptions.datepickerMode = self[key]);
            }) : self[key] = $scope[key] = datepickerConfig[key] || null;
        }
    }), $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    $scope.disabled = angular.isDefined($attrs.disabled) || !1, angular.isDefined($attrs.ngDisabled) && watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
        $scope.disabled = disabled, self.refreshView();
    })), $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelOptions = extractOptions(ngModelCtrl), $scope.datepickerOptions.initDate ? (self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption("timezone")) || new Date(), 
        $scope.$watch("datepickerOptions.initDate", function(initDate) {
            initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid) && (self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption("timezone")), 
            self.refreshView());
        })) : self.activeDate = new Date();
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
        this.activeDate = isNaN(date) ? dateParser.fromTimezone(new Date(), ngModelOptions.getOption("timezone")) : dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")), 
        ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
            isValid ? this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")) : $datepickerSuppressError || $log.error('Datepicker directive: "ng-model" value must be a Date object');
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            $scope.selectedDt = null, this._refreshView(), $scope.activeDt && ($scope.activeDateId = $scope.activeDt.uid);
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            date = dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")), ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.getOption("timezone"));
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.getOption("timezone"));
        var time = this.compare(date, today), dt = {
            date: date,
            label: dateParser.filter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            past: 0 > time,
            current: 0 === time,
            future: time > 0,
            customClass: this.customClass(date) || null
        };
        return model && 0 === this.compare(date, model) && ($scope.selectedDt = dt), self.activeDate && 0 === this.compare(dt.date, self.activeDate) && ($scope.activeDt = dt), 
        dt;
    }, this.isDisabled = function(date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption("timezone")) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), dt = dateParser.toTimezone(dt, ngModelOptions.getOption("timezone")), 
            ngModelCtrl.$setViewValue(dt), ngModelCtrl.$render();
        } else self.activeDate = date, setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]), 
        $scope.$emit("uib:datepicker.mode");
        $scope.$broadcast("uib:datepicker.focus");
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || (setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]), 
        $scope.$emit("uib:datepicker.mode"));
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("uib:datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey && !$scope.disabled) if (evt.preventDefault(), 
        self.shortcutPropagation || evt.stopPropagation(), "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate);
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : $scope.toggleMode("up" === key ? 1 : -1);
    }, $element.on("keydown", function(evt) {
        $scope.$apply(function() {
            $scope.keydown(evt);
        });
    }), $scope.$on("$destroy", function() {
        for (;watchListeners.length; ) watchListeners.shift()();
    });
} ]).controller("UibDaypickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getDaysInMonth(year, month) {
        return 1 !== month || year % 4 !== 0 || year % 100 === 0 && year % 400 !== 0 ? DAYS_IN_MONTH[month] : 29;
    }
    function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
    }
    var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    this.step = {
        months: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), scope.showWeeks = ctrl.showWeeks, ctrl.refreshView();
    }, this.getDates = function(startDate, n) {
        for (var date, dates = new Array(n), current = new Date(startDate), i = 0; n > i; ) date = new Date(current), 
        dates[i++] = date, current.setDate(current.getDate() + 1);
        return dates;
    }, this._refreshView = function() {
        var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
        numDisplayedFromPreviousMonth > 0 && firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        for (var days = this.getDates(firstDate, 42), i = 0; 42 > i; i++) days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + "-" + i
        });
        scope.labels = new Array(7);
        for (var j = 0; 7 > j; j++) scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, "EEEE")
        };
        if (scope.title = dateFilter(this.activeDate, this.formatDayTitle), scope.rows = this.split(days, 7), 
        scope.showWeeks) {
            scope.weekNumbers = [];
            for (var thursdayIndex = (11 - this.startingDay) % 7, numWeeks = scope.rows.length, curWeek = 0; numWeeks > curWeek; curWeek++) scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()), _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getDate();
        if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
            var month = this.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
            this.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()));
        this.activeDate.setDate(date);
    };
} ]).controller("UibMonthpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    this.step = {
        years: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), ctrl.refreshView();
    }, this._refreshView = function() {
        for (var date, months = new Array(12), year = this.activeDate.getFullYear(), i = 0; 12 > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(year, i, 1), months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle), scope.rows = this.split(months, this.monthColumns), 
        scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth()), _date2 = new Date(date2.getFullYear(), date2.getMonth());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getMonth();
        if ("left" === key) date -= 1; else if ("up" === key) date -= this.monthColumns; else if ("right" === key) date += 1; else if ("down" === key) date += this.monthColumns; else if ("pageup" === key || "pagedown" === key) {
            var year = this.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
            this.activeDate.setFullYear(year);
        } else "home" === key ? date = 0 : "end" === key && (date = 11);
        this.activeDate.setMonth(date);
    };
} ]).controller("UibYearpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
    }
    var columns, range;
    this.element = $element, this.yearpickerInit = function() {
        columns = this.yearColumns, range = this.yearRows * columns, this.step = {
            years: range
        };
    }, this._refreshView = function() {
        for (var date, years = new Array(range), i = 0, start = getStartingYear(this.activeDate.getFullYear()); range > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(start + i, 0, 1), years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = this.split(years, columns), 
        scope.columns = columns;
    }, this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getFullYear();
        "left" === key ? date -= 1 : "up" === key ? date -= columns : "right" === key ? date += 1 : "down" === key ? date += columns : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * range : "home" === key ? date = getStartingYear(this.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(this.activeDate.getFullYear()) + range - 1), 
        this.activeDate.setFullYear(date);
    };
} ]).directive("uibDatepicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/datepicker.html";
        },
        scope: {
            datepickerOptions: "=?"
        },
        require: [ "uibDatepicker", "^ngModel" ],
        restrict: "A",
        controller: "UibDatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("uibDaypicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/day.html";
        },
        require: [ "^uibDatepicker", "uibDaypicker" ],
        restrict: "A",
        controller: "UibDaypickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibMonthpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/month.html";
        },
        require: [ "^uibDatepicker", "uibMonthpicker" ],
        restrict: "A",
        controller: "UibMonthpickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibYearpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/year.html";
        },
        require: [ "^uibDatepicker", "uibYearpicker" ],
        restrict: "A",
        controller: "UibYearpickerController",
        link: function(scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]), ctrl.yearpickerInit(), ctrl.refreshView();
        }
    };
}), angular.module("ui.bootstrap.position", []).factory("$uibPosition", [ "$document", "$window", function($document, $window) {
    var SCROLLBAR_WIDTH, BODY_SCROLLBAR_WIDTH, OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
    }, PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
    }, BODY_REGEX = /(HTML|BODY)/;
    return {
        getRawNode: function(elem) {
            return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
            return value = parseFloat(value), isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
            function isStaticPositioned(el) {
                return "static" === ($window.getComputedStyle(el).position || "static");
            }
            elem = this.getRawNode(elem);
            for (var offsetParent = elem.offsetParent || $document[0].documentElement; offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
            return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
            if (isBody) {
                if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                    var bodyElem = $document.find("body");
                    bodyElem.addClass("uib-position-body-scrollbar-measure"), BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth, 
                    BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0, 
                    bodyElem.removeClass("uib-position-body-scrollbar-measure");
                }
                return BODY_SCROLLBAR_WIDTH;
            }
            if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                $document.find("body").append(scrollElem), SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth, 
                SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0, scrollElem.remove();
            }
            return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
            elem = this.getRawNode(elem);
            var elemStyle = $window.getComputedStyle(elem), paddingRight = this.parseStyle(elemStyle.paddingRight), paddingBottom = this.parseStyle(elemStyle.paddingBottom), scrollParent = this.scrollParent(elem, !1, !0), scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));
            return {
                scrollbarWidth: scrollbarWidth,
                widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                right: paddingRight + scrollbarWidth,
                originalRight: paddingRight,
                heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                bottom: paddingBottom + scrollbarWidth,
                originalBottom: paddingBottom
            };
        },
        isScrollable: function(elem, includeHidden) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, elemStyle = $window.getComputedStyle(elem);
            return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, documentEl = $document[0].documentElement, elemStyle = $window.getComputedStyle(elem);
            if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) return elem;
            var excludeStatic = "absolute" === elemStyle.position, scrollParent = elem.parentElement || documentEl;
            if (scrollParent === documentEl || "fixed" === elemStyle.position) return documentEl;
            for (;scrollParent.parentElement && scrollParent !== documentEl; ) {
                var spStyle = $window.getComputedStyle(scrollParent);
                if (excludeStatic && "static" !== spStyle.position && (excludeStatic = !1), !excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) break;
                scrollParent = scrollParent.parentElement;
            }
            return scrollParent;
        },
        position: function(elem, includeMagins) {
            elem = this.getRawNode(elem);
            var elemOffset = this.offset(elem);
            if (includeMagins) {
                var elemStyle = $window.getComputedStyle(elem);
                elemOffset.top -= this.parseStyle(elemStyle.marginTop), elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
            }
            var parent = this.offsetParent(elem), parentOffset = {
                top: 0,
                left: 0
            };
            return parent !== $document[0].documentElement && (parentOffset = this.offset(parent), 
            parentOffset.top += parent.clientTop - parent.scrollTop, parentOffset.left += parent.clientLeft - parent.scrollLeft), 
            {
                width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                top: Math.round(elemOffset.top - parentOffset.top),
                left: Math.round(elemOffset.left - parentOffset.left)
            };
        },
        offset: function(elem) {
            elem = this.getRawNode(elem);
            var elemBCR = elem.getBoundingClientRect();
            return {
                width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
            };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
            elem = this.getRawNode(elem), includePadding = includePadding !== !1 ? !0 : !1;
            var elemBCR = elem.getBoundingClientRect(), offsetBCR = {
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }, offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem), offsetParentBCR = offsetParent.getBoundingClientRect();
            if (offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop, offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft, 
            offsetParent === $document[0].documentElement && (offsetBCR.top += $window.pageYOffset, 
            offsetBCR.left += $window.pageXOffset), offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight, 
            offsetBCR.right = offsetBCR.left + offsetParent.clientWidth, includePadding) {
                var offsetParentStyle = $window.getComputedStyle(offsetParent);
                offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop), offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom), 
                offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft), offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
            }
            return {
                top: Math.round(elemBCR.top - offsetBCR.top),
                bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                left: Math.round(elemBCR.left - offsetBCR.left),
                right: Math.round(offsetBCR.right - elemBCR.right)
            };
        },
        parsePlacement: function(placement) {
            var autoPlace = PLACEMENT_REGEX.auto.test(placement);
            return autoPlace && (placement = placement.replace(PLACEMENT_REGEX.auto, "")), placement = placement.split("-"), 
            placement[0] = placement[0] || "top", PLACEMENT_REGEX.primary.test(placement[0]) || (placement[0] = "top"), 
            placement[1] = placement[1] || "center", PLACEMENT_REGEX.secondary.test(placement[1]) || (placement[1] = "center"), 
            autoPlace ? placement[2] = !0 : placement[2] = !1, placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
            hostElem = this.getRawNode(hostElem), targetElem = this.getRawNode(targetElem);
            var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop("offsetWidth"), targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop("offsetHeight");
            placement = this.parsePlacement(placement);
            var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem), targetElemPos = {
                top: 0,
                left: 0,
                placement: ""
            };
            if (placement[2]) {
                var viewportOffset = this.viewportOffset(hostElem, appendToBody), targetElemStyle = $window.getComputedStyle(targetElem), adjustedSize = {
                    width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                    height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                };
                if (placement[0] = "top" === placement[0] && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? "bottom" : "bottom" === placement[0] && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? "top" : "left" === placement[0] && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? "right" : "right" === placement[0] && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? "left" : placement[0], 
                placement[1] = "top" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? "bottom" : "bottom" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? "top" : "left" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? "right" : "right" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? "left" : placement[1], 
                "center" === placement[1]) if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                    viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? placement[1] = "left" : viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left && (placement[1] = "right");
                } else {
                    var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                    viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? placement[1] = "top" : viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top && (placement[1] = "bottom");
                }
            }
            switch (placement[0]) {
              case "top":
                targetElemPos.top = hostElemPos.top - targetHeight;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left - targetWidth;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width;
            }
            switch (placement[1]) {
              case "top":
                targetElemPos.top = hostElemPos.top;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                break;

              case "center":
                PLACEMENT_REGEX.vertical.test(placement[0]) ? targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2 : targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            return targetElemPos.top = Math.round(targetElemPos.top), targetElemPos.left = Math.round(targetElemPos.left), 
            targetElemPos.placement = "center" === placement[1] ? placement[0] : placement[0] + "-" + placement[1], 
            targetElemPos;
        },
        adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
            return -1 !== placementClasses.indexOf("top") && initialHeight !== currentHeight ? {
                top: containerPosition.top - currentHeight + "px"
            } : void 0;
        },
        positionArrow: function(elem, placement) {
            elem = this.getRawNode(elem);
            var innerElem = elem.querySelector(".tooltip-inner, .popover-inner");
            if (innerElem) {
                var isTooltip = angular.element(innerElem).hasClass("tooltip-inner"), arrowElem = isTooltip ? elem.querySelector(".tooltip-arrow") : elem.querySelector(".arrow");
                if (arrowElem) {
                    var arrowCss = {
                        top: "",
                        bottom: "",
                        left: "",
                        right: ""
                    };
                    if (placement = this.parsePlacement(placement), "center" === placement[1]) return void angular.element(arrowElem).css(arrowCss);
                    var borderProp = "border-" + placement[0] + "-width", borderWidth = $window.getComputedStyle(arrowElem)[borderProp], borderRadiusProp = "border-";
                    borderRadiusProp += PLACEMENT_REGEX.vertical.test(placement[0]) ? placement[0] + "-" + placement[1] : placement[1] + "-" + placement[0], 
                    borderRadiusProp += "-radius";
                    var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                    switch (placement[0]) {
                      case "top":
                        arrowCss.bottom = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "bottom":
                        arrowCss.top = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "left":
                        arrowCss.right = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "right":
                        arrowCss.left = isTooltip ? "0" : "-" + borderWidth;
                    }
                    arrowCss[placement[1]] = borderRadius, angular.element(arrowElem).css(arrowCss);
                }
            }
        }
    };
} ]), angular.module("ui.bootstrap.datepickerPopup", [ "ui.bootstrap.datepicker", "ui.bootstrap.position" ]).value("$datepickerPopupLiteralWarning", !0).constant("uibDatepickerPopupConfig", {
    altInputFormats: [],
    appendToBody: !1,
    clearText: "Clear",
    closeOnDateSelection: !0,
    closeText: "Done",
    currentText: "Today",
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "uib/template/datepickerPopup/popup.html",
    datepickerTemplateUrl: "uib/template/datepicker/datepicker.html",
    html5Types: {
        date: "yyyy-MM-dd",
        "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
        month: "yyyy-MM"
    },
    onOpenFocus: !0,
    showButtonBar: !0,
    placement: "auto bottom-left"
}).controller("UibDatepickerPopupController", [ "$scope", "$element", "$attrs", "$compile", "$log", "$parse", "$window", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", "uibDatepickerConfig", "$datepickerPopupLiteralWarning", function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
    function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) for (var i = 0; i < altInputFormats.length; i++) if (date = dateParser.parse(viewValue, altInputFormats[i], $scope.date), 
        !isNaN(date)) return date;
        return date;
    }
    function parseDate(viewValue) {
        if (angular.isNumber(viewValue) && (viewValue = new Date(viewValue)), !viewValue) return null;
        if (angular.isDate(viewValue) && !isNaN(viewValue)) return viewValue;
        if (angular.isString(viewValue)) {
            var date = parseDateString(viewValue);
            if (!isNaN(date)) return dateParser.toTimezone(date, ngModelOptions.getOption("timezone"));
        }
        return ngModelOptions.getOption("allowInvalid") ? viewValue : void 0;
    }
    function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        return $attrs.ngRequired || value ? (angular.isNumber(value) && (value = new Date(value)), 
        value ? angular.isDate(value) && !isNaN(value) ? !0 : angular.isString(value) ? !isNaN(parseDateString(value)) : !1 : !0) : !0;
    }
    function documentClickBind(event) {
        if ($scope.isOpen || !$scope.disabled) {
            var popup = $popup[0], dpContainsTarget = $element[0].contains(event.target), popupContainsTarget = void 0 !== popup.contains && popup.contains(event.target);
            !$scope.isOpen || dpContainsTarget || popupContainsTarget || $scope.$apply(function() {
                $scope.isOpen = !1;
            });
        }
    }
    function inputKeydownBind(evt) {
        27 === evt.which && $scope.isOpen ? (evt.preventDefault(), evt.stopPropagation(), 
        $scope.$apply(function() {
            $scope.isOpen = !1;
        }), $element[0].focus()) : 40 !== evt.which || $scope.isOpen || (evt.preventDefault(), 
        evt.stopPropagation(), $scope.$apply(function() {
            $scope.isOpen = !0;
        }));
    }
    function positionPopup() {
        if ($scope.isOpen) {
            var dpElement = angular.element($popup[0].querySelector(".uib-datepicker-popup")), placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement, position = $position.positionElements($element, dpElement, placement, appendToBody);
            dpElement.css({
                top: position.top + "px",
                left: position.left + "px"
            }), dpElement.hasClass("uib-position-measure") && dpElement.removeClass("uib-position-measure");
        }
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        return angular.version.minor < 6 ? (ngModelOptions = angular.isObject(ngModelCtrl.$options) ? ngModelCtrl.$options : {
            timezone: null
        }, ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }) : ngModelOptions = ngModelCtrl.$options, ngModelOptions;
    }
    var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, isHtml5DateInput = !1, watchListeners = [];
    this.init = function(_ngModel_) {
        if (ngModel = _ngModel_, ngModelOptions = extractOptions(ngModel), closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, 
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody, 
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus, 
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl, 
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl, 
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats, 
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
        datepickerPopupConfig.html5Types[$attrs.type] ? (dateFormat = datepickerPopupConfig.html5Types[$attrs.type], 
        isHtml5DateInput = !0) : (dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup, 
        $attrs.$observe("uibDatepickerPopup", function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat && (dateFormat = newDateFormat, ngModel.$modelValue = null, 
            !dateFormat)) throw new Error("uibDatepickerPopup must have a date format specified.");
        })), !dateFormat) throw new Error("uibDatepickerPopup must have a date format specified.");
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) throw new Error("HTML5 date input types do not support custom formats.");
        popupEl = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), 
        popupEl.attr({
            "ng-model": "date",
            "ng-change": "dateSelection(date)",
            "template-url": datepickerPopupTemplateUrl
        }), datepickerEl = angular.element(popupEl.children()[0]), datepickerEl.attr("template-url", datepickerTemplateUrl), 
        $scope.datepickerOptions || ($scope.datepickerOptions = {}), isHtml5DateInput && "month" === $attrs.type && ($scope.datepickerOptions.datepickerMode = "month", 
        $scope.datepickerOptions.minMode = "month"), datepickerEl.attr("datepicker-options", "datepickerOptions"), 
        isHtml5DateInput ? ngModel.$formatters.push(function(value) {
            return $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption("timezone")), 
            value;
        }) : (ngModel.$$parserName = "date", ngModel.$validators.date = validator, ngModel.$parsers.unshift(parseDate), 
        ngModel.$formatters.push(function(value) {
            return ngModel.$isEmpty(value) ? ($scope.date = value, value) : (angular.isNumber(value) && (value = new Date(value)), 
            $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption("timezone")), 
            dateParser.filter($scope.date, dateFormat));
        })), ngModel.$viewChangeListeners.push(function() {
            $scope.date = parseDateString(ngModel.$viewValue);
        }), $element.on("keydown", inputKeydownBind), $popup = $compile(popupEl)($scope), 
        popupEl.remove(), appendToBody ? $document.find("body").append($popup) : $element.after($popup), 
        $scope.$on("$destroy", function() {
            for ($scope.isOpen === !0 && ($rootScope.$$phase || $scope.$apply(function() {
                $scope.isOpen = !1;
            })), $popup.remove(), $element.off("keydown", inputKeydownBind), $document.off("click", documentClickBind), 
            scrollParentEl && scrollParentEl.off("scroll", positionPopup), angular.element($window).off("resize", positionPopup); watchListeners.length; ) watchListeners.shift()();
        });
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
    }, $scope.isDisabled = function(date) {
        "today" === date && (date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption("timezone")));
        var dates = {};
        return angular.forEach([ "minDate", "maxDate" ], function(key) {
            $scope.datepickerOptions[key] ? angular.isDate($scope.datepickerOptions[key]) ? dates[key] = new Date($scope.datepickerOptions[key]) : ($datepickerPopupLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], "medium"))) : dates[key] = null;
        }), $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
    }, $scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }, $scope.dateSelection = function(dt) {
        $scope.date = dt;
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
        $element.val(date), ngModel.$setViewValue(date), closeOnDateSelection && ($scope.isOpen = !1, 
        $element[0].focus());
    }, $scope.keydown = function(evt) {
        27 === evt.which && (evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus());
    }, $scope.select = function(date, evt) {
        if (evt.stopPropagation(), "today" === date) {
            var today = new Date();
            angular.isDate($scope.date) ? (date = new Date($scope.date), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : (date = dateParser.fromTimezone(today, ngModelOptions.getOption("timezone")), 
            date.setHours(0, 0, 0, 0));
        }
        $scope.dateSelection(date);
    }, $scope.close = function(evt) {
        evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus();
    }, $scope.disabled = angular.isDefined($attrs.disabled) || !1, $attrs.ngDisabled && watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
        $scope.disabled = disabled;
    })), $scope.$watch("isOpen", function(value) {
        value ? $scope.disabled ? $scope.isOpen = !1 : $timeout(function() {
            positionPopup(), onOpenFocus && $scope.$broadcast("uib:datepicker.focus"), $document.on("click", documentClickBind);
            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
            appendToBody || $position.parsePlacement(placement)[2] ? (scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element)), 
            scrollParentEl && scrollParentEl.on("scroll", positionPopup)) : scrollParentEl = null, 
            angular.element($window).on("resize", positionPopup);
        }, 0, !1) : ($document.off("click", documentClickBind), scrollParentEl && scrollParentEl.off("scroll", positionPopup), 
        angular.element($window).off("resize", positionPopup));
    }), $scope.$on("uib:datepicker.mode", function() {
        $timeout(positionPopup, 0, !1);
    });
} ]).directive("uibDatepickerPopup", function() {
    return {
        require: [ "ngModel", "uibDatepickerPopup" ],
        controller: "UibDatepickerPopupController",
        scope: {
            datepickerOptions: "=?",
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@"
        },
        link: function(scope, element, attrs, ctrls) {
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
}).directive("uibDatepickerPopupWrap", function() {
    return {
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepickerPopup/popup.html";
        }
    };
}), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", [ "$timeout", function($timeout) {
    return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
            var self = this, args = Array.prototype.slice.call(arguments);
            timeoutPromise && $timeout.cancel(timeoutPromise), timeoutPromise = $timeout(function() {
                callback.apply(self, args);
            }, debounceTime);
        };
    };
} ]), angular.module("ui.bootstrap.multiMap", []).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    map[key] || (map[key] = []), map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (values) {
                        var idx = values.indexOf(value);
                        -1 !== idx && values.splice(idx, 1), values.length || delete map[key];
                    }
                }
            };
        }
    };
}), angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.multiMap", "ui.bootstrap.position" ]).constant("uibDropdownConfig", {
    appendToOpenClass: "uib-dropdown-open",
    openClass: "open"
}).service("uibDropdownService", [ "$document", "$rootScope", "$$multiMap", function($document, $rootScope, $$multiMap) {
    var openScope = null, openedContainers = $$multiMap.createNew();
    this.isOnlyOpen = function(dropdownScope, appendTo) {
        var openedDropdowns = openedContainers.get(appendTo);
        if (openedDropdowns) {
            var openDropdown = openedDropdowns.reduce(function(toClose, dropdown) {
                return dropdown.scope === dropdownScope ? dropdown : toClose;
            }, {});
            if (openDropdown) return 1 === openedDropdowns.length;
        }
        return !1;
    }, this.open = function(dropdownScope, element, appendTo) {
        if (openScope || $document.on("click", closeDropdown), openScope && openScope !== dropdownScope && (openScope.isOpen = !1), 
        openScope = dropdownScope, appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openedScopes = openedDropdowns.map(function(dropdown) {
                    return dropdown.scope;
                });
                -1 === openedScopes.indexOf(dropdownScope) && openedContainers.put(appendTo, {
                    scope: dropdownScope
                });
            } else openedContainers.put(appendTo, {
                scope: dropdownScope
            });
        }
    }, this.close = function(dropdownScope, element, appendTo) {
        if (openScope === dropdownScope && ($document.off("click", closeDropdown), $document.off("keydown", this.keybindFilter), 
        openScope = null), appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {
                    return dropdown.scope === dropdownScope ? dropdown : toClose;
                }, {});
                dropdownToClose && openedContainers.remove(appendTo, dropdownToClose);
            }
        }
    };
    var closeDropdown = function(evt) {
        if (openScope && openScope.isOpen && !(evt && "disabled" === openScope.getAutoClose() || evt && 3 === evt.which)) {
            var toggleElement = openScope.getToggleElement();
            if (!(evt && toggleElement && toggleElement[0].contains(evt.target))) {
                var dropdownElement = openScope.getDropdownElement();
                evt && "outsideClick" === openScope.getAutoClose() && dropdownElement && dropdownElement[0].contains(evt.target) || (openScope.focusToggleElement(), 
                openScope.isOpen = !1, $rootScope.$$phase || openScope.$apply());
            }
        }
    };
    this.keybindFilter = function(evt) {
        if (openScope) {
            var dropdownElement = openScope.getDropdownElement(), toggleElement = openScope.getToggleElement(), dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target), toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            27 === evt.which ? (evt.stopPropagation(), openScope.focusToggleElement(), closeDropdown()) : openScope.isKeynavEnabled() && -1 !== [ 38, 40 ].indexOf(evt.which) && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted) && (evt.preventDefault(), 
            evt.stopPropagation(), openScope.focusDropdownEntry(evt.which));
        }
    };
} ]).controller("UibDropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    function removeDropdownMenu() {
        $element.append(self.dropdownMenu);
    }
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, keynavEnabled = !1, body = $document.find("body");
    $element.addClass("dropdown"), this.init = function() {
        $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), keynavEnabled = angular.isDefined($attrs.keyboardNav);
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen, angular.isFunction(setIsOpen) && setIsOpen(scope, scope.isOpen), 
        scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : $element.find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            angular.isNumber(self.selectedOption) ? self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : self.selectedOption = 0;
            break;

          case 38:
            angular.isNumber(self.selectedOption) ? self.selectedOption = 0 === self.selectedOption ? 0 : self.selectedOption - 1 : self.selectedOption = elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        var appendTo = null, appendToBody = !1;
        if (angular.isDefined($attrs.dropdownAppendTo)) {
            var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
            appendToEl && (appendTo = angular.element(appendToEl));
        }
        if (angular.isDefined($attrs.dropdownAppendToBody)) {
            var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
            appendToBodyValue !== !1 && (appendToBody = !0);
        }
        if (appendToBody && !appendTo && (appendTo = body), appendTo && self.dropdownMenu && (isOpen ? (appendTo.append(self.dropdownMenu), 
        $element.on("$destroy", removeDropdownMenu)) : ($element.off("$destroy", removeDropdownMenu), 
        removeDropdownMenu())), appendTo && self.dropdownMenu) {
            var css, rightalign, scrollbarPadding, pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), scrollbarWidth = 0;
            if (css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right"), rightalign ? (css.left = "auto", 
            scrollbarPadding = $position.scrollbarPadding(appendTo), scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarWidth = scrollbarPadding.scrollbarWidth), 
            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), !appendToBody) {
                var appendOffset = $position.offset(appendTo);
                css.top = pos.top - appendOffset.top + "px", rightalign ? css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop("offsetWidth")) + "px" : css.left = pos.left - appendOffset.left + "px";
            }
            self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element, dropdownOpenClass = appendTo ? appendToOpenClass : openClass, hasOpenClass = openContainer.hasClass(dropdownOpenClass), isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);
        if (hasOpenClass === !isOpen) {
            var toggleClass;
            toggleClass = appendTo ? isOnlyOpen ? "removeClass" : "addClass" : isOpen ? "addClass" : "removeClass", 
            $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {
                angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                    open: !!isOpen
                });
            });
        }
        if (isOpen) self.dropdownMenuTemplateUrl ? $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl, $document.on("keydown", uibDropdownService.keybindFilter);
            });
        }) : $document.on("keydown", uibDropdownService.keybindFilter), scope.focusToggleElement(), 
        uibDropdownService.open(scope, $element, appendTo); else {
            if (uibDropdownService.close(scope, $element, appendTo), self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    });
} ]).directive("uibDropdown", function() {
    return {
        controller: "UibDropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
}).directive("uibDropdownMenu", function() {
    return {
        restrict: "A",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
}).directive("uibDropdownToggle", function() {
    return {
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.on("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.off("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key === stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key === stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.pop();
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.multiMap", "ui.bootstrap.stackedMap", "ui.bootstrap.position" ]).provider("$uibResolve", function() {
    var resolve = this;
    this.resolver = null, this.setResolver = function(resolver) {
        this.resolver = resolver;
    }, this.$get = [ "$injector", "$q", function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {
            resolve: function(invocables, locals, parent, self) {
                if (resolver) return resolver.resolve(invocables, locals, parent, self);
                var promises = [];
                return angular.forEach(invocables, function(value) {
                    angular.isFunction(value) || angular.isArray(value) ? promises.push($q.resolve($injector.invoke(value))) : angular.isString(value) ? promises.push($q.resolve($injector.get(value))) : promises.push($q.resolve(value));
                }), $q.all(promises).then(function(resolves) {
                    var resolveObj = {}, resolveIter = 0;
                    return angular.forEach(invocables, function(value, key) {
                        resolveObj[key] = resolves[resolveIter++];
                    }), resolveObj;
                });
            }
        };
    } ];
}).directive("uibModalBackdrop", [ "$animate", "$injector", "$uibModalStack", function($animate, $injector, $modalStack) {
    function linkFn(scope, element, attrs) {
        attrs.modalInClass && ($animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            scope.modalOptions.animation ? $animate.removeClass(element, attrs.modalInClass).then(done) : done();
        }));
    }
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("uibModalWindow", [ "$uibModalStack", "$q", "$animateCss", "$document", function($modalStack, $q, $animateCss, $document) {
    return {
        scope: {
            index: "@"
        },
        restrict: "A",
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "uib/template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowTopClass || ""), scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            scope.$$postDigest(function() {
                modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start(), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done);
                })), $q.when(animationPromise).then(function() {
                    var modal = $modalStack.getTop();
                    if (modal && $modalStack.modalRendered(modal.key), !$document[0].activeElement || !element[0].contains($document[0].activeElement)) {
                        var inputWithAutofocus = element[0].querySelector("[autofocus]");
                        inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                    }
                });
            });
        }
    };
} ]).directive("uibModalAnimationClass", function() {
    return {
        compile: function(tElement, tAttrs) {
            tAttrs.modalAnimation && tElement.addClass(tAttrs.uibModalAnimationClass);
        }
    };
}).directive("uibModalTransclude", [ "$animate", function($animate) {
    return {
        link: function(scope, element, attrs, controller, transclude) {
            transclude(scope.$parent, function(clone) {
                element.empty(), $animate.enter(clone, element);
            });
        }
    };
} ]).factory("$uibModalStack", [ "$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
    function snake_case(name) {
        var separator = "-";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    }
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex > -1 && topModalIndex > topBackdropIndex && (topBackdropIndex = topModalIndex), 
        topBackdropIndex;
    }
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value, appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance), previousTopOpenedModal = openedWindows.top(), 
        previousTopOpenedModal && (topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10)), 
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            var areAnyOpen = openedClasses.hasKey(modalBodyClass);
            appendToElement.toggleClass(modalBodyClass, areAnyOpen), !areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarPadding.originalRight ? appendToElement.css({
                paddingRight: scrollbarPadding.originalRight + "px"
            }) : appendToElement.css({
                paddingRight: ""
            }), scrollbarPadding = null), toggleTopWindowClass(!0);
        }, modalWindow.closedDeferred), checkRemoveBackdrop(), elementToReceiveFocus && elementToReceiveFocus.focus ? elementToReceiveFocus.focus() : appendToElement.focus && appendToElement.focus();
    }
    function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        openedWindows.length() > 0 && (modalWindow = openedWindows.top().value, modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || "", toggleSwitch));
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 === backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, $animate.leave(domEl).then(function() {
                done && done(), domEl.remove(), closedDeferred && closedDeferred.resolve();
            }), scope.$destroy());
        }
        var asyncDeferred, asyncPromise = null, setIsAsync = function() {
            return asyncDeferred || (asyncDeferred = $q.defer(), asyncPromise = asyncDeferred.promise), 
            function() {
                asyncDeferred.resolve();
            };
        };
        return scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync), $q.when(asyncPromise).then(afterAnimating);
    }
    function keydownListener(evt) {
        if (evt.isDefaultPrevented()) return evt;
        var modal = openedWindows.top();
        if (modal) switch (evt.which) {
          case 27:
            modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press");
            }));
            break;

          case 9:
            var list = $modalStack.loadFocusElementList(modal), focusChanged = !1;
            evt.shiftKey ? ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) && (focusChanged = $modalStack.focusLastFocusableElement(list)) : $modalStack.isFocusInLastItem(evt, list) && (focusChanged = $modalStack.focusFirstFocusableElement(list)), 
            focusChanged && (evt.preventDefault(), evt.stopPropagation());
        }
    }
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    function unhideBackgroundElements() {
        Array.prototype.forEach.call(document.querySelectorAll("[" + ARIA_HIDDEN_ATTRIBUTE_NAME + "]"), function(hiddenEl) {
            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10), newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount), newHiddenCount || (hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 
            hiddenEl.removeAttribute("aria-hidden"));
        });
    }
    var backdropDomEl, backdropScope, scrollbarPadding, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), openedClasses = $$multiMap.createNew(), $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    }, topModalIndex = 0, previousTopOpenedModal = null, ARIA_HIDDEN_ATTRIBUTE_NAME = "data-bootstrap-modal-aria-hidden-count", tabbableSelector = "a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]", SNAKE_CASE_REGEXP = /[A-Z]/g;
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.on("keydown", keydownListener), $rootScope.$on("$destroy", function() {
        $document.off("keydown", keydownListener);
    }), $modalStack.open = function(modalInstance, modal) {
        function applyAriaHidden(el) {
            function getSiblings(el) {
                var children = el.parent() ? el.parent().children() : [];
                return Array.prototype.filter.call(children, function(child) {
                    return child !== el[0];
                });
            }
            if (el && "BODY" !== el[0].tagName) return getSiblings(el).forEach(function(sibling) {
                var elemIsAlreadyHidden = "true" === sibling.getAttribute("aria-hidden"), ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);
                ariaHiddenCount || (ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0), sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1), 
                sibling.setAttribute("aria-hidden", "true");
            }), applyAriaHidden(el.parent());
        }
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(!1), previousTopOpenedModal = openedWindows.top(), openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            closedDeferred: modal.closedDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass,
            windowTopClass: modal.windowTopClass,
            animation: modal.animation,
            appendTo: modal.appendTo
        }), openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.modalOptions = modal, backdropScope.index = currBackdropIndex, backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), 
        backdropDomEl.attr({
            "class": "modal-backdrop",
            "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}",
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }), modal.backdropClass && backdropDomEl.addClass(modal.backdropClass), modal.animation && backdropDomEl.attr("modal-animation", "true"), 
        $compile(backdropDomEl)(backdropScope), $animate.enter(backdropDomEl, appendToElement), 
        $uibPosition.isScrollable(appendToElement) && (scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement), 
        scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && appendToElement.css({
            paddingRight: scrollbarPadding.right + "px"
        })));
        var content;
        modal.component ? (content = document.createElement(snake_case(modal.component.name)), 
        content = angular.element(content), content.attr({
            resolve: "$resolve",
            "modal-instance": "$uibModalInstance",
            close: "$close($value)",
            dismiss: "$dismiss($value)"
        })) : content = modal.content, topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
            "class": "modal",
            "template-url": modal.windowTemplateUrl,
            "window-top-class": modal.windowTopClass,
            role: "dialog",
            "aria-labelledby": modal.ariaLabelledBy,
            "aria-describedby": modal.ariaDescribedBy,
            size: modal.size,
            index: topModalIndex,
            animate: "animate",
            "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}",
            tabindex: -1,
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }).append(content), modal.windowClass && angularDomEl.addClass(modal.windowClass), 
        modal.animation && angularDomEl.attr("modal-animation", "true"), appendToElement.addClass(modalBodyClass), 
        modal.scope && (modal.scope.$$topModalIndex = topModalIndex), $animate.enter($compile(angularDomEl)(modal.scope), appendToElement), 
        openedWindows.top().value.modalDomEl = angularDomEl, openedWindows.top().value.modalOpener = modalOpener, 
        applyAriaHidden(angularDomEl);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, result, !0) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, reason, !1) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal && this.dismiss(topModal.key, reason); ) topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && modalWindow.value.renderDeferred.resolve();
    }, $modalStack.focusFirstFocusableElement = function(list) {
        return list.length > 0 ? (list[0].focus(), !0) : !1;
    }, $modalStack.focusLastFocusableElement = function(list) {
        return list.length > 0 ? (list[list.length - 1].focus(), !0) : !1;
    }, $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
            var modalDomEl = modalWindow.value.modalDomEl;
            if (modalDomEl && modalDomEl.length) return (evt.target || evt.srcElement) === modalDomEl[0];
        }
        return !1;
    }, $modalStack.isFocusInFirstItem = function(evt, list) {
        return list.length > 0 ? (evt.target || evt.srcElement) === list[0] : !1;
    }, $modalStack.isFocusInLastItem = function(evt, list) {
        return list.length > 0 ? (evt.target || evt.srcElement) === list[list.length - 1] : !1;
    }, $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
                var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                return elements ? Array.prototype.filter.call(elements, function(element) {
                    return isVisible(element);
                }) : elements;
            }
        }
    }, $modalStack;
} ]).provider("$uibModal", function() {
    var $modalProvider = {
        options: {
            animation: !0,
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            var $modal = {}, promiseChain = null;
            return $modal.getPromiseChain = function() {
                return promiseChain;
            }, $modal.open = function(modalOptions) {
                function resolveWithTemplate() {
                    return templateAndResolvePromise;
                }
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalClosedDeferred = $q.defer(), modalRenderDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    closed: modalClosedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                modalOptions.appendTo = modalOptions.appendTo || $document.find("body").eq(0), !modalOptions.appendTo.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM.");
                if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of component or template or templateUrl options is required.");
                var templateAndResolvePromise;
                templateAndResolvePromise = modalOptions.component ? $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null)) : $q.all([ getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null) ]);
                var samePromise;
                return samePromise = promiseChain = $q.all([ promiseChain ]).then(resolveWithTemplate, resolveWithTemplate).then(function(tplAndVars) {
                    function constructLocals(obj, template, instanceOnScope, injectable) {
                        obj.$scope = modalScope, obj.$scope.$resolve = {}, instanceOnScope ? obj.$scope.$uibModalInstance = modalInstance : obj.$uibModalInstance = modalInstance;
                        var resolves = template ? tplAndVars[1] : tplAndVars;
                        angular.forEach(resolves, function(value, key) {
                            injectable && (obj[key] = value), obj.$scope.$resolve[key] = value;
                        });
                    }
                    var providedScope = modalOptions.scope || $rootScope, modalScope = providedScope.$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss, 
                    modalScope.$on("$destroy", function() {
                        modalScope.$$uibDestructionScheduled || modalScope.$dismiss("$uibUnscheduledDestruction");
                    });
                    var ctrlInstance, ctrlInstantiate, modal = {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        closedDeferred: modalClosedDeferred,
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowTopClass: modalOptions.windowTopClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        ariaLabelledBy: modalOptions.ariaLabelledBy,
                        ariaDescribedBy: modalOptions.ariaDescribedBy,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass,
                        appendTo: modalOptions.appendTo
                    }, component = {}, ctrlLocals = {};
                    modalOptions.component ? (constructLocals(component, !1, !0, !1), component.name = modalOptions.component, 
                    modal.component = component) : modalOptions.controller && (constructLocals(ctrlLocals, !0, !1, !0), 
                    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, !0, modalOptions.controllerAs), 
                    modalOptions.controllerAs && modalOptions.bindToController && (ctrlInstance = ctrlInstantiate.instance, 
                    ctrlInstance.$close = modalScope.$close, ctrlInstance.$dismiss = modalScope.$dismiss, 
                    angular.extend(ctrlInstance, {
                        $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope)), ctrlInstance = ctrlInstantiate(), angular.isFunction(ctrlInstance.$onInit) && ctrlInstance.$onInit()), 
                    modalOptions.component || (modal.content = tplAndVars[0]), $modalStack.open(modalInstance, modal), 
                    modalOpenedDeferred.resolve(!0);
                }, function(reason) {
                    modalOpenedDeferred.reject(reason), modalResultDeferred.reject(reason);
                })["finally"](function() {
                    promiseChain === samePromise && (promiseChain = null);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.paging", []).factory("uibPaging", [ "$parse", function($parse) {
    return {
        create: function(ctrl, $scope, $attrs) {
            ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop, 
            ctrl.ngModelCtrl = {
                $setViewValue: angular.noop
            }, ctrl._watchers = [], ctrl.init = function(ngModelCtrl, config) {
                ctrl.ngModelCtrl = ngModelCtrl, ctrl.config = config, ngModelCtrl.$render = function() {
                    ctrl.render();
                }, $attrs.itemsPerPage ? ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
                    ctrl.itemsPerPage = parseInt(value, 10), $scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage();
                })) : ctrl.itemsPerPage = config.itemsPerPage, $scope.$watch("totalItems", function(newTotal, oldTotal) {
                    (angular.isDefined(newTotal) || newTotal !== oldTotal) && ($scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage());
                });
            }, ctrl.calculateTotalPages = function() {
                var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                return Math.max(totalPages || 0, 1);
            }, ctrl.render = function() {
                $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
            }, $scope.selectPage = function(page, evt) {
                evt && evt.preventDefault();
                var clickAllowed = !$scope.ngDisabled || !evt;
                clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages && (evt && evt.target && evt.target.blur(), 
                ctrl.ngModelCtrl.$setViewValue(page), ctrl.ngModelCtrl.$render());
            }, $scope.getText = function(key) {
                return $scope[key + "Text"] || ctrl.config[key + "Text"];
            }, $scope.noPrevious = function() {
                return 1 === $scope.page;
            }, $scope.noNext = function() {
                return $scope.page === $scope.totalPages;
            }, ctrl.updatePage = function() {
                ctrl.setNumPages($scope.$parent, $scope.totalPages), $scope.page > $scope.totalPages ? $scope.selectPage($scope.totalPages) : ctrl.ngModelCtrl.$render();
            }, $scope.$on("$destroy", function() {
                for (;ctrl._watchers.length; ) ctrl._watchers.shift()();
            });
        }
    };
} ]), angular.module("ui.bootstrap.pager", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPagerController", [ "$scope", "$attrs", "uibPaging", "uibPagerConfig", function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align, 
    uibPaging.create(this, $scope, $attrs);
} ]).constant("uibPagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("uibPager", [ "uibPagerConfig", function(uibPagerConfig) {
    return {
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "uibPager", "?ngModel" ],
        restrict: "A",
        controller: "UibPagerController",
        controllerAs: "pager",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pager/pager.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pager");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
    };
} ]), angular.module("ui.bootstrap.pagination", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPaginationController", [ "$scope", "$attrs", "$parse", "uibPaging", "uibPaginationConfig", function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    function makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    function getPages(currentPage, totalPages) {
        var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
        isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
        endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
        startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
        endPage = Math.min(startPage + maxSize - 1, totalPages)));
        for (var number = startPage; endPage >= number; number++) {
            var page = makePage(number, pageLabel(number), number === currentPage);
            pages.push(page);
        }
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!boundaryLinkNumbers || startPage > 3) {
                    var previousPageSet = makePage(startPage - 1, "...", !1);
                    pages.unshift(previousPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (3 === startPage) {
                        var secondPageLink = makePage(2, "2", !1);
                        pages.unshift(secondPageLink);
                    }
                    var firstPageLink = makePage(1, "1", !1);
                    pages.unshift(firstPageLink);
                }
            }
            if (totalPages > endPage) {
                if (!boundaryLinkNumbers || totalPages - 2 > endPage) {
                    var nextPageSet = makePage(endPage + 1, "...", !1);
                    pages.push(nextPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) {
                        var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, !1);
                        pages.push(secondToLastPageLink);
                    }
                    var lastPageLink = makePage(totalPages, totalPages, !1);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    var ctrl = this, maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
        return $scope.$parent.$eval($attrs.pageLabel, {
            $page: idx
        });
    } : angular.identity;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks, 
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks, 
    $attrs.$set("role", "menu"), uibPaging.create(this, $scope, $attrs), $attrs.maxSize && ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10), ctrl.render();
    }));
    var originalRender = this.render;
    this.render = function() {
        originalRender(), $scope.page > 0 && $scope.page <= $scope.totalPages && ($scope.pages = getPages($scope.page, $scope.totalPages));
    };
} ]).constant("uibPaginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    boundaryLinkNumbers: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0,
    forceEllipses: !1
}).directive("uibPagination", [ "$parse", "uibPaginationConfig", function($parse, uibPaginationConfig) {
    return {
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "uibPagination", "?ngModel" ],
        restrict: "A",
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pagination/pagination.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pagination");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.stackedMap" ]).provider("$uibTooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        placementClassPrefix: "",
        animation: !0,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: !1
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        outsideClick: "outsideClick",
        focus: "blur",
        none: ""
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        function keypressListener(e) {
            if (27 === e.which) {
                var last = openedTooltips.top();
                last && (last.value.close(), last = null);
            }
        }
        var openedTooltips = $$stackedMap.createNew();
        return $document.on("keyup", keypressListener), $rootScope.$on("$destroy", function() {
            $document.off("keyup", keypressListener);
        }), function(ttType, prefix, defaultTriggerShow, options) {
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" "), hide = show.map(function(trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }
            options = angular.extend({}, defaultOptions, globalOptions, options);
            var directiveName = snake_case(ttType), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup uib-title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'origin-scope="origScope" class="uib-position-measure ' + prefix + '" tooltip-animation-class="fade"uib-tooltip-classes ng-class="{ in: isOpen }" ></div>';
            return {
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs, tooltipCtrl) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (cancelHide(), prepareTooltip(), 
                            ttScope.popupDelay ? showTimeout || (showTimeout = $timeout(show, ttScope.popupDelay, !1)) : show());
                        }
                        function hideTooltipBind() {
                            cancelShow(), ttScope.popupCloseDelay ? hideTimeout || (hideTimeout = $timeout(hide, ttScope.popupCloseDelay, !1)) : hide();
                        }
                        function show() {
                            return cancelShow(), cancelHide(), ttScope.content ? (createTooltip(), void ttScope.$evalAsync(function() {
                                ttScope.isOpen = !0, assignIsOpen(!0), positionTooltip();
                            })) : angular.noop;
                        }
                        function cancelShow() {
                            showTimeout && ($timeout.cancel(showTimeout), showTimeout = null), positionTimeout && ($timeout.cancel(positionTimeout), 
                            positionTimeout = null);
                        }
                        function hide() {
                            ttScope && ttScope.$evalAsync(function() {
                                ttScope && (ttScope.isOpen = !1, assignIsOpen(!1), ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 150, !1)) : removeTooltip());
                            });
                        }
                        function cancelHide() {
                            hideTimeout && ($timeout.cancel(hideTimeout), hideTimeout = null), transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null);
                        }
                        function createTooltip() {
                            tooltip || (tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip);
                            }), openedTooltips.add(ttScope, {
                                close: hide
                            }), prepObservers());
                        }
                        function removeTooltip() {
                            cancelShow(), cancelHide(), unregisterObservers(), tooltip && (tooltip.remove(), 
                            tooltip = null, adjustmentTimeout && $timeout.cancel(adjustmentTimeout)), openedTooltips.remove(ttScope), 
                            tooltipLinkedScope && (tooltipLinkedScope.$destroy(), tooltipLinkedScope = null);
                        }
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + "Title"], contentParse ? ttScope.content = contentParse(scope) : ttScope.content = attrs[ttType], 
                            ttScope.popupClass = attrs[prefix + "Class"], ttScope.placement = angular.isDefined(attrs[prefix + "Placement"]) ? attrs[prefix + "Placement"] : options.placement;
                            var placement = $position.parsePlacement(ttScope.placement);
                            lastPlacement = placement[1] ? placement[0] + "-" + placement[1] : placement[0];
                            var delay = parseInt(attrs[prefix + "PopupDelay"], 10), closeDelay = parseInt(attrs[prefix + "PopupCloseDelay"], 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay, ttScope.popupCloseDelay = isNaN(closeDelay) ? options.popupCloseDelay : closeDelay;
                        }
                        function assignIsOpen(isOpen) {
                            isOpenParse && angular.isFunction(isOpenParse.assign) && isOpenParse.assign(scope, isOpen);
                        }
                        function prepObservers() {
                            observers.length = 0, contentParse ? (observers.push(scope.$watch(contentParse, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide();
                            })), observers.push(tooltipLinkedScope.$watch(function() {
                                repositionScheduled || (repositionScheduled = !0, tooltipLinkedScope.$$postDigest(function() {
                                    repositionScheduled = !1, ttScope && ttScope.isOpen && positionTooltip();
                                }));
                            }))) : observers.push(attrs.$observe(ttType, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen ? hide() : positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Title", function(val) {
                                ttScope.title = val, ttScope.isOpen && positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Placement", function(val) {
                                ttScope.placement = val ? val : options.placement, ttScope.isOpen && positionTooltip();
                            }));
                        }
                        function unregisterObservers() {
                            observers.length && (angular.forEach(observers, function(observer) {
                                observer();
                            }), observers.length = 0);
                        }
                        function bodyHideTooltipBind(e) {
                            ttScope && ttScope.isOpen && tooltip && (element[0].contains(e.target) || tooltip[0].contains(e.target) || hideTooltipBind());
                        }
                        function hideOnEscapeKey(e) {
                            27 === e.which && hideTooltipBind();
                        }
                        function prepTriggers() {
                            var showTriggers = [], hideTriggers = [], val = scope.$eval(attrs[prefix + "Trigger"]);
                            unregisterTriggers(), angular.isObject(val) ? (Object.keys(val).forEach(function(key) {
                                showTriggers.push(key), hideTriggers.push(val[key]);
                            }), triggers = {
                                show: showTriggers,
                                hide: hideTriggers
                            }) : triggers = getTriggers(val), "none" !== triggers.show && triggers.show.forEach(function(trigger, idx) {
                                "outsideClick" === trigger ? (element.on("click", toggleTooltipBind), $document.on("click", bodyHideTooltipBind)) : trigger === triggers.hide[idx] ? element.on(trigger, toggleTooltipBind) : trigger && (element.on(trigger, showTooltipBind), 
                                element.on(triggers.hide[idx], hideTooltipBind)), element.on("keypress", hideOnEscapeKey);
                            });
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, showTimeout, hideTimeout, positionTimeout, adjustmentTimeout, lastPlacement, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), repositionScheduled = !1, isOpenParse = angular.isDefined(attrs[prefix + "IsOpen"]) ? $parse(attrs[prefix + "IsOpen"]) : !1, contentParse = options.useContentExp ? $parse(attrs[ttType]) : !1, observers = [], positionTooltip = function() {
                            tooltip && tooltip.html() && (positionTimeout || (positionTimeout = $timeout(function() {
                                var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody), initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                tooltip.css({
                                    top: ttPosition.top + "px",
                                    left: ttPosition.left + "px"
                                });
                                var placementClasses = ttPosition.placement.split("-");
                                tooltip.hasClass(placementClasses[0]) || (tooltip.removeClass(lastPlacement.split("-")[0]), 
                                tooltip.addClass(placementClasses[0])), tooltip.hasClass(options.placementClassPrefix + ttPosition.placement) || (tooltip.removeClass(options.placementClassPrefix + lastPlacement), 
                                tooltip.addClass(options.placementClassPrefix + ttPosition.placement)), adjustmentTimeout = $timeout(function() {
                                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                    adjustment && tooltip.css(adjustment), adjustmentTimeout = null;
                                }, 0, !1), tooltip.hasClass("uib-position-measure") ? ($position.positionArrow(tooltip, ttPosition.placement), 
                                tooltip.removeClass("uib-position-measure")) : lastPlacement !== ttPosition.placement && $position.positionArrow(tooltip, ttPosition.placement), 
                                lastPlacement = ttPosition.placement, positionTimeout = null;
                            }, 0, !1)));
                        };
                        ttScope.origScope = scope, ttScope.isOpen = !1, ttScope.contentExp = function() {
                            return ttScope.content;
                        }, attrs.$observe("disabled", function(val) {
                            val && cancelShow(), val && ttScope.isOpen && hide();
                        }), isOpenParse && scope.$watch(isOpenParse, function(val) {
                            ttScope && !val === ttScope.isOpen && toggleTooltipBind();
                        });
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                "outsideClick" === trigger ? element.off("click", toggleTooltipBind) : (element.off(trigger, showTooltipBind), 
                                element.off(trigger, toggleTooltipBind)), element.off("keypress", hideOnEscapeKey);
                            }), triggers.hide.forEach(function(trigger) {
                                "outsideClick" === trigger ? $document.off("click", bodyHideTooltipBind) : element.off(trigger, hideTooltipBind);
                            });
                        };
                        prepTriggers();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal, appendKey = prefix + "AppendToBody";
                        appendToBodyVal = appendKey in attrs && void 0 === attrs[appendKey] ? !0 : scope.$eval(attrs[appendKey]), 
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, 
                        scope.$on("$destroy", function() {
                            unregisterTriggers(), removeTooltip(), ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("uibTooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("uibTooltipClasses", [ "$uibPosition", function($uibPosition) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            if (scope.placement) {
                var position = $uibPosition.parsePlacement(scope.placement);
                element.addClass(position[0]);
            }
            scope.popupClass && element.addClass(scope.popupClass), scope.animation && element.addClass(attrs.tooltipAnimationClass);
        }
    };
} ]).directive("uibTooltipPopup", function() {
    return {
        restrict: "A",
        scope: {
            content: "@"
        },
        templateUrl: "uib/template/tooltip/tooltip-popup.html"
    };
}).directive("uibTooltip", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
} ]).directive("uibTooltipTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-template-popup.html"
    };
}).directive("uibTooltipTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("uibTooltipHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-html-popup.html"
    };
}).directive("uibTooltipHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("uibPopoverTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/popover/popover-template.html"
    };
}).directive("uibPopoverTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            uibTitle: "@"
        },
        templateUrl: "uib/template/popover/popover-html.html"
    };
}).directive("uibPopoverHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverPopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            content: "@"
        },
        templateUrl: "uib/template/popover/popover.html"
    };
}).directive("uibPopover", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("uibProgressConfig", {
    animate: !0,
    max: 100
}).controller("UibProgressController", [ "$scope", "$attrs", "uibProgressConfig", function($scope, $attrs, progressConfig) {
    function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
    }
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = getMaxOrDefault(), this.addBar = function(bar, element, attrs) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.max = getMaxOrDefault(), bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar", 
        bar.$watch("value", function(value) {
            bar.recalculatePercentage();
        }), bar.recalculatePercentage = function() {
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return bar.percent = +(100 * bar.value / bar.max).toFixed(2), total + bar.percent;
            }, 0);
            totalPercentage > 100 && (bar.percent -= totalPercentage - 100);
        }, bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1), this.bars.forEach(function(bar) {
            bar.recalculatePercentage();
        });
    }, $scope.$watch("maxParam", function(maxParam) {
        self.bars.forEach(function(bar) {
            bar.max = getMaxOrDefault(), bar.recalculatePercentage();
        });
    });
} ]).directive("uibProgress", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        require: "uibProgress",
        scope: {
            maxParam: "=?max"
        },
        templateUrl: "uib/template/progressbar/progress.html"
    };
}).directive("uibBar", function() {
    return {
        replace: !0,
        transclude: !0,
        require: "^uibProgress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
}).directive("uibProgressbar", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        scope: {
            value: "=",
            maxParam: "=?max",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), {
                title: attrs.title
            });
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("uibRatingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: !0,
    titles: [ "one", "two", "three", "four", "five" ]
}).controller("UibRatingController", [ "$scope", "$attrs", "uibRatingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    }, self = this;
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.push(function(value) {
            return angular.isNumber(value) && value << 0 !== value && (value = Math.round(value)), 
            value;
        }), this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff, 
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
        }, states[i]);
        return states;
    }, this.getTitle = function(index) {
        return index >= this.titles.length ? index + 1 : this.titles[index];
    }, $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
            ngModelCtrl.$setViewValue(newViewValue), ngModelCtrl.$render();
        }
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.title = self.getTitle($scope.value - 1);
    };
} ]).directive("uibRating", function() {
    return {
        require: [ "uibRating", "ngModel" ],
        restrict: "A",
        scope: {
            readonly: "=?readOnly",
            onHover: "&",
            onLeave: "&"
        },
        controller: "UibRatingController",
        templateUrl: "uib/template/rating/rating.html",
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", [ "$scope", function($scope) {
    function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].index === index) return i;
    }
    var oldIndex, ctrl = this;
    ctrl.tabs = [], ctrl.select = function(index, evt) {
        if (!destroyed) {
            var previousIndex = findTabIndex(oldIndex), previousSelected = ctrl.tabs[previousIndex];
            if (previousSelected) {
                if (previousSelected.tab.onDeselect({
                    $event: evt,
                    $selectedIndex: index
                }), evt && evt.isDefaultPrevented()) return;
                previousSelected.tab.active = !1;
            }
            var selected = ctrl.tabs[index];
            selected ? (selected.tab.onSelect({
                $event: evt
            }), selected.tab.active = !0, ctrl.active = selected.index, oldIndex = selected.index) : !selected && angular.isDefined(oldIndex) && (ctrl.active = null, 
            oldIndex = null);
        }
    }, ctrl.addTab = function(tab) {
        if (ctrl.tabs.push({
            tab: tab,
            index: tab.index
        }), ctrl.tabs.sort(function(t1, t2) {
            return t1.index > t2.index ? 1 : t1.index < t2.index ? -1 : 0;
        }), tab.index === ctrl.active || !angular.isDefined(ctrl.active) && 1 === ctrl.tabs.length) {
            var newActiveIndex = findTabIndex(tab.index);
            ctrl.select(newActiveIndex);
        }
    }, ctrl.removeTab = function(tab) {
        for (var index, i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
        }
        if (ctrl.tabs[index].index === ctrl.active) {
            var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
            ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
    }, $scope.$watch("tabset.active", function(val) {
        angular.isDefined(val) && val !== oldIndex && ctrl.select(findTabIndex(val));
    });
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = !0;
    });
} ]).directive("uibTabset", function() {
    return {
        transclude: !0,
        replace: !0,
        scope: {},
        bindToController: {
            active: "=?",
            type: "@"
        },
        controller: "UibTabsetController",
        controllerAs: "tabset",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tabset.html";
        },
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
}).directive("uibTab", [ "$parse", function($parse) {
    return {
        require: "^uibTabset",
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tab.html";
        },
        transclude: !0,
        scope: {
            heading: "@",
            index: "=?",
            classes: "@?",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        controllerAs: "tab",
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            scope.disabled = !1, attrs.disable && scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
            }), angular.isUndefined(attrs.index) && (tabsetCtrl.tabs && tabsetCtrl.tabs.length ? scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
                return t.index;
            })) + 1 : scope.index = 0), angular.isUndefined(attrs.classes) && (scope.classes = ""), 
            scope.select = function(evt) {
                if (!scope.disabled) {
                    for (var index, i = 0; i < tabsetCtrl.tabs.length; i++) if (tabsetCtrl.tabs[i].tab === scope) {
                        index = i;
                        break;
                    }
                    tabsetCtrl.select(index, evt);
                }
            }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            }), scope.$transcludeFn = transclude;
        }
    };
} ]).directive("uibTabHeadingTransclude", function() {
    return {
        restrict: "A",
        require: "^uibTab",
        link: function(scope, elm) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
}).directive("uibTabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("uib-tab-heading") || node.hasAttribute("data-uib-tab-heading") || node.hasAttribute("x-uib-tab-heading") || "uib-tab-heading" === node.tagName.toLowerCase() || "data-uib-tab-heading" === node.tagName.toLowerCase() || "x-uib-tab-heading" === node.tagName.toLowerCase() || "uib:tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^uibTabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("uibTimepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: !0,
    showSeconds: !1,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0,
    arrowkeys: !0,
    showSpinners: !0,
    templateUrl: "uib/template/timepicker/timepicker.html"
}).controller("UibTimepickerController", [ "$scope", "$element", "$attrs", "$parse", "$log", "$locale", "uibTimepickerConfig", function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = +$scope.hours, valid = $scope.showMeridian ? hours > 0 && 13 > hours : hours >= 0 && 24 > hours;
        return valid && "" !== $scope.hours ? ($scope.showMeridian && (12 === hours && (hours = 0), 
        $scope.meridian === meridians[1] && (hours += 12)), hours) : void 0;
    }
    function getMinutesFromTemplate() {
        var minutes = +$scope.minutes, valid = minutes >= 0 && 60 > minutes;
        return valid && "" !== $scope.minutes ? minutes : void 0;
    }
    function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && 60 > seconds ? seconds : void 0;
    }
    function pad(value, noPad) {
        return null === value ? "" : angular.isDefined(value) && value.toString().length < 2 && !noPad ? "0" + value : value.toString();
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        hoursModelCtrl && hoursModelCtrl.$setValidity("hours", !0), minutesModelCtrl && minutesModelCtrl.$setValidity("minutes", !0), 
        secondsModelCtrl && secondsModelCtrl.$setValidity("seconds", !0), ngModelCtrl.$setValidity("time", !0), 
        $scope.invalidHours = !1, $scope.invalidMinutes = !1, $scope.invalidSeconds = !1;
    }
    function updateTemplate(keyboardChange) {
        if (ngModelCtrl.$modelValue) {
            var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
            $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
            $scope.hours = "h" === keyboardChange ? hours : pad(hours, !padHours), "m" !== keyboardChange && ($scope.minutes = pad(minutes)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1], "s" !== keyboardChange && ($scope.seconds = pad(seconds)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        } else $scope.hours = null, $scope.minutes = null, $scope.seconds = null, $scope.meridian = meridians[0];
    }
    function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds), refresh();
    }
    function addMinutes(selected, minutes) {
        return addSeconds(selected, 60 * minutes);
    }
    function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + 1e3 * seconds), newDate = new Date(date);
        return newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds()), newDate;
    }
    function modelIsEmpty() {
        return (null === $scope.hours || "" === $scope.hours) && (null === $scope.minutes || "" === $scope.minutes) && (!$scope.showSeconds || $scope.showSeconds && (null === $scope.seconds || "" === $scope.seconds));
    }
    var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl, selected = new Date(), watchers = [], ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : !0;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0, $element.removeAttr("tabindex"), 
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.unshift(function(modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2);
        hoursModelCtrl = hoursInputEl.controller("ngModel"), minutesModelCtrl = minutesInputEl.controller("ngModel"), 
        secondsModelCtrl = secondsInputEl.controller("ngModel");
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        mousewheel && this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        arrowkeys && this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl), 
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
    }));
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
    }));
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? void 0 : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? void 0 : dt;
    }));
    var disabled = !1;
    $attrs.ngDisabled && watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
    })), $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, 60 * hourStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, 60 * -hourStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementSeconds = function() {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementSeconds = function() {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noToggleMeridian = function() {
        return selected.getHours() < 12 ? disabled || addMinutes(selected, 720) > max : disabled || addMinutes(selected, -720) < min;
    };
    var secondStep = timepickerConfig.secondStep;
    $attrs.secondStep && watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
    })), $scope.showSeconds = timepickerConfig.showSeconds, $attrs.showSeconds && watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
    })), $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    })), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        }), secondsInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds()), 
            e.preventDefault();
        });
    }, this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementHours(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementHours(), $scope.$apply()));
        }), minutesInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementMinutes(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementMinutes(), $scope.$apply()));
        }), secondsInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementSeconds(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementSeconds(), $scope.$apply()));
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, $scope.updateMinutes = angular.noop, 
        void ($scope.updateSeconds = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours, 
            hoursModelCtrl && hoursModelCtrl.$setValidity("hours", !1)), angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes, 
            minutesModelCtrl && minutesModelCtrl.$setValidity("minutes", !1)), angular.isDefined(invalidSeconds) && ($scope.invalidSeconds = invalidSeconds, 
            secondsModelCtrl && secondsModelCtrl.$setValidity("seconds", !1));
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(hours) && angular.isDefined(minutes) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), min > selected || selected > max ? invalidate(!0) : refresh("h")) : invalidate(!0);
        }, hoursInputEl.on("blur", function(e) {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.hours || "" === $scope.hours ? invalidate(!0) : !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours, !padHours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(minutes) && angular.isDefined(hours) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), min > selected || selected > max ? invalidate(void 0, !0) : refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.on("blur", function(e) {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.minutes ? invalidate(void 0, !0) : !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        }), $scope.updateSeconds = function() {
            var seconds = getSecondsFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(seconds) ? (selected.setSeconds(seconds), 
            refresh("s")) : invalidate(void 0, void 0, !0);
        }, secondsInputEl.on("blur", function(e) {
            modelIsEmpty() ? makeValid() : !$scope.invalidSeconds && $scope.seconds < 10 && $scope.$apply(function() {
                $scope.seconds = pad($scope.seconds);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$viewValue;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        min > selected || selected > max ? (ngModelCtrl.$setValidity("time", !1), $scope.invalidHours = !0, 
        $scope.invalidMinutes = !0) : makeValid(), updateTemplate());
    }, $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners, 
    $scope.incrementHours = function() {
        $scope.noIncrementHours() || addSecondsToSelected(60 * hourStep * 60);
    }, $scope.decrementHours = function() {
        $scope.noDecrementHours() || addSecondsToSelected(60 * -hourStep * 60);
    }, $scope.incrementMinutes = function() {
        $scope.noIncrementMinutes() || addSecondsToSelected(60 * minuteStep);
    }, $scope.decrementMinutes = function() {
        $scope.noDecrementMinutes() || addSecondsToSelected(60 * -minuteStep);
    }, $scope.incrementSeconds = function() {
        $scope.noIncrementSeconds() || addSecondsToSelected(secondStep);
    }, $scope.decrementSeconds = function() {
        $scope.noDecrementSeconds() || addSecondsToSelected(-secondStep);
    }, $scope.toggleMeridian = function() {
        var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
        $scope.noToggleMeridian() || (angular.isDefined(minutes) && angular.isDefined(hours) ? addSecondsToSelected(720 * (selected.getHours() < 12 ? 60 : -60)) : $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0]);
    }, $scope.blur = function() {
        ngModelCtrl.$setTouched();
    }, $scope.$on("$destroy", function() {
        for (;watchers.length; ) watchers.shift()();
    });
} ]).directive("uibTimepicker", [ "uibTimepickerConfig", function(uibTimepickerConfig) {
    return {
        require: [ "uibTimepicker", "?^ngModel" ],
        restrict: "A",
        controller: "UibTimepickerController",
        controllerAs: "timepicker",
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.debounce", "ui.bootstrap.position" ]).factory("uibTypeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).controller("UibTypeaheadController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    function fireRecalculating() {
        scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), debouncedRecalculate();
    }
    function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top += element.prop("offsetHeight");
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        return angular.version.minor < 6 ? (ngModelOptions = ngModelCtrl.$options || {}, 
        ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }) : ngModelOptions = ngModelCtrl.$options, ngModelOptions;
    }
    var modelCtrl, ngModelOptions, HOT_KEYS = [ 9, 13, 27, 38, 40 ], eventDebounceTime = 200, minLength = originalScope.$eval(attrs.typeaheadMinLength);
    minLength || 0 === minLength || (minLength = 1), originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = newVal || 0 === newVal ? newVal : 1;
    });
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1;
    originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== !1;
    });
    var hasFocus, selected, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
        var evt = vals.$event;
        return 13 === evt.which || 9 === evt.which;
    }, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : !1, isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null, focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== !1, selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : !1, isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop, showHint = originalScope.$eval(attrs.typeaheadShowHint) || !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
        return angular.isFunction(parsedModel(originalScope)) && ngModelOptions.getOption("getterSetter") ? invokeModelSetter(scope, {
            $$$p: newValue
        }) : parsedModel.assign(scope, newValue);
    }, parserResult = typeaheadParser.parse(attrs.uibTypeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
    var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
    element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": !1,
        "aria-owns": popupId
    });
    var inputsContainer, hintInputElem;
    showHint && (inputsContainer = angular.element("<div></div>"), inputsContainer.css("position", "relative"), 
    element.after(inputsContainer), hintInputElem = element.clone(), hintInputElem.attr("placeholder", ""), 
    hintInputElem.attr("tabindex", "-1"), hintInputElem.val(""), hintInputElem.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "border-color": "transparent",
        "box-shadow": "none",
        opacity: 1,
        background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",
        color: "#999"
    }), element.css({
        position: "relative",
        "vertical-align": "top",
        "background-color": "transparent"
    }), hintInputElem.attr("id") && hintInputElem.removeAttr("id"), inputsContainer.append(hintInputElem), 
    hintInputElem.after(element));
    var popUpEl = angular.element("<div uib-typeahead-popup></div>");
    popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx, evt)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position",
        "assign-is-open": "assignIsOpen(isOpen)",
        debounce: "debounceUpdate"
    }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
    angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
    var resetHint = function() {
        showHint && hintInputElem.val("");
    }, resetMatches = function() {
        scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1), resetHint();
    }, getMatchId = function(index) {
        return popupId + "-option-" + index;
    };
    scope.$watch("activeIdx", function(index) {
        0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
    });
    var inputIsExactMatch = function(inputValue, index) {
        return scope.matches.length > index && inputValue ? inputValue.toUpperCase() === scope.matches[index].label.toUpperCase() : !1;
    }, getMatchesAsync = function(inputValue, evt) {
        var locals = {
            $viewValue: inputValue
        };
        isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                });
                if (scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                    scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(0, evt)), 
                showHint) {
                    var firstLabel = scope.matches[0].label;
                    angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase() ? hintInputElem.val(inputValue + firstLabel.slice(inputValue.length)) : hintInputElem.val("");
                }
            } else resetMatches(), isNoResultsSetter(originalScope, !0);
            onCurrentRequest && isLoadingSetter(originalScope, !1);
        }, function() {
            resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
        });
    };
    appendToBody && (angular.element($window).on("resize", fireRecalculating), $document.find("body").on("scroll", fireRecalculating));
    var debouncedRecalculate = $$debounce(function() {
        scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
    }, eventDebounceTime);
    scope.moveInProgress = !1, scope.query = void 0;
    var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
        }, waitTime);
    }, cancelPreviousTimeout = function() {
        timeoutPromise && $timeout.cancel(timeoutPromise);
    };
    resetMatches(), scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
    }, scope.select = function(activeIdx, evt) {
        var model, item, locals = {};
        selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
        model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
        modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals),
            $event: evt
        }), resetMatches(), scope.$eval(attrs.typeaheadFocusOnSelect) !== !1 && $timeout(function() {
            element[0].focus();
        }, 0, !1);
    }, element.on("keydown", function(evt) {
        if (0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which)) {
            var shouldSelect = isSelectEvent(originalScope, {
                $event: evt
            });
            if (-1 === scope.activeIdx && shouldSelect || 9 === evt.which && evt.shiftKey) return resetMatches(), 
            void scope.$digest();
            evt.preventDefault();
            var target;
            switch (evt.which) {
              case 27:
                evt.stopPropagation(), resetMatches(), originalScope.$digest();
                break;

              case 38:
                scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest(), target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], 
                target.parentNode.scrollTop = target.offsetTop;
                break;

              case 40:
                scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, scope.$digest(), 
                target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], target.parentNode.scrollTop = target.offsetTop;
                break;

              default:
                shouldSelect && scope.$apply(function() {
                    angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                        scope.select(scope.activeIdx, evt);
                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(scope.activeIdx, evt);
                });
            }
        }
    }), element.on("focus", function(evt) {
        hasFocus = !0, 0 !== minLength || modelCtrl.$viewValue || $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
    }), element.on("blur", function(evt) {
        isSelectOnBlur && scope.matches.length && -1 !== scope.activeIdx && !selected && (selected = !0, 
        scope.$apply(function() {
            angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur) ? $$debounce(function() {
                scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur) : scope.select(scope.activeIdx, evt);
        })), !isEditable && modelCtrl.$error.editable && (modelCtrl.$setViewValue(), scope.$apply(function() {
            modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0);
        }), element.val("")), hasFocus = !1, selected = !1;
    });
    var dismissClickHandler = function(evt) {
        element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
        $rootScope.$$phase || originalScope.$digest());
    };
    $document.on("click", dismissClickHandler), originalScope.$on("$destroy", function() {
        $document.off("click", dismissClickHandler), (appendToBody || appendTo) && $popup.remove(), 
        appendToBody && (angular.element($window).off("resize", fireRecalculating), $document.find("body").off("scroll", fireRecalculating)), 
        popUpEl.remove(), showHint && inputsContainer.remove();
    });
    var $popup = $compile(popUpEl)(scope);
    appendToBody ? $document.find("body").append($popup) : appendTo ? angular.element(appendTo).eq(0).append($popup) : element.after($popup), 
    this.init = function(_modelCtrl) {
        modelCtrl = _modelCtrl, ngModelOptions = extractOptions(modelCtrl), scope.debounceUpdate = $parse(ngModelOptions.getOption("debounce"))(originalScope), 
        modelCtrl.$parsers.unshift(function(inputValue) {
            return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
            scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
            cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
            null);
        }), modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue, emptyViewValue, locals = {};
            return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
            inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
            candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
            emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
        });
    };
} ]).directive("uibTypeahead", function() {
    return {
        controller: "UibTypeaheadController",
        require: [ "ngModel", "uibTypeahead" ],
        link: function(originalScope, element, attrs, ctrls) {
            ctrls[1].init(ctrls[0]);
        }
    };
}).directive("uibTypeaheadPopup", [ "$$debounce", function($$debounce) {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&",
            assignIsOpen: "&",
            debounce: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                var isDropdownOpen = scope.matches.length > 0;
                return scope.assignIsOpen({
                    isOpen: isDropdownOpen
                }), isDropdownOpen;
            }, scope.isActive = function(matchIdx) {
                return scope.active === matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx, evt) {
                var debounce = scope.debounce();
                angular.isNumber(debounce) || angular.isObject(debounce) ? $$debounce(function() {
                    scope.select({
                        activeIdx: activeIdx,
                        evt: evt
                    });
                }, angular.isNumber(debounce) ? debounce : debounce["default"]) : scope.select({
                    activeIdx: activeIdx,
                    evt: evt
                });
            };
        }
    };
} ]).directive("uibTypeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "uib/template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                var tplEl = angular.element(tplContent.trim());
                element.replaceWith(tplEl), $compile(tplEl)(scope);
            });
        }
    };
} ]).filter("uibTypeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("uib/template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html", '<div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n  <h4 class="panel-title">\n    <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading" ng-disabled="isDisabled" uib-tabindex-toggle><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n  </h4>\n</div>\n<div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n  <div class="panel-body" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html", '<div role="tablist" class="panel-group" ng-transclude></div>');
} ]), angular.module("uib/template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/alert/alert.html", '<button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n  <span aria-hidden="true">&times;</span>\n  <span class="sr-only">Close</span>\n</button>\n<div ng-transclude></div>\n');
} ]), angular.module("uib/template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html", '<div class="carousel-inner" ng-transclude></div>\n<a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n  <span class="sr-only">previous</span>\n</a>\n<a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n  <span class="sr-only">next</span>\n</a>\n<ol class="carousel-indicators" ng-show="slides.length > 1">\n  <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n    <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n  </li>\n</ol>\n');
} ]), angular.module("uib/template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html", '<div class="text-center" ng-transclude></div>\n');
} ]), angular.module("uib/template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/datepicker.html", '<div ng-switch="datepickerMode">\n  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n</div>\n');
} ]), angular.module("uib/template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepickerPopup/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepickerPopup/popup.html", '<ul role="presentation" class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n  <li ng-transclude></li>\n  <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n    </span>\n    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n  </li>\n</ul>\n');
} ]), angular.module("uib/template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n");
} ]), angular.module("uib/template/pager/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pager/pager.html", '<li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n');
} ]), angular.module("uib/template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html", '<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'first\')}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li role="menuitem" ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)" ng-disabled="ngDisabled&&!page.active" uib-tabindex-toggle>{{page.text}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'last\')}}</a></li>\n');
} ]), angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind="content"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner"\n  uib-tooltip-template-transclude="contentExp()"\n  tooltip-template-transclude-scope="originScope()"></div>\n');
} ]), angular.module("uib/template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind-html="contentExp()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content"\n      uib-tooltip-template-transclude="contentExp()"\n      tooltip-template-transclude-scope="originScope()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("uib/template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n');
} ]), angular.module("uib/template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html", '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>');
} ]), angular.module("uib/template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n</span>\n');
} ]), angular.module("uib/template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tab.html", '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("uib/template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane"\n         ng-repeat="tab in tabset.tabs"\n         ng-class="{active: tabset.active === tab.index}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("uib/template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html", '<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html", '<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n');
} ]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n');
} ]), angular.module("ui.bootstrap.carousel").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'), 
    angular.$$uibCarouselCss = !0;
}), angular.module("ui.bootstrap.datepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'), 
    angular.$$uibDatepickerCss = !0;
}), angular.module("ui.bootstrap.position").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), 
    angular.$$uibPositionCss = !0;
}), angular.module("ui.bootstrap.datepickerPopup").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'), 
    angular.$$uibDatepickerpopupCss = !0;
}), angular.module("ui.bootstrap.tooltip").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), 
    angular.$$uibTooltipCss = !0;
}), angular.module("ui.bootstrap.timepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-time input{width:50px;}</style>'), 
    angular.$$uibTimepickerCss = !0;
}), angular.module("ui.bootstrap.typeahead").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), 
    angular.$$uibTypeaheadCss = !0;
}), angular.module("fluro.socket", []), angular.module("fluro.socket").service("FluroSocket", [ "Fluro", "$rootScope", function(Fluro, $rootScope) {
    var socket, currentSocketID, controller = {}, currentAccount = (Fluro.apiURL, ""), listeners = [];
    return "undefined" != typeof io && (console.log("init fluro-socket"), socket = io(Fluro.apiURL, {
        transports: [ "websocket" ],
        upgrade: !1
    }), $rootScope.$watch("user.account._id", function() {
        var user = $rootScope.user;
        user ? user.account && user.account._id ? (currentAccount = user.account._id, controller.join(currentAccount)) : controller.leave(currentAccount) : currentAccount && controller.leave(currentAccount);
    })), controller.getSocketID = function() {
        return currentSocketID;
    }, controller.join = function(roomName) {
        socket && (socket.on("connect", function() {
            currentSocketID = socket.io.engine.id, console.log("websocket connected to " + roomName), 
            socket.emit("subscribe", {
                room: roomName
            });
        }), socket.on("reconnect", function() {
            currentSocketID = socket.io.engine.id, console.log("websocket reconnected to " + roomName), 
            socket.emit("subscribe", {
                room: roomName
            });
        }), socket.on("disconnect", function() {
            currentSocketID = null, console.log("websocket disconected");
        }), _.each(listeners, function(listener) {
            socket.on(listener);
        }));
    }, controller.leave = function(roomName) {
        socket && (console.log("leave", roomName), socket.emit("unsubscribe", {
            room: roomName
        }), socket.off("connect"), socket.off("reconnect"), socket.off("disconnect"), _.each(listeners, function(listener) {
            socket.off(listener);
        }));
    }, controller.emit = function(roomName, key, data) {
        socket && (console.log("Emit to room", roomName, socket), socket.emit(key, data));
    }, controller.on = function(event, callback) {
        var alreadyListening = _.find(listeners, function(listener) {
            var sameCallback = listener.callback == callback, sameEvent = listener.event == event;
            return sameCallback && sameEvent;
        });
        return alreadyListening ? console.log("websocket already listening for ", event) : (listeners.push({
            event: event,
            callback: callback
        }), void (socket && socket.on(event, callback)));
    }, controller.off = function(event, callback) {
        if (callback) {
            var match = _.find(listeners, function(listener) {
                var sameCallback = listener.callback == callback, sameEvent = listener.event == event;
                return sameCallback && sameEvent;
            });
            match && (_.pull(listeners, match), socket && socket.removeListener(event, callback));
        } else listeners = _.filter(listeners, function(listener) {
            return listener.event != event;
        }), socket && socket.off(event);
    }, controller;
} ]), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : "object" == typeof exports ? exports.apiCheck = factory() : root.apiCheck = factory();
}(this, function() {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _apiCheck = __webpack_require__(1), _apiCheck2 = _interopRequireDefault(_apiCheck);
        exports["default"] = _apiCheck2["default"], module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function getApiCheckInstance() {
            function apiCheck(api, args, output) {
                if (apiCheck.config.disabled || module.exports.globalConfig.disabled) return {
                    apiTypes: {},
                    argTypes: {},
                    passed: !0,
                    message: "",
                    failed: !1
                };
                checkApiCheckApi(arguments), Array.isArray(api) ? args = Array.prototype.slice.call(args) : (api = [ api ], 
                args = [ args ]);
                var messages = checkEnoughArgs(api, args);
                messages.length || (messages = checkApiWithArgs(api, args));
                var returnObject = getTypes(api, args);
                return returnObject.args = args, messages.length ? (returnObject.message = apiCheck.getErrorMessage(api, args, messages, output), 
                returnObject.failed = !0, returnObject.passed = !1) : (returnObject.message = "", 
                returnObject.failed = !1, returnObject.passed = !0), returnObject;
            }
            function checkApiCheckApi(checkApiArgs) {
                var api = checkApiArgs[0], args = checkApiArgs[1], isArrayOrArgs = Array.isArray(args) || args && "object" == typeof args && "number" == typeof args.length;
                if (Array.isArray(api) && !isArrayOrArgs) throw new Error(getErrorMessage(api, [ args ], [ "If an array is provided for the api, an array must be provided for the args as well." ], {
                    prefix: "apiCheck"
                }));
                var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);
                if (errors.length) {
                    var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {
                        prefix: "apiCheck"
                    });
                    apiCheck.handleErrorMessage(message, !0);
                }
            }
            function getApiCheck(shouldThrow) {
                return function(api, args, output) {
                    var result = apiCheck(api, args, output);
                    return apiCheck.handleErrorMessage(result.message, shouldThrow), result;
                };
            }
            function handleErrorMessage(message, shouldThrow) {
                if (shouldThrow && message) throw new Error(message);
                message && console.warn(message);
            }
            function getErrorMessage(api, args) {
                function getPrefix() {
                    var p = output.onlyPrefix;
                    return p || (p = ((gOut.prefix || "") + " " + (output.prefix || "")).trim()), p;
                }
                function getSuffix() {
                    var s = output.onlySuffix;
                    return s || (s = ((output.suffix || "") + " " + (gOut.suffix || "")).trim()), s;
                }
                function getUrl() {
                    var u = output.url;
                    return u || (u = gOut.docsBaseUrl && output.urlSuffix && ("" + gOut.docsBaseUrl + output.urlSuffix).trim()), 
                    u;
                }
                var messages = arguments.length <= 2 || void 0 === arguments[2] ? [] : arguments[2], output = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3], gOut = apiCheck.config.output || {}, prefix = getPrefix(), suffix = getSuffix(), url = getUrl(), message = "apiCheck failed! " + messages.join(", "), passedAndShouldHavePassed = "\n\n" + buildMessageFromApiAndArgs(api, args);
                return (prefix + " " + message + " " + suffix + " " + (url || "") + passedAndShouldHavePassed).trim();
            }
            function buildMessageFromApiAndArgs(api, args) {
                function replaceFunctionWithName(obj) {
                    each(obj, function(val, name) {
                        -1 === replacedItems.indexOf(val) && (replacedItems.push(val), "object" == typeof val ? replaceFunctionWithName(obj) : "function" == typeof val && (obj[name] = val.displayName || val.name || "anonymous function"));
                    });
                }
                function getObjectString(types) {
                    return types && types.length ? (types && 1 === types.length && (types = types[0]), 
                    stringify(types, null, 2)) : "nothing";
                }
                function generateMessage() {
                    var n = "\n", useS = !0;
                    args && 1 === args.length && (useS = "object" == typeof args[0] && null !== args[0] ? !!Object.keys(args[0]).length : !1);
                    var types = "type" + (useS ? "s" : ""), newLine = n + n;
                    return "You passed:" + n + passedArgs + newLine + ("With the " + types + ":" + n + argTypes + newLine) + ("The API calls for:" + n + apiTypes);
                }
                var _getTypes = getTypes(api, args), apiTypes = _getTypes.apiTypes, argTypes = _getTypes.argTypes, copy = Array.prototype.slice.call(args || []), replacedItems = [];
                replaceFunctionWithName(copy);
                var passedArgs = getObjectString(copy);
                return argTypes = getObjectString(argTypes), apiTypes = getObjectString(apiTypes), 
                generateMessage();
            }
            function getTypes(api, args) {
                api = arrayify(api), args = arrayify(args);
                var apiTypes = api.map(function(checker, index) {
                    var specified = module.exports.globalConfig.hasOwnProperty("verbose");
                    return getCheckerDisplay(checker, {
                        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,
                        obj: args[index],
                        addHelpers: !0
                    });
                }), argTypes = args.map(function(arg) {
                    return getArgDisplay(arg, []);
                });
                return {
                    argTypes: argTypes,
                    apiTypes: apiTypes
                };
            }
            var config = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], extraCheckers = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];
            apiCheckApiCheck && arguments.length && apiCheckApiCheck["throw"](apiCheckApis.getApiCheckInstanceCheckers, arguments, {
                prefix: "creating an apiCheck instance"
            });
            var additionalProperties = {
                "throw": getApiCheck(!0),
                warn: getApiCheck(!1),
                getErrorMessage: getErrorMessage,
                handleErrorMessage: handleErrorMessage,
                config: {
                    output: config.output || {
                        prefix: "",
                        suffix: "",
                        docsBaseUrl: ""
                    },
                    verbose: config.verbose || !1,
                    disabled: config.disabled || !1
                },
                utils: apiCheckUtil
            };
            each(additionalProperties, function(wrapper, name) {
                return apiCheck[name] = wrapper;
            });
            var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;
            return each(checkers.getCheckers(disabled), function(checker, name) {
                return apiCheck[name] = checker;
            }), each(extraCheckers, function(checker, name) {
                return apiCheck[name] = checker;
            }), apiCheck;
        }
        function checkApiWithArgs(api, args) {
            for (var messages = [], failed = !1, checkerIndex = 0, argIndex = 0, arg = void 0, checker = void 0, res = void 0, lastChecker = void 0, argName = void 0, argFailed = void 0, skipPreviousChecker = void 0; (checker = api[checkerIndex++]) && argIndex < args.length; ) arg = args[argIndex++], 
            argName = "Argument " + argIndex + (checker.isOptional ? " (optional)" : ""), res = checker(arg, "value", argName), 
            argFailed = isError(res), lastChecker = checkerIndex >= api.length, skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional, 
            argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker ? (failed = !0, 
            messages.push(getCheckerErrorMessage(res, checker, arg))) : argFailed && checker.isOptional ? argIndex-- : messages.push(t(argName) + " passed");
            return failed ? messages : [];
        }
        function checkerTypeType(checkerType, name, location) {
            var apiCheckDataChecker = checkers.shape({
                type: checkers.string,
                optional: checkers.bool
            }), asFunc = checkers.func.withProperties({
                __apiCheckData: apiCheckDataChecker
            }), asShape = checkers.shape({
                __apiCheckData: apiCheckDataChecker
            }), wrongShape = checkers.oneOfType([ asFunc, asShape ])(checkerType, name, location);
            return isError(wrongShape) ? wrongShape : "function" == typeof checkerType || checkerType.hasOwnProperty(checkerType.__apiCheckData.type) ? void 0 : getError(name, location, checkerTypeType.type);
        }
        function getCheckerErrorMessage(res, checker, val) {
            var checkerHelp = getCheckerHelp(checker, val);
            return checkerHelp = checkerHelp ? " - " + checkerHelp : "", res.message + checkerHelp;
        }
        function getCheckerHelp(_ref, val) {
            var help = _ref.help;
            return help ? ("function" == typeof help && (help = help(val)), help) : "";
        }
        function checkEnoughArgs(api, args) {
            var requiredArgs = api.filter(function(a) {
                return !a.isOptional;
            });
            return args.length < requiredArgs.length ? [ "Not enough arguments specified. Requires `" + requiredArgs.length + "`, you passed `" + args.length + "`" ] : [];
        }
        function getArgDisplay(arg, gottenArgs) {
            function hasKeys() {
                return arg && Object.keys(arg).length;
            }
            function getDisplayIfNotGotten() {
                return -1 !== gottenArgs.indexOf(arg) ? "[Circular]" : (gottenArgs.push(arg), getDisplay(arg, gottenArgs));
            }
            var cName = arg && arg.constructor && arg.constructor.name, type = typeOf(arg);
            if ("function" === type) {
                if (hasKeys()) {
                    var properties = stringify(getDisplayIfNotGotten());
                    return cName + " (with properties: " + properties + ")";
                }
                return cName;
            }
            return null === arg ? "null" : "array" !== type && "object" !== type ? type : hasKeys() ? getDisplayIfNotGotten() : cName;
        }
        function getDisplay(obj, gottenArgs) {
            var argDisplay = {};
            return each(obj, function(v, k) {
                return argDisplay[k] = getArgDisplay(v, gottenArgs);
            }), argDisplay;
        }
        function getApiCheckApis() {
            var os = checkers.string.optional, checkerFnChecker = checkers.func.withProperties({
                type: checkers.oneOfType([ checkers.string, checkerTypeType ]).optional,
                displayName: checkers.string.optional,
                shortType: checkers.string.optional,
                notOptional: checkers.bool.optional,
                notRequired: checkers.bool.optional
            }), getApiCheckInstanceCheckers = [ checkers.shape({
                output: checkers.shape({
                    prefix: checkers.string.optional,
                    suffix: checkers.string.optional,
                    docsBaseUrl: checkers.string.optional
                }).strict.optional,
                verbose: checkers.bool.optional,
                disabled: checkers.bool.optional
            }).strict.optional, checkers.objectOf(checkerFnChecker).optional ], checkApiCheckApi = [ checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({
                prefix: os,
                suffix: os,
                urlSuffix: os,
                onlyPrefix: os,
                onlySuffix: os,
                url: os
            }).strict.optional ];
            return {
                checkerFnChecker: checkerFnChecker,
                getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,
                checkApiCheckApi: checkApiCheckApi
            };
        }
        var stringify = __webpack_require__(2), apiCheckUtil = __webpack_require__(3), each = apiCheckUtil.each, isError = apiCheckUtil.isError, t = apiCheckUtil.t, arrayify = apiCheckUtil.arrayify, getCheckerDisplay = apiCheckUtil.getCheckerDisplay, typeOf = apiCheckUtil.typeOf, getError = apiCheckUtil.getError, checkers = __webpack_require__(4), apiCheckApis = getApiCheckApis();
        module.exports = getApiCheckInstance, module.exports.VERSION = "7.5.5", module.exports.utils = apiCheckUtil, 
        module.exports.globalConfig = {
            verbose: !1,
            disabled: !1
        };
        var apiCheckApiCheck = getApiCheckInstance({
            output: {
                prefix: "apiCheck"
            }
        });
        module.exports.internalChecker = apiCheckApiCheck, each(checkers, function(checker, name) {
            return module.exports[name] = checker;
        }), checkerTypeType.type = "function with __apiCheckData property and `${function.type}` property";
    }, function(module, exports) {
        function getSerialize(fn, decycle) {
            var seen = [], keys = [];
            return decycle = decycle || function(key, value) {
                return "[Circular " + getPath(value, seen, keys) + "]";
            }, function(key, value) {
                var ret = value;
                return "object" == typeof value && value && (-1 !== seen.indexOf(value) ? ret = decycle(key, value) : (seen.push(value), 
                keys.push(key))), fn && (ret = fn(key, ret)), ret;
            };
        }
        function getPath(value, seen, keys) {
            var index = seen.indexOf(value), path = [ keys[index] ];
            for (index--; index >= 0; index--) seen[index][path[0]] === value && (value = seen[index], 
            path.unshift(keys[index]));
            return "~" + path.join(".");
        }
        function stringify(obj, fn, spaces, decycle) {
            return JSON.stringify(obj, getSerialize(fn, decycle), spaces);
        }
        module.exports = stringify, stringify.getSerialize = getSerialize;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function copy(obj) {
            var type = typeOf(obj), daCopy = void 0;
            if ("array" === type) daCopy = []; else {
                if ("object" !== type) return obj;
                daCopy = {};
            }
            return each(obj, function(val, key) {
                daCopy[key] = val;
            }), daCopy;
        }
        function typeOf(obj) {
            return Array.isArray(obj) ? "array" : obj instanceof RegExp ? "object" : typeof obj;
        }
        function getCheckerDisplay(checker, options) {
            var display = void 0, short = options && options["short"];
            return display = short && checker.shortType ? checker.shortType : !short && "object" == typeof checker.type || "function" === checker.type ? getCheckerType(checker, options) : getCheckerType(checker, options) || checker.displayName || checker.name;
        }
        function getCheckerType(_ref, options) {
            var type = _ref.type;
            if ("function" == typeof type) {
                var __apiCheckData = type.__apiCheckData, typeTypes = type(options);
                type = _defineProperty({
                    __apiCheckData: __apiCheckData
                }, __apiCheckData.type, typeTypes);
            }
            return type;
        }
        function arrayify(obj) {
            return obj ? Array.isArray(obj) ? obj : [ obj ] : [];
        }
        function each(obj, iterator, context) {
            return Array.isArray(obj) ? eachArry(obj, iterator, context) : eachObj(obj, iterator, context);
        }
        function eachObj(obj, iterator, context) {
            var ret = void 0, hasOwn = Object.prototype.hasOwnProperty;
            for (var key in obj) if (hasOwn.call(obj, key) && (ret = iterator.call(context, obj[key], key, obj), 
            ret === !1)) return ret;
            return !0;
        }
        function eachArry(obj, iterator, context) {
            for (var ret = void 0, length = obj.length, i = 0; length > i; i++) if (ret = iterator.call(context, obj[i], i, obj), 
            ret === !1) return ret;
            return !0;
        }
        function isError(obj) {
            return obj instanceof Error;
        }
        function list(arry, join, finalJoin) {
            arry = arrayify(arry);
            var copy = arry.slice(), last = copy.pop();
            return 1 === copy.length && (join = " "), copy.join(join) + ("" + (copy.length ? join + finalJoin : "") + last);
        }
        function getError(name, location, checkerType) {
            "function" == typeof checkerType && (checkerType = checkerType({
                "short": !0
            }));
            var stringType = "object" != typeof checkerType ? checkerType : stringify(checkerType);
            return new Error(nAtL(name, location) + " must be " + t(stringType));
        }
        function nAtL(name, location) {
            var tName = t(name || "value"), tLocation = location ? " at " + t(location) : "";
            return "" + tName + tLocation;
        }
        function t(thing) {
            return "`" + thing + "`";
        }
        function undef(thing) {
            return "undefined" == typeof thing;
        }
        function setupChecker(checker, properties, disabled) {
            return disabled && (checker = getNoop(), checker.isNoop = !0), "string" == typeof checker.type && (checker.shortType = checker.type), 
            each(properties, function(prop, name) {
                return checker[name] = prop;
            }), checker.displayName || (checker.displayName = "apiCheck " + t(checker.shortType || checker.type || checker.name) + " type checker"), 
            checker.notRequired || (checker = getRequiredVersion(checker, disabled)), checker.notNullable || addNullable(checker, disabled), 
            checker.notOptional || addOptional(checker, disabled), checker;
        }
        function getRequiredVersion(checker, disabled) {
            var requiredChecker = disabled ? getNoop() : function(val, name, location, obj) {
                if (undef(val) && !checker.isOptional) {
                    var tLocation = location ? " in " + t(location) : "", type = getCheckerDisplay(checker, {
                        "short": !0
                    }), stringType = "object" != typeof type ? type : stringify(type);
                    return new Error("Required " + t(name) + " not specified" + tLocation + ". Must be " + t(stringType));
                }
                return checker(val, name, location, obj);
            };
            return copyProps(checker, requiredChecker), requiredChecker.originalChecker = checker, 
            requiredChecker;
        }
        function addOptional(checker, disabled) {
            var optionalCheck = disabled ? getNoop() : function(val, name, location, obj) {
                return undef(val) ? void 0 : checker(val, name, location, obj);
            };
            copyProps(checker, optionalCheck), optionalCheck.isOptional = !0, optionalCheck.displayName = checker.displayName + " (optional)", 
            optionalCheck.originalChecker = checker, checker.optional = optionalCheck, fixType(checker, checker.optional);
        }
        function addNullable(checker, disabled) {
            var nullableCheck = disabled ? getNoop() : function(val, name, location, obj) {
                return null !== val ? checker(val, name, location, obj) : void 0;
            };
            copyProps(checker, nullableCheck), nullableCheck.isNullable = !0, nullableCheck.displayName = checker.displayName + " (nullable)", 
            nullableCheck.originalChecker = checker, checker.nullable = nullableCheck, fixType(checker, checker.nullable), 
            checker.notOptional || addOptional(checker.nullable, disabled);
        }
        function fixType(checker, checkerCopy) {
            if ("object" == typeof checkerCopy.type) checkerCopy.type = copy(checkerCopy.type); else {
                if ("function" != typeof checkerCopy.type) return void (checkerCopy.type += " (optional)");
                checkerCopy.type = function() {
                    return checker.type.apply(checker, arguments);
                };
            }
            checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}, checkerCopy.type.__apiCheckData.optional = !0;
        }
        function copyProps(src, dest) {
            each(Object.keys(src), function(key) {
                return dest[key] = src[key];
            });
        }
        function noop() {}
        function getNoop() {
            return function() {};
        }
        var stringify = __webpack_require__(2), checkerHelpers = {
            addOptional: addOptional,
            getRequiredVersion: getRequiredVersion,
            setupChecker: setupChecker,
            addNullable: addNullable
        };
        module.exports = {
            each: each,
            copy: copy,
            typeOf: typeOf,
            arrayify: arrayify,
            getCheckerDisplay: getCheckerDisplay,
            isError: isError,
            list: list,
            getError: getError,
            nAtL: nAtL,
            t: t,
            undef: undef,
            checkerHelpers: checkerHelpers,
            noop: noop
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function getCheckers(disabled) {
            function typeOfCheckGetter(type) {
                var lType = type.toLowerCase();
                return setupChecker(function(val, name, location) {
                    return typeOf(val) !== lType ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function funcCheckGetter() {
                var type = "Function", functionChecker = setupChecker(function(val, name, location) {
                    return "function" !== typeOf(val) ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
                return functionChecker.withProperties = function(properties) {
                    var apiError = checkers.objectOf(checkers.func)(properties, "properties", "apiCheck.func.withProperties");
                    if (isError(apiError)) throw apiError;
                    var shapeChecker = checkers.shape(properties, !0);
                    return shapeChecker.type.__apiCheckData.type = "func.withProperties", setupChecker(function(val, name, location) {
                        var notFunction = checkers.func(val, name, location);
                        return isError(notFunction) ? notFunction : shapeChecker(val, name, location);
                    }, {
                        type: shapeChecker.type,
                        shortType: "func.withProperties"
                    }, disabled);
                }, functionChecker;
            }
            function objectCheckGetter() {
                var type = "Object", nullType = "Object (null ok)", objectNullOkChecker = setupChecker(function(val, name, location) {
                    return "object" !== typeOf(val) ? getError(name, location, nullType) : void 0;
                }, {
                    type: nullType
                }, disabled), objectChecker = setupChecker(function(val, name, location) {
                    return null === val || isError(objectNullOkChecker(val, name, location)) ? getError(name, location, objectChecker.type) : void 0;
                }, {
                    type: type,
                    nullOk: objectNullOkChecker
                }, disabled);
                return objectChecker;
            }
            function instanceCheckGetter(classToCheck) {
                return setupChecker(function(val, name, location) {
                    return val instanceof classToCheck ? void 0 : getError(name, location, classToCheck.name);
                }, {
                    type: classToCheck.name
                }, disabled);
            }
            function oneOfCheckGetter(enums) {
                var type = {
                    __apiCheckData: {
                        optional: !1,
                        type: "enum"
                    },
                    "enum": enums
                }, shortType = "oneOf[" + enums.map(function(enm) {
                    return stringify(enm);
                }).join(", ") + "]";
                return setupChecker(function(val, name, location) {
                    return enums.some(function(enm) {
                        return enm === val;
                    }) ? void 0 : getError(name, location, shortType);
                }, {
                    type: type,
                    shortType: shortType
                }, disabled);
            }
            function oneOfTypeCheckGetter(typeCheckers) {
                function type(options) {
                    return options && options["short"] ? shortType : typeCheckers.map(function(checker) {
                        return getCheckerDisplay(checker, options);
                    });
                }
                var checkersDisplay = typeCheckers.map(function(checker) {
                    return getCheckerDisplay(checker, {
                        "short": !0
                    });
                }), shortType = "oneOfType[" + checkersDisplay.join(", ") + "]";
                return type.__apiCheckData = {
                    optional: !1,
                    type: "oneOfType"
                }, setupChecker(function(val, name, location) {
                    return typeCheckers.some(function(checker) {
                        return !isError(checker(val, name, location));
                    }) ? void 0 : getError(name, location, shortType);
                }, {
                    type: type,
                    shortType: shortType
                }, disabled);
            }
            function arrayOfCheckGetter(checker) {
                function type(options) {
                    return options && options["short"] ? shortType : getCheckerDisplay(checker, options);
                }
                var shortCheckerDisplay = getCheckerDisplay(checker, {
                    "short": !0
                }), shortType = "arrayOf[" + shortCheckerDisplay + "]";
                return type.__apiCheckData = {
                    optional: !1,
                    type: "arrayOf"
                }, setupChecker(function(val, name, location) {
                    return isError(checkers.array(val)) || !val.every(function(item) {
                        return !isError(checker(item));
                    }) ? getError(name, location, shortType) : void 0;
                }, {
                    type: type,
                    shortType: shortType
                }, disabled);
            }
            function objectOfCheckGetter(checker) {
                function type(options) {
                    return options && options["short"] ? shortType : getCheckerDisplay(checker, options);
                }
                var checkerDisplay = getCheckerDisplay(checker, {
                    "short": !0
                }), shortType = "objectOf[" + checkerDisplay + "]";
                return type.__apiCheckData = {
                    optional: !1,
                    type: "objectOf"
                }, setupChecker(function(val, name, location) {
                    var notObject = checkers.object(val, name, location);
                    if (isError(notObject)) return notObject;
                    var allTypesSuccess = each(val, function(item, key) {
                        return isError(checker(item, key, name)) ? !1 : void 0;
                    });
                    return allTypesSuccess ? void 0 : getError(name, location, shortType);
                }, {
                    type: type,
                    shortType: shortType
                }, disabled);
            }
            function typeOrArrayOfCheckGetter(checker) {
                function type(options) {
                    return options && options["short"] ? shortType : getCheckerDisplay(checker, options);
                }
                var checkerDisplay = getCheckerDisplay(checker, {
                    "short": !0
                }), shortType = "typeOrArrayOf[" + checkerDisplay + "]";
                return type.__apiCheckData = {
                    optional: !1,
                    type: "typeOrArrayOf"
                }, setupChecker(function(val, name, location, obj) {
                    return isError(checkers.oneOfType([ checker, checkers.arrayOf(checker) ])(val, name, location, obj)) ? getError(name, location, shortType) : void 0;
                }, {
                    type: type,
                    shortType: shortType
                }, disabled);
            }
            function getShapeCheckGetter() {
                function shapeCheckGetter(shape, nonObject) {
                    function type() {
                        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {
                            function addHelper(property, objectMessage, stringMessage) {
                                "string" == typeof theRet[prop] ? theRet[prop] += stringMessage : theRet[prop].__apiCheckData[property] = objectMessage;
                            }
                            if (specified || !required || checker.isOptional) {
                                if (specified) {
                                    var error = checker(obj[prop], prop, null, obj);
                                    isError(error) && addHelper("error", "THIS IS THE PROBLEM: " + error.message, " <-- THIS IS THE PROBLEM: " + error.message);
                                }
                            } else {
                                var item = "ITEM";
                                checker.type && checker.type.__apiCheckData && (item = checker.type.__apiCheckData.type.toUpperCase()), 
                                addHelper("missing", "MISSING THIS " + item, " <-- YOU ARE MISSING THIS");
                            }
                        }
                        var options = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], ret = {}, terse = options.terse, obj = options.obj, addHelpers = options.addHelpers, parentRequired = options.required;
                        return each(shape, function(checker, prop) {
                            var specified = obj && obj.hasOwnProperty(prop), required = undef(parentRequired) ? !checker.isOptional : parentRequired;
                            terse && !specified && checker.isOptional || (ret[prop] = getCheckerDisplay(checker, {
                                terse: terse,
                                obj: obj && obj[prop],
                                required: required,
                                addHelpers: addHelpers
                            })), addHelpers && modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);
                        }), ret;
                    }
                    function strictType() {
                        return type.apply(void 0, arguments);
                    }
                    var shapeTypes = {};
                    each(shape, function(checker, prop) {
                        shapeTypes[prop] = getCheckerDisplay(checker);
                    }), type.__apiCheckData = {
                        strict: !1,
                        optional: !1,
                        type: "shape"
                    };
                    var shapeChecker = setupChecker(function(val, name, location) {
                        var isObject = !nonObject && checkers.object(val, name, location);
                        if (isError(isObject)) return isObject;
                        var shapePropError = void 0;
                        return location = location ? location + (name ? "/" : "") : "", name = name || "", 
                        each(shape, function(checker, prop) {
                            return val.hasOwnProperty(prop) || !checker.isOptional ? (shapePropError = checker(val[prop], prop, "" + location + name, val), 
                            !isError(shapePropError)) : void 0;
                        }), isError(shapePropError) ? shapePropError : void 0;
                    }, {
                        type: type,
                        shortType: "shape"
                    }, disabled);
                    return strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData), strictType.__apiCheckData.strict = !0, 
                    shapeChecker.strict = setupChecker(function(val, name, location) {
                        var shapeError = shapeChecker(val, name, location);
                        if (isError(shapeError)) return shapeError;
                        var allowedProperties = Object.keys(shape), extraProps = Object.keys(val).filter(function(prop) {
                            return -1 === allowedProperties.indexOf(prop);
                        });
                        return extraProps.length ? new Error(nAtL(name, location) + " cannot have extra properties: " + t(extraProps.join("`, `")) + ".It is limited to " + t(allowedProperties.join("`, `"))) : void 0;
                    }, {
                        type: strictType,
                        shortType: "strict shape"
                    }, disabled), shapeChecker;
                }
                function getRequiredIfNotChecker(all, otherProps, propChecker) {
                    var props = t(otherProps.join(", ")), ifProps = "if " + (all ? "all of" : "at least one of"), description = "specified " + ifProps + " these are not specified: " + props + " (otherwise it's optional)", shortType = "requiredIfNot" + (all ? ".all" : "") + "[" + otherProps.join(", ") + "}]", type = getTypeForShapeChild(propChecker, description, shortType);
                    return setupChecker(function(prop, propName, location, obj) {
                        var propExists = obj && obj.hasOwnProperty(propName), iteration = all ? "every" : "some", otherPropsExist = otherProps[iteration](function(otherProp) {
                            return obj && obj.hasOwnProperty(otherProp);
                        });
                        return otherPropsExist || propExists ? propExists ? propChecker(prop, propName, location, obj) : void 0 : getError(propName, location, type);
                    }, {
                        type: type,
                        notRequired: !0
                    }, disabled);
                }
                function getTypeForShapeChild(propChecker, description, shortType) {
                    function type(options) {
                        return options && options["short"] ? shortType : getCheckerDisplay(propChecker);
                    }
                    return type.__apiCheckData = {
                        optional: !1,
                        type: "ifNot",
                        description: description
                    }, type;
                }
                return shapeCheckGetter.ifNot = function(otherProps, propChecker) {
                    Array.isArray(otherProps) || (otherProps = [ otherProps ]);
                    var description = void 0;
                    description = 1 === otherProps.length ? "specified only if " + otherProps[0] + " is not specified" : "specified only if none of the following are specified: [" + list(otherProps, ", ", "and ") + "]";
                    var shortType = "ifNot[" + otherProps.join(", ") + "]", type = getTypeForShapeChild(propChecker, description, shortType);
                    return setupChecker(function(prop, propName, location, obj) {
                        var propExists = obj && obj.hasOwnProperty(propName), otherPropsExist = otherProps.some(function(otherProp) {
                            return obj && obj.hasOwnProperty(otherProp);
                        });
                        return propExists === otherPropsExist ? getError(propName, location, type) : propExists ? propChecker(prop, propName, location, obj) : void 0;
                    }, {
                        notRequired: !0,
                        type: type,
                        shortType: shortType
                    }, disabled);
                }, shapeCheckGetter.onlyIf = function(otherProps, propChecker) {
                    otherProps = arrayify(otherProps);
                    var description = void 0;
                    description = 1 === otherProps.length ? "specified only if " + otherProps[0] + " is also specified" : "specified only if all of the following are specified: [" + list(otherProps, ", ", "and ") + "]";
                    var shortType = "onlyIf[" + otherProps.join(", ") + "]", type = getTypeForShapeChild(propChecker, description, shortType);
                    return setupChecker(function(prop, propName, location, obj) {
                        var othersPresent = otherProps.every(function(property) {
                            return obj.hasOwnProperty(property);
                        });
                        return othersPresent ? propChecker(prop, propName, location, obj) : getError(propName, location, type);
                    }, {
                        type: type,
                        shortType: shortType
                    }, disabled);
                }, shapeCheckGetter.requiredIfNot = function(otherProps, propChecker) {
                    return Array.isArray(otherProps) || (otherProps = [ otherProps ]), getRequiredIfNotChecker(!1, otherProps, propChecker);
                }, shapeCheckGetter.requiredIfNot.all = function(otherProps, propChecker) {
                    if (!Array.isArray(otherProps)) throw new Error("requiredIfNot.all must be passed an array");
                    return getRequiredIfNotChecker(!0, otherProps, propChecker);
                }, shapeCheckGetter;
            }
            function argumentsCheckerGetter() {
                var type = "function arguments";
                return setupChecker(function(val, name, location) {
                    return Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length)) ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function anyCheckGetter() {
                return setupChecker(function() {}, {
                    type: "any"
                }, disabled);
            }
            function nullCheckGetter() {
                var type = "null";
                return setupChecker(function(val, name, location) {
                    return null !== val ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function rangeCheckGetter(min, max) {
                var type = "Range (" + min + " - " + max + ")";
                return setupChecker(function(val, name, location) {
                    return "number" != typeof val || min > val || val > max ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function lessThanCheckGetter(min) {
                var type = "lessThan[" + min + "]";
                return setupChecker(function(val, name, location) {
                    return "number" != typeof val || val > min ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function greaterThanCheckGetter(max) {
                var type = "greaterThan[" + max + "]";
                return setupChecker(function(val, name, location) {
                    return "number" != typeof val || max > val ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            function emptyObjectCheckGetter() {
                var type = "empty object";
                return setupChecker(function(val, name, location) {
                    return "object" !== typeOf(val) || null === val || Object.keys(val).length ? getError(name, location, type) : void 0;
                }, {
                    type: type
                }, disabled);
            }
            return {
                array: typeOfCheckGetter("Array"),
                bool: typeOfCheckGetter("Boolean"),
                number: typeOfCheckGetter("Number"),
                string: typeOfCheckGetter("String"),
                func: funcCheckGetter(),
                object: objectCheckGetter(),
                emptyObject: emptyObjectCheckGetter(),
                instanceOf: instanceCheckGetter,
                oneOf: oneOfCheckGetter,
                oneOfType: oneOfTypeCheckGetter,
                arrayOf: arrayOfCheckGetter,
                objectOf: objectOfCheckGetter,
                typeOrArrayOf: typeOrArrayOfCheckGetter,
                range: rangeCheckGetter,
                lessThan: lessThanCheckGetter,
                greaterThan: greaterThanCheckGetter,
                shape: getShapeCheckGetter(),
                args: argumentsCheckerGetter(),
                any: anyCheckGetter(),
                "null": nullCheckGetter()
            };
        }
        var stringify = __webpack_require__(2), _require = __webpack_require__(3), typeOf = _require.typeOf, each = _require.each, copy = _require.copy, getCheckerDisplay = _require.getCheckerDisplay, isError = _require.isError, arrayify = _require.arrayify, list = _require.list, getError = _require.getError, nAtL = _require.nAtL, t = _require.t, checkerHelpers = _require.checkerHelpers, undef = _require.undef, setupChecker = checkerHelpers.setupChecker, checkers = module.exports = getCheckers();
        module.exports.getCheckers = getCheckers;
    } ]);
}), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("angular"), require("api-check")) : "function" == typeof define && define.amd ? define([ "angular", "api-check" ], factory) : "object" == typeof exports ? exports.ngFormly = factory(require("angular"), require("api-check")) : root.ngFormly = factory(root.angular, root.apiCheck);
}(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _indexCommon = __webpack_require__(1), _indexCommon2 = _interopRequireDefault(_indexCommon);
        exports["default"] = _indexCommon2["default"], module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix), _providersFormlyApiCheck = __webpack_require__(4), _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck), _otherDocsBaseUrl = __webpack_require__(6), _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl), _providersFormlyUsability = __webpack_require__(7), _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability), _providersFormlyConfig = __webpack_require__(8), _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig), _providersFormlyValidationMessages = __webpack_require__(10), _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages), _servicesFormlyUtil = __webpack_require__(11), _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil), _servicesFormlyWarn = __webpack_require__(12), _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn), _directivesFormlyCustomValidation = __webpack_require__(13), _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation), _directivesFormlyField = __webpack_require__(14), _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField), _directivesFormlyFocus = __webpack_require__(15), _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus), _directivesFormlyForm = __webpack_require__(16), _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm), _directivesFormlyFormController = __webpack_require__(17), _directivesFormlyFormController2 = _interopRequireDefault(_directivesFormlyFormController), _runFormlyNgModelAttrsManipulator = __webpack_require__(18), _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator), _runFormlyCustomTags = __webpack_require__(19), _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags), ngModuleName = "formly";
        exports["default"] = ngModuleName;
        var ngModule = _angularFix2["default"].module(ngModuleName, []);
        ngModule.constant("formlyApiCheck", _providersFormlyApiCheck2["default"]), ngModule.constant("formlyErrorAndWarningsUrlPrefix", _otherDocsBaseUrl2["default"]), 
        ngModule.constant("formlyVersion", "8.4.1"), ngModule.provider("formlyUsability", _providersFormlyUsability2["default"]), 
        ngModule.provider("formlyConfig", _providersFormlyConfig2["default"]), ngModule.factory("formlyValidationMessages", _providersFormlyValidationMessages2["default"]), 
        ngModule.factory("formlyUtil", _servicesFormlyUtil2["default"]), ngModule.factory("formlyWarn", _servicesFormlyWarn2["default"]), 
        ngModule.directive("formlyCustomValidation", _directivesFormlyCustomValidation2["default"]), 
        ngModule.directive("formlyField", _directivesFormlyField2["default"]), ngModule.directive("formlyFocus", _directivesFormlyFocus2["default"]), 
        ngModule.directive("formlyForm", _directivesFormlyForm2["default"]), ngModule.controller("FormlyFormController", _directivesFormlyFormController2["default"]), 
        ngModule.run(_runFormlyNgModelAttrsManipulator2["default"]), ngModule.run(_runFormlyCustomTags2["default"]), 
        module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var angular = __webpack_require__(3);
        angular.version || (angular = window.angular), exports["default"] = angular, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_3__;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function shapeRequiredIfNot(otherProps, propChecker) {
            function shapeRequiredIfNotDefinition(prop, propName, location, obj) {
                var propExists = obj && obj.hasOwnProperty(propName), otherPropsExist = otherProps.some(function(otherProp) {
                    return obj && obj.hasOwnProperty(otherProp);
                });
                return otherPropsExist || propExists ? propExists ? propChecker(prop, propName, location, obj) : void 0 : apiCheck.utils.getError(propName, location, type);
            }
            _angularFix2["default"].isArray(otherProps) || (otherProps = [ otherProps ]);
            var type = "specified if these are not specified: `" + otherProps.join(", ") + "` (otherwise it's optional)";
            return shapeRequiredIfNotDefinition.type = type, apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix), _apiCheck = __webpack_require__(5), _apiCheck2 = _interopRequireDefault(_apiCheck), apiCheck = _apiCheck2["default"]({
            output: {
                prefix: "angular-formly:",
                docsBaseUrl: __webpack_require__(6)
            }
        }), formlyExpression = apiCheck.oneOfType([ apiCheck.string, apiCheck.func ]), specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable, apiCheckProperty = apiCheck.func, apiCheckInstanceProperty = apiCheck.shape.onlyIf("apiCheck", apiCheck.func.withProperties({
            warn: apiCheck.func,
            "throw": apiCheck.func,
            shape: apiCheck.func
        })), apiCheckFunctionProperty = apiCheck.shape.onlyIf("apiCheck", apiCheck.oneOf([ "throw", "warn" ])), formlyWrapperType = apiCheck.shape({
            name: shapeRequiredIfNot("types", apiCheck.string).optional,
            template: apiCheck.shape.ifNot("templateUrl", apiCheck.string).optional,
            templateUrl: apiCheck.shape.ifNot("template", apiCheck.string).optional,
            types: apiCheck.typeOrArrayOf(apiCheck.string).optional,
            overwriteOk: apiCheck.bool.optional,
            apiCheck: apiCheckProperty.optional,
            apiCheckInstance: apiCheckInstanceProperty.optional,
            apiCheckFunction: apiCheckFunctionProperty.optional,
            apiCheckOptions: apiCheck.object.optional
        }).strict, expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([ formlyExpression, apiCheck.shape({
            expression: formlyExpression,
            message: formlyExpression.optional
        }).strict ])), modelChecker = apiCheck.oneOfType([ apiCheck.string, apiCheck.object ]), templateManipulators = apiCheck.shape({
            preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,
            postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional
        }).strict.nullable, validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([ formlyExpression, apiCheck.shape({
            expression: formlyExpression,
            message: formlyExpression.optional
        }).strict ])), watcherChecker = apiCheck.typeOrArrayOf(apiCheck.shape({
            expression: formlyExpression.optional,
            listener: formlyExpression.optional,
            runFieldExpressions: apiCheck.bool.optional
        })), fieldOptionsApiShape = {
            $$hashKey: apiCheck.any.optional,
            type: apiCheck.shape.ifNot([ "template", "templateUrl" ], apiCheck.string).optional,
            template: apiCheck.shape.ifNot([ "type", "templateUrl" ], apiCheck.oneOfType([ apiCheck.string, apiCheck.func ])).optional,
            templateUrl: apiCheck.shape.ifNot([ "type", "template" ], apiCheck.oneOfType([ apiCheck.string, apiCheck.func ])).optional,
            key: apiCheck.oneOfType([ apiCheck.string, apiCheck.number ]).optional,
            model: modelChecker.optional,
            originalModel: modelChecker.optional,
            className: apiCheck.string.optional,
            id: apiCheck.string.optional,
            name: apiCheck.string.optional,
            expressionProperties: expressionProperties.optional,
            extras: apiCheck.shape({
                validateOnModelChange: apiCheck.bool.optional,
                skipNgModelAttrsManipulator: apiCheck.oneOfType([ apiCheck.string, apiCheck.bool ]).optional
            }).strict.optional,
            data: apiCheck.object.optional,
            templateOptions: apiCheck.object.optional,
            wrapper: specifyWrapperType.optional,
            modelOptions: apiCheck.shape({
                updateOn: apiCheck.string.optional,
                debounce: apiCheck.oneOfType([ apiCheck.objectOf(apiCheck.number), apiCheck.number ]).optional,
                allowInvalid: apiCheck.bool.optional,
                getterSetter: apiCheck.bool.optional,
                timezone: apiCheck.string.optional
            }).optional,
            watcher: watcherChecker.optional,
            validators: validatorChecker.optional,
            asyncValidators: validatorChecker.optional,
            parsers: apiCheck.arrayOf(formlyExpression).optional,
            formatters: apiCheck.arrayOf(formlyExpression).optional,
            noFormControl: apiCheck.bool.optional,
            hide: apiCheck.bool.optional,
            hideExpression: formlyExpression.optional,
            ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,
            ngModelAttrs: apiCheck.objectOf(apiCheck.shape({
                statement: apiCheck.shape.ifNot([ "value", "attribute", "bound", "boolean" ], apiCheck.any).optional,
                value: apiCheck.shape.ifNot("statement", apiCheck.any).optional,
                attribute: apiCheck.shape.ifNot("statement", apiCheck.any).optional,
                bound: apiCheck.shape.ifNot("statement", apiCheck.any).optional,
                "boolean": apiCheck.shape.ifNot("statement", apiCheck.any).optional
            }).strict).optional,
            elementAttributes: apiCheck.objectOf(apiCheck.string).optional,
            optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,
            link: apiCheck.func.optional,
            controller: apiCheck.oneOfType([ apiCheck.string, apiCheck.func, apiCheck.array ]).optional,
            validation: apiCheck.shape({
                show: apiCheck.bool.nullable.optional,
                messages: apiCheck.objectOf(formlyExpression).optional,
                errorExistsAndShouldBeVisible: apiCheck.bool.optional
            }).optional,
            formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,
            value: apiCheck.func.optional,
            runExpressions: apiCheck.func.optional,
            templateManipulators: templateManipulators.optional,
            resetModel: apiCheck.func.optional,
            updateInitialValue: apiCheck.func.optional,
            initialValue: apiCheck.any.optional,
            defaultValue: apiCheck.any.optional
        }, formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict, formOptionsApi = apiCheck.shape({
            formState: apiCheck.object.optional,
            resetModel: apiCheck.func.optional,
            updateInitialValue: apiCheck.func.optional,
            removeChromeAutoComplete: apiCheck.bool.optional,
            parseKeyArrays: apiCheck.bool.optional,
            templateManipulators: templateManipulators.optional,
            manualModelWatcher: apiCheck.oneOfType([ apiCheck.bool, apiCheck.func ]).optional,
            watchAllExpressions: apiCheck.bool.optional,
            wrapper: specifyWrapperType.optional,
            fieldTransform: apiCheck.oneOfType([ apiCheck.func, apiCheck.array ]).optional,
            data: apiCheck.object.optional
        }).strict, fieldGroup = apiCheck.shape({
            $$hashKey: apiCheck.any.optional,
            key: apiCheck.oneOfType([ apiCheck.string, apiCheck.number ]).optional,
            fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([ formlyFieldOptions, apiCheck.object ])),
            className: apiCheck.string.optional,
            options: formOptionsApi.optional,
            templateOptions: apiCheck.object.optional,
            wrapper: specifyWrapperType.optional,
            watcher: watcherChecker.optional,
            hide: apiCheck.bool.optional,
            hideExpression: formlyExpression.optional,
            data: apiCheck.object.optional,
            model: modelChecker.optional,
            form: apiCheck.object.optional,
            elementAttributes: apiCheck.objectOf(apiCheck.string).optional
        }).strict, typeOptionsDefaultOptions = _angularFix2["default"].copy(fieldOptionsApiShape);
        typeOptionsDefaultOptions.key = apiCheck.string.optional;
        var formlyTypeOptions = apiCheck.shape({
            name: apiCheck.string,
            template: apiCheck.shape.ifNot("templateUrl", apiCheck.oneOfType([ apiCheck.string, apiCheck.func ])).optional,
            templateUrl: apiCheck.shape.ifNot("template", apiCheck.oneOfType([ apiCheck.string, apiCheck.func ])).optional,
            controller: apiCheck.oneOfType([ apiCheck.func, apiCheck.string, apiCheck.array ]).optional,
            link: apiCheck.func.optional,
            defaultOptions: apiCheck.oneOfType([ apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions) ]).optional,
            "extends": apiCheck.string.optional,
            wrapper: specifyWrapperType.optional,
            data: apiCheck.object.optional,
            apiCheck: apiCheckProperty.optional,
            apiCheckInstance: apiCheckInstanceProperty.optional,
            apiCheckFunction: apiCheckFunctionProperty.optional,
            apiCheckOptions: apiCheck.object.optional,
            overwriteOk: apiCheck.bool.optional
        }).strict;
        _angularFix2["default"].extend(apiCheck, {
            formlyTypeOptions: formlyTypeOptions,
            formlyFieldOptions: formlyFieldOptions,
            formlyExpression: formlyExpression,
            formlyWrapperType: formlyWrapperType,
            fieldGroup: fieldGroup,
            formOptionsApi: formOptionsApi
        }), exports["default"] = apiCheck, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = "https://github.com/formly-js/angular-formly/blob/8.4.1/other/ERRORS_AND_WARNINGS.md#", 
        module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {
            function getFieldError(errorInfoSlug, message, field) {
                return arguments.length < 3 && (field = message, message = errorInfoSlug, errorInfoSlug = null), 
                new Error(getErrorMessage(errorInfoSlug, message) + (" Field definition: " + _angularFix2["default"].toJson(field)));
            }
            function getFormlyError(errorInfoSlug, message) {
                return message || (message = errorInfoSlug, errorInfoSlug = null), new Error(getErrorMessage(errorInfoSlug, message));
            }
            function getErrorMessage(errorInfoSlug, message) {
                var url = "";
                return null !== errorInfoSlug && (url = "" + formlyErrorAndWarningsUrlPrefix + errorInfoSlug), 
                "Formly Error: " + message + ". " + url;
            }
            function checkWrapper(wrapper) {
                formlyApiCheck["throw"](formlyApiCheck.formlyWrapperType, wrapper, {
                    prefix: "formlyConfig.setWrapper",
                    urlSuffix: "setwrapper-validation-failed"
                });
            }
            function checkWrapperTemplate(template, additionalInfo) {
                var formlyTransclude = "<formly-transclude></formly-transclude>";
                if (-1 === template.indexOf(formlyTransclude)) throw getFormlyError('Template wrapper templates must use "' + formlyTransclude + '" somewhere in them. This one does not have "<formly-transclude></formly-transclude>" in it: ' + template + "\nAdditional information: " + JSON.stringify(additionalInfo));
            }
            var _this = this;
            _angularFix2["default"].extend(this, {
                getFormlyError: getFormlyError,
                getFieldError: getFieldError,
                checkWrapper: checkWrapper,
                checkWrapperTemplate: checkWrapperTemplate,
                getErrorMessage: getErrorMessage,
                $get: function() {
                    return _this;
                }
            });
        }
        formlyUsability.$inject = [ "formlyApiCheck", "formlyErrorAndWarningsUrlPrefix" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        exports["default"] = formlyUsability, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        function formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {
            function setType(options) {
                if (!_angularFix2["default"].isArray(options)) {
                    if (_angularFix2["default"].isObject(options)) return checkType(options), options["extends"] && extendTypeOptions(options), 
                    typeMap[options.name] = options, typeMap[options.name];
                    throw getError("You must provide an object or array for setType. You provided: " + JSON.stringify(arguments));
                }
                var _ret = function() {
                    var allTypes = [];
                    return _angularFix2["default"].forEach(options, function(item) {
                        allTypes.push(setType(item));
                    }), {
                        v: allTypes
                    };
                }();
                return "object" == typeof _ret ? _ret.v : void 0;
            }
            function checkType(options) {
                formlyApiCheck["throw"](formlyApiCheck.formlyTypeOptions, options, {
                    prefix: "formlyConfig.setType",
                    url: "settype-validation-failed"
                }), options.overwriteOk ? options.overwriteOk = void 0 : checkOverwrite(options.name, typeMap, options, "types");
            }
            function extendTypeOptions(options) {
                var extendsType = getType(options["extends"], !0, options);
                extendTypeControllerFunction(options, extendsType), extendTypeLinkFunction(options, extendsType), 
                extendTypeDefaultOptions(options, extendsType), _otherUtils2["default"].reverseDeepMerge(options, extendsType), 
                extendTemplate(options, extendsType);
            }
            function extendTemplate(options, extendsType) {
                options.template && extendsType.templateUrl ? delete options.templateUrl : options.templateUrl && extendsType.template && delete options.template;
            }
            function extendTypeControllerFunction(options, extendsType) {
                var extendsCtrl = extendsType.controller;
                if (_angularFix2["default"].isDefined(extendsCtrl)) {
                    var optionsCtrl = options.controller;
                    _angularFix2["default"].isDefined(optionsCtrl) ? (options.controller = function($scope, $controller) {
                        $controller(extendsCtrl, {
                            $scope: $scope
                        }), $controller(optionsCtrl, {
                            $scope: $scope
                        });
                    }, options.controller.$inject = [ "$scope", "$controller" ]) : options.controller = extendsCtrl;
                }
            }
            function extendTypeLinkFunction(options, extendsType) {
                var extendsFn = extendsType.link;
                if (_angularFix2["default"].isDefined(extendsFn)) {
                    var optionsFn = options.link;
                    _angularFix2["default"].isDefined(optionsFn) ? options.link = function() {
                        extendsFn.apply(void 0, arguments), optionsFn.apply(void 0, arguments);
                    } : options.link = extendsFn;
                }
            }
            function extendTypeDefaultOptions(options, extendsType) {
                var extendsDO = extendsType.defaultOptions;
                if (_angularFix2["default"].isDefined(extendsDO)) {
                    var optionsDO = options.defaultOptions || {}, optionsDOIsFn = _angularFix2["default"].isFunction(optionsDO), extendsDOIsFn = _angularFix2["default"].isFunction(extendsDO);
                    extendsDOIsFn ? options.defaultOptions = function(opts, scope) {
                        var extendsDefaultOptions = extendsDO(opts, scope), mergedDefaultOptions = {};
                        _otherUtils2["default"].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);
                        var extenderOptionsDefaultOptions = optionsDO;
                        return optionsDOIsFn && (extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope)), 
                        _otherUtils2["default"].reverseDeepMerge(extenderOptionsDefaultOptions, extendsDefaultOptions), 
                        extenderOptionsDefaultOptions;
                    } : optionsDOIsFn && (options.defaultOptions = function(opts, scope) {
                        var newDefaultOptions = {};
                        return _otherUtils2["default"].reverseDeepMerge(newDefaultOptions, opts, extendsDO), 
                        optionsDO(newDefaultOptions, scope);
                    });
                }
            }
            function getType(name, throwError, errorContext) {
                if (!name) return void 0;
                var type = typeMap[name];
                if (type || throwError !== !0) return type;
                throw getError('There is no type by the name of "' + name + '": ' + JSON.stringify(errorContext));
            }
            function getTypes() {
                return typeMap;
            }
            function getTypeHeritage(parent) {
                var heritage = [], type = parent;
                for (_angularFix2["default"].isString(type) && (type = getType(parent)), parent = type["extends"]; parent; ) type = getType(parent), 
                heritage.push(type), parent = type["extends"];
                return heritage;
            }
            function setWrapper(_x, _x2) {
                for (var _again = !0; _again; ) {
                    var options = _x, name = _x2;
                    if (_again = !1, _angularFix2["default"].isArray(options)) return options.map(function(wrapperOptions) {
                        return setWrapper(wrapperOptions);
                    });
                    if (_angularFix2["default"].isObject(options)) return options.types = getOptionsTypes(options), 
                    options.name = getOptionsName(options, name), checkWrapperAPI(options), templateWrappersMap[options.name] = options, 
                    options;
                    _angularFix2["default"].isString(options) && (_x = {
                        template: options,
                        name: name
                    }, _x2 = void 0, _again = !0);
                }
            }
            function getOptionsTypes(options) {
                return _angularFix2["default"].isString(options.types) ? [ options.types ] : _angularFix2["default"].isDefined(options.types) ? options.types : [];
            }
            function getOptionsName(options, name) {
                return options.name || name || options.types.join(" ") || defaultWrapperName;
            }
            function checkWrapperAPI(options) {
                formlyUsabilityProvider.checkWrapper(options), options.template && formlyUsabilityProvider.checkWrapperTemplate(options.template, options), 
                options.overwriteOk ? delete options.overwriteOk : checkOverwrite(options.name, templateWrappersMap, options, "templateWrappers"), 
                checkWrapperTypes(options);
            }
            function checkWrapperTypes(options) {
                var shouldThrow = !_angularFix2["default"].isArray(options.types) || !options.types.every(_angularFix2["default"].isString);
                if (shouldThrow) throw getError("Attempted to create a template wrapper with types that is not a string or an array of strings");
            }
            function checkOverwrite(property, object, newValue, objectName) {
                object.hasOwnProperty(property) && warn("overwriting-types-or-wrappers", [ "Attempting to overwrite " + property + " on " + objectName + " which is currently", JSON.stringify(object[property]) + " with " + JSON.stringify(newValue), 'To supress this warning, specify the property "overwriteOk: true"' ].join(" "));
            }
            function getWrapper(name) {
                return templateWrappersMap[name || defaultWrapperName];
            }
            function getWrapperByType(type) {
                var wrappers = [];
                for (var _name in templateWrappersMap) templateWrappersMap.hasOwnProperty(_name) && templateWrappersMap[_name].types && -1 !== templateWrappersMap[_name].types.indexOf(type) && wrappers.push(templateWrappersMap[_name]);
                return wrappers;
            }
            function removeWrapperByName(name) {
                var wrapper = templateWrappersMap[name];
                return delete templateWrappersMap[name], wrapper;
            }
            function removeWrappersForType(type) {
                var wrappers = getWrapperByType(type);
                return wrappers ? _angularFix2["default"].isArray(wrappers) ? (wrappers.forEach(function(wrapper) {
                    return removeWrapperByName(wrapper.name);
                }), wrappers) : removeWrapperByName(wrappers.name) : void 0;
            }
            function warn() {
                if (!_this.disableWarnings && console.warn) {
                    var args = Array.prototype.slice.call(arguments), warnInfoSlug = args.shift();
                    args.unshift("Formly Warning:"), args.push("" + formlyErrorAndWarningsUrlPrefix + warnInfoSlug), 
                    console.warn.apply(console, _toConsumableArray(args));
                }
            }
            var _this2 = this, typeMap = {}, templateWrappersMap = {}, defaultWrapperName = "default", _this = this, getError = formlyUsabilityProvider.getFormlyError;
            _angularFix2["default"].extend(this, {
                setType: setType,
                getType: getType,
                getTypes: getTypes,
                getTypeHeritage: getTypeHeritage,
                setWrapper: setWrapper,
                getWrapper: getWrapper,
                getWrapperByType: getWrapperByType,
                removeWrapperByName: removeWrapperByName,
                removeWrappersForType: removeWrappersForType,
                disableWarnings: !1,
                extras: {
                    disableNgModelAttrsManipulator: !1,
                    fieldTransform: [],
                    ngModelAttrsManipulatorPreferUnbound: !1,
                    removeChromeAutoComplete: !1,
                    parseKeyArrays: !1,
                    defaultHideDirective: "ng-if",
                    getFieldId: null
                },
                templateManipulators: {
                    preWrapper: [],
                    postWrapper: []
                },
                $get: function() {
                    return _this2;
                }
            });
        }
        formlyConfig.$inject = [ "formlyUsabilityProvider", "formlyErrorAndWarningsUrlPrefix", "formlyApiCheck" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix), _otherUtils = __webpack_require__(9), _otherUtils2 = _interopRequireDefault(_otherUtils);
        exports["default"] = formlyConfig, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function containsSelector(string) {
            return containsSpecialChar(string, ".") || containsSpecialChar(string, "[") && containsSpecialChar(string, "]");
        }
        function containsSpecialChar(a, b) {
            return a && a.indexOf ? -1 !== a.indexOf(b) : !1;
        }
        function formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {
            return _angularFix2["default"].isFunction(expression) ? expression($viewValue, $modelValue, scope, extraLocals) : scope.$eval(expression, _angularFix2["default"].extend({
                $viewValue: $viewValue,
                $modelValue: $modelValue
            }, extraLocals));
        }
        function getFieldId(formId, options, index) {
            if (options.id) return options.id;
            var type = options.type;
            return !type && options.template ? type = "template" : !type && options.templateUrl && (type = "templateUrl"), 
            [ formId, type, options.key, index ].join("_");
        }
        function reverseDeepMerge(dest) {
            return _angularFix2["default"].forEach(arguments, function(src, index) {
                index && _angularFix2["default"].forEach(src, function(val, prop) {
                    _angularFix2["default"].isDefined(dest[prop]) ? objAndSameType(dest[prop], val) && reverseDeepMerge(dest[prop], val) : dest[prop] = _angularFix2["default"].copy(val);
                });
            }), dest;
        }
        function objAndSameType(obj1, obj2) {
            return _angularFix2["default"].isObject(obj1) && _angularFix2["default"].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);
        }
        function findByNodeName(el, nodeName) {
            if (el.prop || (el = _angularFix2["default"].element(el)), el.prop("nodeName") === nodeName.toUpperCase()) return el;
            for (var c = el.children(), i = 0; c && i < c.length; i++) {
                var node = findByNodeName(c[i], nodeName);
                if (node) return node;
            }
        }
        function arrayify(obj) {
            return obj && !_angularFix2["default"].isArray(obj) ? obj = [ obj ] : obj || (obj = []), 
            obj;
        }
        function extendFunction() {
            for (var _len = arguments.length, fns = Array(_len), _key = 0; _len > _key; _key++) fns[_key] = arguments[_key];
            return function() {
                var args = arguments;
                fns.forEach(function(fn) {
                    return fn.apply(null, args);
                });
            };
        }
        function extendArray(primary, secondary, property) {
            return property && (primary = primary[property], secondary = secondary[property]), 
            secondary && primary ? (_angularFix2["default"].forEach(secondary, function(item) {
                -1 === primary.indexOf(item) && primary.push(item);
            }), primary) : secondary ? secondary : primary;
        }
        function startsWith(str, search) {
            return _angularFix2["default"].isString(str) && _angularFix2["default"].isString(search) ? str.length >= search.length && str.substring(0, search.length) === search : !1;
        }
        function contains(str, search) {
            return _angularFix2["default"].isString(str) && _angularFix2["default"].isString(search) ? str.length >= search.length && -1 !== str.indexOf(search) : !1;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        exports["default"] = {
            containsSelector: containsSelector,
            containsSpecialChar: containsSpecialChar,
            formlyEval: formlyEval,
            getFieldId: getFieldId,
            reverseDeepMerge: reverseDeepMerge,
            findByNodeName: findByNodeName,
            arrayify: arrayify,
            extendFunction: extendFunction,
            extendArray: extendArray,
            startsWith: startsWith,
            contains: contains
        }, module.exports = exports["default"];
    }, function(module, exports) {
        "use strict";
        function formlyValidationMessages() {
            function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {
                validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);
            }
            function addStringMessage(name, string) {
                validationMessages.messages[name] = function() {
                    return string;
                };
            }
            function templateOptionValue(prop, prefix, suffix, alternate) {
                return function(viewValue, modelValue, scope) {
                    return "undefined" != typeof scope.options.templateOptions[prop] ? prefix + " " + scope.options.templateOptions[prop] + " " + suffix : alternate;
                };
            }
            var validationMessages = {
                addTemplateOptionValueMessage: addTemplateOptionValueMessage,
                addStringMessage: addStringMessage,
                messages: {}
            };
            return validationMessages;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = formlyValidationMessages, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formlyUtil() {
            return _otherUtils2["default"];
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _otherUtils = __webpack_require__(9), _otherUtils2 = _interopRequireDefault(_otherUtils);
        exports["default"] = formlyUtil, module.exports = exports["default"];
    }, function(module, exports) {
        "use strict";
        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        function formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {
            return function() {
                if (!formlyConfig.disableWarnings) {
                    var args = Array.prototype.slice.call(arguments), warnInfoSlug = args.shift();
                    args.unshift("Formly Warning:"), args.push("" + formlyErrorAndWarningsUrlPrefix + warnInfoSlug), 
                    $log.warn.apply($log, _toConsumableArray(args));
                }
            };
        }
        formlyWarn.$inject = [ "formlyConfig", "formlyErrorAndWarningsUrlPrefix", "$log" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = formlyWarn, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formlyCustomValidation(formlyUtil) {
            return {
                restrict: "A",
                require: "ngModel",
                link: function(scope, el, attrs, ctrl) {
                    function addValidatorToPipeline(isAsync, validator, name) {
                        setupMessage(validator, name), validator = _angularFix2["default"].isObject(validator) ? validator.expression : validator, 
                        useNewValidatorsApi ? setupWithValidators(validator, name, isAsync) : setupWithParsers(validator, name, isAsync);
                    }
                    function setupMessage(validator, name) {
                        var message = validator.message;
                        message && (opts.validation.messages[name] = function() {
                            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);
                        });
                    }
                    function setupWithValidators(validator, name, isAsync) {
                        var validatorCollection = isAsync ? "$asyncValidators" : "$validators";
                        ctrl[validatorCollection][name] = function(modelValue, viewValue) {
                            return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);
                        };
                    }
                    function setupWithParsers(validator, name, isAsync) {
                        var inFlightValidator = void 0;
                        ctrl.$parsers.unshift(function(viewValue) {
                            var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);
                            return isAsync ? (ctrl.$pending = ctrl.$pending || {}, ctrl.$pending[name] = !0, 
                            inFlightValidator = isValid, isValid.then(function() {
                                inFlightValidator === isValid && ctrl.$setValidity(name, !0);
                            })["catch"](function() {
                                inFlightValidator === isValid && ctrl.$setValidity(name, !1);
                            })["finally"](function() {
                                var $pending = ctrl.$pending || {};
                                1 === Object.keys($pending).length ? delete ctrl.$pending : delete ctrl.$pending[name];
                            })) : ctrl.$setValidity(name, isValid), viewValue;
                        });
                    }
                    var opts = scope.options;
                    opts.validation.messages = opts.validation.messages || {}, _angularFix2["default"].forEach(opts.validation.messages, function(message, key) {
                        opts.validation.messages[key] = function() {
                            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);
                        };
                    });
                    var useNewValidatorsApi = ctrl.hasOwnProperty("$validators") && !attrs.hasOwnProperty("useParsers");
                    _angularFix2["default"].forEach(opts.validators, _angularFix2["default"].bind(null, addValidatorToPipeline, !1)), 
                    _angularFix2["default"].forEach(opts.asyncValidators, _angularFix2["default"].bind(null, addValidatorToPipeline, !0));
                }
            };
        }
        formlyCustomValidation.$inject = [ "formlyUtil" ], Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        exports["default"] = formlyCustomValidation, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        function formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {
            function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {
                function runExpressions() {
                    var deferred = $q.defer();
                    return $timeout(function() {
                        var promises = [], field = $scope.options, currentValue = valueGetterSetter();
                        _angularFix2["default"].forEach(field.expressionProperties, function(expression, prop) {
                            var setter = $parse(prop).assign, promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue)).then(function(value) {
                                setter(field, value);
                            });
                            promises.push(promise);
                        }), $q.all(promises).then(function() {
                            deferred.resolve();
                        });
                    }, 0, !1), deferred.promise;
                }
                function watchExpressions() {
                    $scope.formOptions.watchAllExpressions && !function() {
                        var field = $scope.options, currentValue = valueGetterSetter();
                        _angularFix2["default"].forEach(field.expressionProperties, function(expression, prop) {
                            var setter = $parse(prop).assign;
                            $scope.$watch(function() {
                                return formlyUtil.formlyEval($scope, expression, currentValue, currentValue);
                            }, function(value) {
                                setter(field, value);
                            }, !0);
                        });
                    }();
                }
                function valueGetterSetter(newVal) {
                    return $scope.model && $scope.options.key ? (_angularFix2["default"].isDefined(newVal) && parseSet($scope.options.key, $scope.model, newVal), 
                    parseGet($scope.options.key, $scope.model)) : void 0;
                }
                function shouldNotUseParseKey(key) {
                    return _angularFix2["default"].isNumber(key) || !formlyUtil.containsSelector(key);
                }
                function keyContainsArrays(key) {
                    return /\[\d{1,}\]/.test(key);
                }
                function deepAssign(obj, prop, value) {
                    if (_angularFix2["default"].isString(prop) && (prop = prop.replace(/\[(\w+)\]/g, ".$1").split(".")), 
                    prop.length > 1) {
                        var e = prop.shift();
                        obj[e] = obj[e] || isNaN(prop[0]) ? {} : [], deepAssign(obj[e], prop, value);
                    } else obj[prop[0]] = value;
                }
                function parseSet(key, model, newVal) {
                    if ((key || 0 === key) && model) if (shouldNotUseParseKey(key)) model[key] = newVal; else if (formlyConfig.extras.parseKeyArrays && keyContainsArrays(key)) deepAssign($scope.model, key, newVal); else {
                        var setter = $parse($scope.options.key).assign;
                        setter && setter($scope.model, newVal);
                    }
                }
                function parseGet(key, model) {
                    return !key && 0 !== key || !model ? void 0 : shouldNotUseParseKey(key) ? model[key] : $parse(key)(model);
                }
                function simplifyLife(options) {
                    formlyUtil.reverseDeepMerge(options, {
                        originalModel: options.model,
                        extras: {},
                        data: {},
                        templateOptions: {},
                        validation: {}
                    }), $scope.to = $scope.options.templateOptions, $scope.formOptions = $scope.formOptions || {};
                }
                function setFieldIdAndName() {
                    if (_angularFix2["default"].isFunction(formlyConfig.extras.getFieldId)) $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope); else {
                        var formName = $scope.form && $scope.form.$name || $scope.formId;
                        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);
                    }
                    $scope.options.id = $scope.id, $scope.name = $scope.options.name || $scope.options.id, 
                    $scope.options.name = $scope.name;
                }
                function setDefaultValue() {
                    _angularFix2["default"].isDefined($scope.options.defaultValue) && !_angularFix2["default"].isDefined(parseGet($scope.options.key, $scope.model)) && parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);
                }
                function setInitialValue() {
                    $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);
                }
                function mergeFieldOptionsWithTypeDefaults(options, type) {
                    type && mergeOptions(options, type.defaultOptions);
                    var properOrder = arrayify(options.optionsTypes).reverse();
                    _angularFix2["default"].forEach(properOrder, function(typeName) {
                        mergeOptions(options, formlyConfig.getType(typeName, !0, options).defaultOptions);
                    });
                }
                function mergeOptions(options, extraOptions) {
                    extraOptions && (_angularFix2["default"].isFunction(extraOptions) && (extraOptions = extraOptions(options, $scope)), 
                    formlyUtil.reverseDeepMerge(options, extraOptions));
                }
                function extendOptionsWithDefaults(options, index) {
                    var key = options.key || index || 0;
                    _angularFix2["default"].extend(options, {
                        key: key,
                        value: options.value || valueGetterSetter,
                        runExpressions: runExpressions,
                        resetModel: resetModel,
                        updateInitialValue: updateInitialValue
                    });
                }
                function resetModel() {
                    parseSet($scope.options.key, $scope.model, $scope.options.initialValue), $scope.options.formControl && (_angularFix2["default"].isArray($scope.options.formControl) ? _angularFix2["default"].forEach($scope.options.formControl, function(formControl) {
                        resetFormControl(formControl, !0);
                    }) : resetFormControl($scope.options.formControl)), $scope.form && ($scope.form.$setUntouched && $scope.form.$setUntouched(), 
                    $scope.form.$setPristine());
                }
                function resetFormControl(formControl, isMultiNgModel) {
                    isMultiNgModel || formControl.$setViewValue(parseGet($scope.options.key, $scope.model)), 
                    formControl.$render(), formControl.$setUntouched && formControl.$setUntouched(), 
                    formControl.$setPristine(), $scope.$root.$$phase || $scope.$digest();
                }
                function updateInitialValue() {
                    $scope.options.initialValue = parseGet($scope.options.key, $scope.model);
                }
                function addValidationMessages(options) {
                    options.validation.messages = options.validation.messages || {}, _angularFix2["default"].forEach(formlyValidationMessages.messages, function(expression, name) {
                        options.validation.messages[name] || (options.validation.messages[name] = function(viewValue, modelValue, scope) {
                            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);
                        });
                    });
                }
                function invokeControllers(scope) {
                    var options = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], type = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                    _angularFix2["default"].forEach([ type.controller, options.controller ], function(controller) {
                        controller && $controller(controller, {
                            $scope: scope
                        });
                    });
                }
                function setupFieldGroup() {
                    $scope.options.options = $scope.options.options || {}, $scope.options.options.formState = $scope.formState, 
                    $scope.to = $scope.options.templateOptions;
                }
                if ($scope.options.fieldGroup) return void setupFieldGroup();
                var fieldType = getFieldType($scope.options);
                simplifyLife($scope.options), mergeFieldOptionsWithTypeDefaults($scope.options, fieldType), 
                extendOptionsWithDefaults($scope.options, $scope.index), checkApi($scope.options), 
                setFieldIdAndName(), setDefaultValue(), setInitialValue(), runExpressions(), watchExpressions(), 
                addValidationMessages($scope.options), invokeControllers($scope, $scope.options, fieldType);
            }
            function fieldLink(scope, el, attrs, formlyFormCtrl) {
                function setFieldGroupTemplate() {
                    checkFieldGroupApi(scope.options), el.addClass("formly-field-group");
                    var extraAttributes = "";
                    scope.options.elementAttributes && (extraAttributes = Object.keys(scope.options.elementAttributes).map(function(key) {
                        return key + '="' + scope.options.elementAttributes[key] + '"';
                    }).join(" "));
                    var modelValue = "model";
                    scope.options.form = scope.form, scope.options.key && (modelValue = "model['" + scope.options.key + "']"), 
                    getTemplate('\n          <formly-form model="' + modelValue + '"\n                       fields="options.fieldGroup"\n                       options="options.options"\n                       form="options.form"\n                       class="' + scope.options.className + '"\n                       ' + extraAttributes + "\n                       is-field-group>\n          </formly-form>\n        ").then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);
                }
                function addAttributes() {
                    scope.options.elementAttributes && el.attr(scope.options.elementAttributes);
                }
                function addClasses() {
                    scope.options.className && el.addClass(scope.options.className), scope.options.type && el.addClass("formly-field-" + scope.options.type);
                }
                function setElementTemplate(templateString) {
                    return el.html(asHtml(templateString)), $compile(el.contents())(scope), templateString;
                }
                function watchFormControl(templateString) {
                    function watchFieldNameOrExistence(name) {
                        var nameExpressionRegex = /\{\{(.*?)}}/, nameExpression = nameExpressionRegex.exec(name);
                        nameExpression && (name = $interpolate(name)(scope)), watchFieldExistence(name);
                    }
                    function watchFieldExistence(name) {
                        scope.$watch('form["' + name + '"]', function(formControl) {
                            formControl && (fieldCount > 1 ? (scope.options.formControl || (scope.options.formControl = []), 
                            scope.options.formControl.push(formControl)) : scope.options.formControl = formControl, 
                            scope.fc = scope.options.formControl, stopWatchingShowError(), addShowMessagesWatcher(), 
                            addParsers(), addFormatters());
                        });
                    }
                    function addShowMessagesWatcher() {
                        stopWatchingShowError = scope.$watch(function() {
                            var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression, options = scope.options, formControls = arrayify(scope.fc);
                            return formControls.some(function(fc) {
                                return fc.$invalid;
                            }) ? "boolean" == typeof options.validation.show ? options.validation.show : customExpression ? formControls.some(function(fc) {
                                return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);
                            }) : formControls.some(function(fc) {
                                var noTouchedButDirty = _angularFix2["default"].isUndefined(fc.$touched) && fc.$dirty;
                                return fc.$touched || noTouchedButDirty;
                            }) : !1;
                        }, function(show) {
                            scope.options.validation.errorExistsAndShouldBeVisible = show, scope.showError = show;
                        });
                    }
                    function addParsers() {
                        setParsersOrFormatters("parsers");
                    }
                    function addFormatters() {
                        setParsersOrFormatters("formatters");
                        var ctrl = scope.fc, formWasPristine = scope.form.$pristine;
                        scope.options.formatters && !function() {
                            var value = ctrl.$modelValue;
                            ctrl.$formatters.forEach(function(formatter) {
                                value = formatter(value);
                            }), ctrl.$setViewValue(value), ctrl.$render(), ctrl.$setPristine(), formWasPristine && scope.form.$setPristine();
                        }();
                    }
                    function setParsersOrFormatters(which) {
                        function getThingsFromType(theType) {
                            if (!theType) return [];
                            _angularFix2["default"].isString(theType) && (theType = formlyConfig.getType(theType, !0, scope.options));
                            var typeThings = [];
                            return theType["extends"] && (typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType["extends"]))), 
                            typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, [])), 
                            typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));
                        }
                        function getThingsFromOptionsTypes() {
                            var optionsTypes = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0], optionsTypesThings = [];
                            return _angularFix2["default"].forEach(_angularFix2["default"].copy(arrayify(optionsTypes)).reverse(), function(optionsTypeName) {
                                optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));
                            }), optionsTypesThings;
                        }
                        function getFormlyExpressionThing(thing) {
                            function formlyExpressionParserOrFormatterFunction($viewValue) {
                                var $modelValue = scope.options.value();
                                return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);
                            }
                            return formlyExpressionParserOrFormatterFunction[originalThingProp] = thing, formlyExpressionParserOrFormatterFunction;
                        }
                        var originalThingProp = "originalParser";
                        "formatters" === which && (originalThingProp = "originalFormatter");
                        var things = getThingsFromType(type);
                        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes)), 
                        things = formlyUtil.extendArray(things, scope.options[which]), _angularFix2["default"].forEach(things, function(thing, index) {
                            things[index] = getFormlyExpressionThing(thing);
                        });
                        var ngModelCtrls = scope.fc;
                        _angularFix2["default"].isArray(ngModelCtrls) || (ngModelCtrls = [ ngModelCtrls ]), 
                        _angularFix2["default"].forEach(ngModelCtrls, function(ngModelCtrl) {
                            var _ngModelCtrl;
                            ngModelCtrl["$" + which] = (_ngModelCtrl = ngModelCtrl["$" + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));
                        });
                    }
                    var stopWatchingShowError = _angularFix2["default"].noop;
                    if (!scope.options.noFormControl) {
                        var templateEl = _angularFix2["default"].element("<div>" + templateString + "</div>"), ngModelNodes = templateEl[0].querySelectorAll("[ng-model],[data-ng-model]");
                        ngModelNodes.length && _angularFix2["default"].forEach(ngModelNodes, function(ngModelNode) {
                            fieldCount++, watchFieldNameOrExistence(ngModelNode.getAttribute("name"));
                        });
                    }
                }
                function callLinkFunctions() {
                    type && type.link && type.link.apply(thusly, args), scope.options.link && scope.options.link.apply(thusly, args);
                }
                function runManipulators(manipulators) {
                    return function(templateToManipulate) {
                        var chain = $q.when(templateToManipulate);
                        return _angularFix2["default"].forEach(manipulators, function(manipulator) {
                            chain = chain.then(function(template) {
                                return $q.when(manipulator(template, scope.options, scope)).then(function(newTemplate) {
                                    return _angularFix2["default"].isString(newTemplate) ? newTemplate : asHtml(newTemplate);
                                });
                            });
                        }), chain;
                    };
                }
                if (scope.options.fieldGroup) return void setFieldGroupTemplate();
                !formlyFormCtrl && scope.options.model && scope.$watch("options.model", function() {
                    return scope.options.runExpressions();
                }, !0), addAttributes(), addClasses();
                var type = getFieldType(scope.options), args = arguments, thusly = this, fieldCount = 0, fieldManipulators = getManipulators(scope.options, scope.formOptions);
                getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)["catch"](function(error) {
                    formlyWarn("there-was-a-problem-setting-the-template-for-this-field", "There was a problem setting the template for this field ", scope.options, error);
                });
            }
            function asHtml(el) {
                var wrapper = _angularFix2["default"].element("<a></a>");
                return wrapper.append(el).html();
            }
            function getFieldType(options) {
                return options.type && formlyConfig.getType(options.type);
            }
            function getManipulators(options, formOptions) {
                function addManipulators(manipulators) {
                    var _ref = manipulators || {}, _ref$preWrapper = _ref.preWrapper, pre = void 0 === _ref$preWrapper ? [] : _ref$preWrapper, _ref$postWrapper = _ref.postWrapper, post = void 0 === _ref$postWrapper ? [] : _ref$postWrapper;
                    preWrapper = preWrapper.concat(pre), postWrapper = postWrapper.concat(post);
                }
                var preWrapper = [], postWrapper = [];
                return addManipulators(options.templateManipulators), addManipulators(formOptions.templateManipulators), 
                addManipulators(formlyConfig.templateManipulators), {
                    preWrapper: preWrapper,
                    postWrapper: postWrapper
                };
            }
            function getFieldTemplate(options) {
                function fromOptionsOrType(key, fieldType) {
                    return _angularFix2["default"].isDefined(options[key]) ? options[key] : fieldType && _angularFix2["default"].isDefined(fieldType[key]) ? fieldType[key] : void 0;
                }
                var type = formlyConfig.getType(options.type, !0, options), template = fromOptionsOrType("template", type), templateUrl = fromOptionsOrType("templateUrl", type);
                if (_angularFix2["default"].isUndefined(template) && !templateUrl) throw formlyUsability.getFieldError("type-type-has-no-template", "Type '" + options.type + "' has no template. On element:", options);
                return getTemplate(templateUrl || template, _angularFix2["default"].isUndefined(template), options);
            }
            function getTemplate(template, isUrl, options) {
                var templatePromise = void 0;
                if (templatePromise = _angularFix2["default"].isFunction(template) ? $q.when(template(options)) : $q.when(template), 
                !isUrl) return templatePromise;
                var _ret3 = function() {
                    var httpOptions = {
                        cache: $templateCache
                    };
                    return {
                        v: templatePromise.then(function(url) {
                            return $http.get(url, httpOptions);
                        }).then(function(response) {
                            return response.data;
                        })["catch"](function(error) {
                            formlyWarn("problem-loading-template-for-templateurl", "Problem loading template for " + template, error);
                        })
                    };
                }();
                return "object" == typeof _ret3 ? _ret3.v : void 0;
            }
            function transcludeInWrappers(options, formOptions) {
                var wrapper = getWrapperOption(options, formOptions);
                return function(template) {
                    if (!wrapper.length) return $q.when(template);
                    wrapper.forEach(function(aWrapper) {
                        formlyUsability.checkWrapper(aWrapper, options), runApiCheck(aWrapper, options);
                    });
                    var promises = wrapper.map(function(w) {
                        return getTemplate(w.template || w.templateUrl, !w.template);
                    });
                    return $q.all(promises).then(function(wrappersTemplates) {
                        wrappersTemplates.forEach(function(wrapperTemplate, index) {
                            formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);
                        }), wrappersTemplates.reverse();
                        var totalWrapper = wrappersTemplates.shift();
                        return wrappersTemplates.forEach(function(wrapperTemplate) {
                            totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);
                        }), doTransclusion(totalWrapper, template);
                    });
                };
            }
            function doTransclusion(wrapper, template) {
                var superWrapper = _angularFix2["default"].element("<a></a>");
                superWrapper.append(wrapper);
                var transcludeEl = superWrapper.find("formly-transclude");
                return transcludeEl.length || (transcludeEl = formlyUtil.findByNodeName(superWrapper, "formly-transclude")), 
                transcludeEl.replaceWith(template), superWrapper.html();
            }
            function getWrapperOption(options, formOptions) {
                var wrapper = options.wrapper;
                if (null === wrapper) return [];
                wrapper = wrapper ? arrayify(wrapper).map(formlyConfig.getWrapper) : arrayify(formlyConfig.getWrapperByType(options.type));
                var type = formlyConfig.getType(options.type, !0, options);
                if (type && type.wrapper) {
                    var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);
                    wrapper = wrapper.concat(typeWrappers);
                }
                if (formOptions.wrapper) {
                    var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);
                    wrapper = wrapper.concat(formWrappers);
                }
                var defaultWrapper = formlyConfig.getWrapper();
                return defaultWrapper && wrapper.push(defaultWrapper), wrapper;
            }
            function checkApi(options) {
                formlyApiCheck["throw"](formlyApiCheck.formlyFieldOptions, options, {
                    prefix: "formly-field directive",
                    url: "formly-field-directive-validation-failed"
                });
                var type = options.type && formlyConfig.getType(options.type);
                type && runApiCheck(type, options, !0), options.expressionProperties && options.expressionProperties.hide && formlyWarn("dont-use-expressionproperties.hide-use-hideexpression-instead", "You have specified `hide` in `expressionProperties`. Use `hideExpression` instead", options);
            }
            function checkFieldGroupApi(options) {
                formlyApiCheck["throw"](formlyApiCheck.fieldGroup, options, {
                    prefix: "formly-field directive",
                    url: "formly-field-directive-validation-failed"
                });
            }
            function runApiCheck(_ref2, options, forType) {
                var apiCheck = _ref2.apiCheck, apiCheckInstance = _ref2.apiCheckInstance, apiCheckFunction = _ref2.apiCheckFunction, apiCheckOptions = _ref2.apiCheckOptions;
                runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options), 
                forType && options.type && _angularFix2["default"].forEach(formlyConfig.getTypeHeritage(options.type), function(type) {
                    runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);
                });
            }
            function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {
                if (apiCheck) {
                    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;
                    if (!instance.config.disabled && !_apiCheck2["default"].globalConfig.disabled) {
                        var fn = apiCheckFunction || "warn", checkerObjects = apiCheck(instance);
                        _angularFix2["default"].forEach(checkerObjects, function(shape, name) {
                            var checker = instance.shape(shape), checkOptions = _angularFix2["default"].extend({
                                prefix: "formly-field type " + options.type + " for property " + name,
                                url: formlyApiCheck.config.output.docsBaseUrl + "formly-field-type-apicheck-failed"
                            }, apiCheckOptions);
                            instance[fn](checker, options[name], checkOptions);
                        });
                    }
                }
            }
            FormlyFieldController.$inject = [ "$scope", "$timeout", "$parse", "$controller", "formlyValidationMessages" ];
            var arrayify = formlyUtil.arrayify;
            return {
                restrict: "AE",
                transclude: !0,
                require: "?^formlyForm",
                scope: {
                    options: "=",
                    model: "=",
                    originalModel: "=?",
                    formId: "@",
                    index: "=?",
                    fields: "=?",
                    formState: "=?",
                    formOptions: "=?",
                    form: "=?"
                },
                controller: FormlyFieldController,
                link: fieldLink
            };
        }
        function getDefaultOptionsOptionsTypes(type) {
            return getDefaultOptionsProperty(type, "optionsTypes", []);
        }
        function getDefaultOptionsProperty(type, prop, defaultValue) {
            return type.defaultOptions && type.defaultOptions[prop] || defaultValue;
        }
        formlyField.$inject = [ "$http", "$q", "$compile", "$templateCache", "$interpolate", "formlyConfig", "formlyApiCheck", "formlyUtil", "formlyUsability", "formlyWarn" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix), _apiCheck = __webpack_require__(5), _apiCheck2 = _interopRequireDefault(_apiCheck);
        exports["default"] = formlyField, module.exports = exports["default"];
    }, function(module, exports) {
        "use strict";
        function formlyFocus($timeout, $document) {
            return {
                restrict: "A",
                link: function(scope, element, attrs) {
                    var previousEl = null, el = element[0], doc = $document[0];
                    attrs.$observe("formlyFocus", function(value) {
                        "true" === value ? $timeout(function() {
                            previousEl = doc.activeElement, el.focus();
                        }, ~~attrs.focusWait) : "false" === value && doc.activeElement === el && (el.blur(), 
                        attrs.hasOwnProperty("refocus") && previousEl && previousEl.focus());
                    });
                }
            };
        }
        formlyFocus.$inject = [ "$timeout", "$document" ], Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = formlyFocus, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {
            function formlyFormGetTemplate(el, attrs) {
                function getRootEl() {
                    return attrs.rootEl || "ng-form";
                }
                function getFieldRootEl() {
                    return attrs.fieldRootEl || "div";
                }
                function getHideDirective() {
                    return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || "ng-if";
                }
                function getTrackBy() {
                    return attrs.trackBy ? "track by " + attrs.trackBy : "";
                }
                function getFormName() {
                    var formName = formId, bindName = attrs.bindName;
                    if (bindName) {
                        if (_angularFix2["default"].version.minor < 3) throw formlyUsability.getFormlyError("bind-name attribute on formly-form not allowed in < angular 1.3");
                        formName = $interpolate.startSymbol() + "::'formly_' + " + bindName + $interpolate.endSymbol();
                    }
                    return formName;
                }
                function getTranscludeClass() {
                    return attrs.transcludeClass || "";
                }
                function copyAttributes(attributes) {
                    var excluded = [ "model", "form", "fields", "options", "name", "role", "class", "data-model", "data-form", "data-fields", "data-options", "data-name" ], arrayAttrs = [];
                    return _angularFix2["default"].forEach(attributes, function(_ref) {
                        var nodeName = _ref.nodeName, value = _ref.value;
                        "undefined" !== nodeName && -1 === excluded.indexOf(nodeName) && arrayAttrs.push(toKebabCase(nodeName) + '="' + value + '"');
                    }), arrayAttrs.join(" ");
                }
                var rootEl = getRootEl(), fieldRootEl = getFieldRootEl(), formId = "formly_" + currentFormId++, parentFormAttributes = "";
                return attrs.hasOwnProperty("isFieldGroup") && el.parent().parent().hasClass("formly") && (parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes)), 
                "\n        <" + rootEl + ' class="formly"\n                 name="' + getFormName() + '"\n                 role="form" ' + parentFormAttributes + ">\n          <" + fieldRootEl + ' formly-field\n               ng-repeat="field in fields ' + getTrackBy() + '"\n               ' + getHideDirective() + '="!field.hide"\n               class="formly-field"\n               options="field"\n               model="field.model || model"\n               original-model="model"\n               fields="fields"\n               form="theFormlyForm"\n               form-id="' + getFormName() + '"\n               form-state="options.formState"\n               form-options="options"\n               index="$index">\n          </' + fieldRootEl + '>\n          <div ng-transclude class="' + getTranscludeClass() + '"></div>\n        </' + rootEl + ">\n      ";
            }
            function formlyFormLink(scope, el, attrs) {
                function setFormController() {
                    var formId = attrs.name;
                    if (scope.formId = formId, scope.theFormlyForm = scope[formId], attrs.form) {
                        var getter = $parse(attrs.form), setter = getter.assign, parentForm = getter(scope.$parent);
                        parentForm ? (scope.theFormlyForm = parentForm, scope[formId] && scope.theFormlyForm.$removeControl(scope[formId]), 
                        el.removeData("$formController")) : setter(scope.$parent, scope[formId]);
                    }
                    scope.theFormlyForm || formlyConfig.disableWarnings || formlyWarn("formly-form-has-no-formcontroller", "Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work", el, scope);
                }
                function fixChromeAutocomplete() {
                    var global = formlyConfig.extras.removeChromeAutoComplete === !0, offInstance = scope.options && scope.options.removeChromeAutoComplete === !1, onInstance = scope.options && scope.options.removeChromeAutoComplete === !0;
                    if (global && !offInstance || onInstance) {
                        var input = document.createElement("input");
                        input.setAttribute("autocomplete", "address-level4"), input.setAttribute("hidden", "true"), 
                        el[0].appendChild(input);
                    }
                }
                setFormController(), fixChromeAutocomplete();
            }
            function toKebabCase(string) {
                return string ? string.replace(/([A-Z])/g, function($1) {
                    return "-" + $1.toLowerCase();
                }) : "";
            }
            var currentFormId = 1;
            return {
                restrict: "AE",
                template: formlyFormGetTemplate,
                replace: !0,
                transclude: !0,
                scope: {
                    fields: "=",
                    model: "=",
                    form: "=?",
                    options: "=?"
                },
                controller: "FormlyFormController",
                link: formlyFormLink
            };
        }
        formlyForm.$inject = [ "formlyUsability", "formlyWarn", "$parse", "formlyConfig", "$interpolate" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        exports["default"] = formlyForm, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        function isFieldGroup(field) {
            return field && !!field.fieldGroup;
        }
        function FormlyFormController(formlyUsability, formlyWarn, formlyConfig, $parse, $scope, formlyApiCheck, formlyUtil) {
            function onModelOrFormStateChange() {
                _angularFix2["default"].forEach($scope.fields, runFieldExpressionProperties);
            }
            function validateFormControl(formControl, promise) {
                var validate = formControl.$validate;
                promise ? promise.then(function() {
                    return validate.apply(formControl);
                }) : validate();
            }
            function runFieldExpressionProperties(field, index) {
                var model = field.model || $scope.model, promise = field.runExpressions && field.runExpressions();
                if (field.hideExpression) {
                    var val = model[field.key];
                    field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index, {
                        model: model
                    });
                }
                field.extras && field.extras.validateOnModelChange && field.formControl && (_angularFix2["default"].isArray(field.formControl) ? _angularFix2["default"].forEach(field.formControl, function(formControl) {
                    validateFormControl(formControl, promise);
                }) : validateFormControl(field.formControl, promise));
            }
            function setupFields() {
                $scope.fields = $scope.fields || [], checkDeprecatedOptions($scope.options);
                var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;
                _angularFix2["default"].isArray(fieldTransforms) || (fieldTransforms = [ fieldTransforms ]), 
                _angularFix2["default"].forEach(fieldTransforms, function(fieldTransform) {
                    if (fieldTransform && ($scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form), 
                    !$scope.fields)) throw formlyUsability.getFormlyError("fieldTransform must return an array of fields");
                }), setupModels(), $scope.options.watchAllExpressions && _angularFix2["default"].forEach($scope.fields, setupHideExpressionWatcher), 
                _angularFix2["default"].forEach($scope.fields, attachKey), _angularFix2["default"].forEach($scope.fields, setupWatchers);
            }
            function checkDeprecatedOptions(options) {
                formlyConfig.extras.fieldTransform && _angularFix2["default"].isFunction(formlyConfig.extras.fieldTransform) ? formlyWarn("fieldtransform-as-a-function-deprecated", "fieldTransform as a function has been deprecated.", "Attempted for formlyConfig.extras: " + formlyConfig.extras.fieldTransform.name, formlyConfig.extras) : options.fieldTransform && _angularFix2["default"].isFunction(options.fieldTransform) && formlyWarn("fieldtransform-as-a-function-deprecated", "fieldTransform as a function has been deprecated.", "Attempted for form", options);
            }
            function setupOptions() {
                formlyApiCheck["throw"]([ formlyApiCheck.formOptionsApi.optional ], [ $scope.options ], {
                    prefix: "formly-form options check"
                }), $scope.options = $scope.options || {}, $scope.options.formState = $scope.options.formState || {}, 
                _angularFix2["default"].extend($scope.options, {
                    updateInitialValue: updateInitialValue,
                    resetModel: resetModel
                });
            }
            function updateInitialValue() {
                _angularFix2["default"].forEach($scope.fields, function(field) {
                    isFieldGroup(field) && field.options ? field.options.updateInitialValue() : field.updateInitialValue();
                });
            }
            function resetModel() {
                _angularFix2["default"].forEach($scope.fields, function(field) {
                    isFieldGroup(field) && field.options ? field.options.resetModel() : field.resetModel && field.resetModel();
                });
            }
            function setupModels() {
                var watchedModels = [ $scope.model ], manualModelWatcher = $scope.options.manualModelWatcher;
                $scope.options.formState && watchedModels.push($scope.options.formState), _angularFix2["default"].forEach($scope.fields, function(field) {
                    var isNewModel = initModel(field);
                    field.model && isNewModel && -1 === watchedModels.indexOf(field.model) && !manualModelWatcher && ($scope.$watch(function() {
                        return field.model;
                    }, onModelOrFormStateChange, !0), watchedModels.push(field.model));
                });
            }
            function setupHideExpressionWatcher(field, index) {
                field.hideExpression && !function() {
                    var model = field.model || $scope.model;
                    $scope.$watch(function() {
                        var val = model[field.key];
                        return evalCloseToFormlyExpression(field.hideExpression, val, field, index, {
                            model: model
                        });
                    }, function(hide) {
                        return field.hide = hide;
                    }, !0);
                }();
            }
            function initModel(field) {
                function resolveStringModel(expression) {
                    var index = $scope.fields.indexOf(field), model = evalCloseToFormlyExpression(expression, void 0, field, index, {
                        model: $scope.model
                    });
                    if (!model) throw formlyUsability.getFieldError("field-model-must-be-initialized", "Field model must be initialized. When specifying a model as a string for a field, the result of the expression must have been initialized ahead of time.", field);
                    return model;
                }
                var isNewModel = !0;
                return _angularFix2["default"].isString(field.model) && !function() {
                    var expression = field.model;
                    isNewModel = !referencesCurrentlyWatchedModel(expression), field.model = resolveStringModel(expression), 
                    $scope.$watch(function() {
                        return resolveStringModel(expression);
                    }, function(model) {
                        return field.model = model;
                    });
                }(), isNewModel;
            }
            function referencesCurrentlyWatchedModel(expression) {
                return [ "model", "formState" ].some(function(item) {
                    return formlyUtil.startsWith(expression, item + ".") || formlyUtil.startsWith(expression, item + "[");
                });
            }
            function attachKey(field, index) {
                isFieldGroup(field) || (field.key = field.key || index || 0);
            }
            function setupWatchers(field, index) {
                if (_angularFix2["default"].isDefined(field.watcher)) {
                    var watchers = field.watcher;
                    _angularFix2["default"].isArray(watchers) || (watchers = [ watchers ]), _angularFix2["default"].forEach(watchers, function(watcher) {
                        if (!_angularFix2["default"].isDefined(watcher.listener) && !watcher.runFieldExpressions) throw formlyUsability.getFieldError("all-field-watchers-must-have-a-listener", "All field watchers must have a listener", field);
                        var watchExpression = getWatchExpression(watcher, field, index), watchListener = getWatchListener(watcher, field, index), type = watcher.type || "$watch";
                        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);
                    });
                }
            }
            function getWatchExpression(watcher, field, index) {
                var watchExpression = void 0;
                return _angularFix2["default"].isUndefined(watcher.expression) ? field.key && (watchExpression = "model['" + field.key.toString().split(".").join("']['") + "']") : watchExpression = watcher.expression, 
                _angularFix2["default"].isFunction(watchExpression) ? !function() {
                    var originalExpression = watchExpression;
                    watchExpression = function() {
                        var args = modifyArgs.apply(void 0, [ watcher, index ].concat(_slice.call(arguments)));
                        return originalExpression.apply(void 0, _toConsumableArray(args));
                    }, watchExpression.displayName = "Formly Watch Expression for field for " + field.key;
                }() : field.model && (watchExpression = $parse(watchExpression).bind(null, $scope, {
                    model: field.model
                })), watchExpression;
            }
            function getWatchListener(watcher, field, index) {
                var watchListener = watcher.listener;
                return (_angularFix2["default"].isFunction(watchListener) || watcher.runFieldExpressions) && !function() {
                    var originalListener = watchListener;
                    watchListener = function() {
                        var value = void 0;
                        if (originalListener) {
                            var args = modifyArgs.apply(void 0, [ watcher, index ].concat(_slice.call(arguments)));
                            value = originalListener.apply(void 0, _toConsumableArray(args));
                        }
                        return watcher.runFieldExpressions && runFieldExpressionProperties(field, index), 
                        value;
                    }, watchListener.displayName = "Formly Watch Listener for field for " + field.key;
                }(), watchListener;
            }
            function modifyArgs(watcher, index) {
                for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _len > _key; _key++) originalArgs[_key - 2] = arguments[_key];
                return [ $scope.fields[index] ].concat(originalArgs, [ watcher.stopWatching ]);
            }
            function evalCloseToFormlyExpression(expression, val, field, index) {
                var extraLocals = arguments.length <= 4 || void 0 === arguments[4] ? {} : arguments[4];
                return extraLocals = _angularFix2["default"].extend(getFormlyFieldLikeLocals(field, index), extraLocals), 
                formlyUtil.formlyEval($scope, expression, val, val, extraLocals);
            }
            function getFormlyFieldLikeLocals(field, index) {
                return {
                    model: field.model,
                    options: field,
                    index: index,
                    formState: $scope.options.formState,
                    originalModel: $scope.model,
                    formOptions: $scope.options,
                    formId: $scope.formId
                };
            }
            setupOptions(), $scope.model = $scope.model || {}, setupFields(), $scope.options.manualModelWatcher ? _angularFix2["default"].isFunction($scope.options.manualModelWatcher) && $scope.$watch($scope.options.manualModelWatcher, onModelOrFormStateChange, !0) : $scope.$watch("model", onModelOrFormStateChange, !0), 
            $scope.options.formState && $scope.$watch("options.formState", onModelOrFormStateChange, !0);
        }
        FormlyFormController.$inject = [ "formlyUsability", "formlyWarn", "formlyConfig", "$parse", "$scope", "formlyApiCheck", "formlyUtil" ], 
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _slice = Array.prototype.slice;
        exports["default"] = FormlyFormController;
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {
            function ngModelAttrsManipulator(template, options, scope) {
                function addValidation() {
                    (_angularFix2["default"].isDefined(options.validators) || _angularFix2["default"].isDefined(options.validation.messages)) && addIfNotPresent(modelNodes, "formly-custom-validation", "");
                }
                function alterNgModelAttr() {
                    isPropertyAccessor(options.key) && addRegardlessOfPresence(modelNodes, "ng-model", "model." + options.key);
                }
                function addModelOptions() {
                    _angularFix2["default"].isDefined(options.modelOptions) && (addIfNotPresent(modelNodes, "ng-model-options", "options.modelOptions"), 
                    options.modelOptions.getterSetter && addRegardlessOfPresence(modelNodes, "ng-model", "options.value"));
                }
                function addTemplateOptionsAttrs() {
                    if (options.templateOptions || options.expressionProperties) {
                        var to = options.templateOptions || {}, ep = options.expressionProperties || {}, ngModelAttributes = getBuiltInAttributes();
                        _angularFix2["default"].extend(ngModelAttributes, options.ngModelAttrs), _angularFix2["default"].forEach(ngModelAttributes, function(val, name) {
                            var attrVal = void 0, attrName = void 0, ref = "options.templateOptions['" + name + "']", toVal = to[name], epVal = getEpValue(ep, name), inTo = _angularFix2["default"].isDefined(toVal), inEp = _angularFix2["default"].isDefined(epVal);
                            if (val.value) attrName = val.value, attrVal = name; else if (val.statement && inTo) if (attrName = val.statement, 
                            _angularFix2["default"].isString(to[name])) attrVal = "$eval(" + ref + ")"; else {
                                if (!_angularFix2["default"].isFunction(to[name])) throw new Error("options.templateOptions." + name + " must be a string or function: " + JSON.stringify(options));
                                attrVal = ref + "(model[options.key], options, this, $event)";
                            } else val.bound && inEp ? (attrName = val.bound, attrVal = ref) : (val.attribute || val["boolean"]) && inEp ? (attrName = val.attribute || val["boolean"], 
                            attrVal = "" + $interpolate.startSymbol() + ref + $interpolate.endSymbol()) : val.attribute && inTo ? (attrName = val.attribute, 
                            attrVal = toVal) : val["boolean"] ? inTo && !inEp && toVal && (attrName = val["boolean"], 
                            attrVal = !0) : val.bound && inTo && (attrName = val.bound, attrVal = ref);
                            _angularFix2["default"].isDefined(attrName) && _angularFix2["default"].isDefined(attrVal) && addIfNotPresent(modelNodes, attrName, attrVal);
                        });
                    }
                }
                function addNgModelElAttrs() {
                    _angularFix2["default"].forEach(options.ngModelElAttrs, function(val, name) {
                        addRegardlessOfPresence(modelNodes, name, val);
                    });
                }
                var node = document.createElement("div"), skip = options.extras && options.extras.skipNgModelAttrsManipulator;
                if (skip === !0) return template;
                node.innerHTML = template;
                var modelNodes = getNgModelNodes(node, skip);
                return modelNodes && modelNodes.length ? (addIfNotPresent(modelNodes, "id", scope.id), 
                addIfNotPresent(modelNodes, "name", scope.name || scope.id), addValidation(), alterNgModelAttr(), 
                addModelOptions(), addTemplateOptionsAttrs(), addNgModelElAttrs(), node.innerHTML) : template;
            }
            function getNgModelNodes(node, skip) {
                var selectorNot = _angularFix2["default"].isString(skip) ? ":not(" + skip + ")" : "", skipNot = ":not([formly-skip-ng-model-attrs-manipulator])", query = "[ng-model]" + selectorNot + skipNot + ", [data-ng-model]" + selectorNot + skipNot;
                try {
                    return node.querySelectorAll(query);
                } catch (e) {
                    return getNgModelNodesFallback(node, skip);
                }
            }
            function getNgModelNodesFallback(node, skip) {
                var allNgModelNodes = node.querySelectorAll("[ng-model], [data-ng-model]"), matchingNgModelNodes = [];
                matchingNgModelNodes.item = function(i) {
                    return this[i];
                };
                for (var i = 0; i < allNgModelNodes.length; i++) {
                    var ngModelNode = allNgModelNodes[i];
                    ngModelNode.hasAttribute("formly-skip-ng-model-attrs-manipulator") || _angularFix2["default"].isString(skip) && nodeMatches(ngModelNode, skip) || matchingNgModelNodes.push(ngModelNode);
                }
                return matchingNgModelNodes;
            }
            function nodeMatches(node, selector) {
                var div = document.createElement("div");
                return div.innerHTML = node.outerHTML, div.querySelector(selector);
            }
            function getBuiltInAttributes() {
                var ngModelAttributes = {
                    focus: {
                        attribute: "formly-focus"
                    }
                }, boundOnly = [], bothBooleanAndBound = [ "required", "disabled" ], bothAttributeAndBound = [ "pattern", "minlength" ], statementOnly = [ "change", "keydown", "keyup", "keypress", "click", "focus", "blur" ], attributeOnly = [ "placeholder", "min", "max", "step", "tabindex", "type" ];
                return formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound ? bothAttributeAndBound.push("maxlength") : boundOnly.push("maxlength"), 
                _angularFix2["default"].forEach(boundOnly, function(item) {
                    ngModelAttributes[item] = {
                        bound: "ng-" + item
                    };
                }), _angularFix2["default"].forEach(bothBooleanAndBound, function(item) {
                    ngModelAttributes[item] = {
                        "boolean": item,
                        bound: "ng-" + item
                    };
                }), _angularFix2["default"].forEach(bothAttributeAndBound, function(item) {
                    ngModelAttributes[item] = {
                        attribute: item,
                        bound: "ng-" + item
                    };
                }), _angularFix2["default"].forEach(statementOnly, function(item) {
                    var propName = "on" + item.substr(0, 1).toUpperCase() + item.substr(1);
                    ngModelAttributes[propName] = {
                        statement: "ng-" + item
                    };
                }), _angularFix2["default"].forEach(attributeOnly, function(item) {
                    ngModelAttributes[item] = {
                        attribute: item
                    };
                }), ngModelAttributes;
            }
            function getEpValue(ep, name) {
                return ep["templateOptions." + name] || ep["templateOptions['" + name + "']"] || ep['templateOptions["' + name + '"]'];
            }
            function addIfNotPresent(nodes, attr, val) {
                _angularFix2["default"].forEach(nodes, function(node) {
                    node.getAttribute(attr) || node.setAttribute(attr, val);
                });
            }
            function addRegardlessOfPresence(nodes, attr, val) {
                _angularFix2["default"].forEach(nodes, function(node) {
                    node.setAttribute(attr, val);
                });
            }
            function isPropertyAccessor(key) {
                return _otherUtils.contains(key, ".") || _otherUtils.contains(key, "[") && _otherUtils.contains(key, "]");
            }
            formlyConfig.extras.disableNgModelAttrsManipulator || formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);
        }
        addFormlyNgModelAttrsManipulator.$inject = [ "formlyConfig", "$interpolate" ], Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix), _otherUtils = __webpack_require__(9);
        exports["default"] = addFormlyNgModelAttrsManipulator, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function addCustomTags($document) {
            $document && $document.documentMode < 9 && !function() {
                var document = $document.get(0), customElements = [ "formly-field", "formly-form" ];
                _angularFix2["default"].forEach(customElements, function(el) {
                    document.createElement(el);
                });
            }();
        }
        addCustomTags.$inject = [ "$document" ], Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _angularFix = __webpack_require__(2), _angularFix2 = _interopRequireDefault(_angularFix);
        exports["default"] = addCustomTags, module.exports = exports["default"];
    } ]);
}), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("angular"), require("angular-formly"), require("api-check")) : "function" == typeof define && define.amd ? define([ "angular", "angular-formly", "api-check" ], factory) : "object" == typeof exports ? exports.ngFormlyTemplatesBootstrap = factory(require("angular"), require("angular-formly"), require("api-check")) : root.ngFormlyTemplatesBootstrap = factory(root.angular, root.ngFormly, root.apiCheck);
}(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = __webpack_require__(1);
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var ngModuleName = "formlyBootstrap", angular = __webpack_require__(2), ngModule = angular.module(ngModuleName, [ __webpack_require__(4) ]);
        ngModule.constant("formlyBootstrapApiCheck", __webpack_require__(5)({
            output: {
                prefix: "angular-formly-bootstrap"
            }
        })), ngModule.constant("formlyBootstrapVersion", "6.3.2"), __webpack_require__(6)(ngModule), 
        __webpack_require__(9)(ngModule), __webpack_require__(19)(ngModule), exports["default"] = ngModuleName, 
        module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var angular = __webpack_require__(3);
        angular.version || (angular = window.angular), module.exports = angular;
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_3__;
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_4__;
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addWrappers(formlyConfigProvider) {
                formlyConfigProvider.setWrapper([ {
                    name: "bootstrapLabel",
                    template: __webpack_require__(7),
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                label: check.string.optional,
                                required: check.bool.optional,
                                labelSrOnly: check.bool.optional
                            }
                        };
                    }
                }, {
                    name: "bootstrapHasError",
                    template: __webpack_require__(8)
                } ]);
            }
            ngModule.config(addWrappers), addWrappers.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = "<div>\n  <label for=\"{{id}}\" class=\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\" ng-if=\"to.label\">\n    {{to.label}}\n    {{to.required ? '*' : ''}}\n  </label>\n  <formly-transclude></formly-transclude>\n</div>\n";
    }, function(module, exports) {
        module.exports = '<div class="form-group" ng-class="{\'has-error\': showError}">\n  <formly-transclude></formly-transclude>\n</div>\n';
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            __webpack_require__(10)(ngModule), __webpack_require__(12)(ngModule), __webpack_require__(14)(ngModule), 
            __webpack_require__(15)(ngModule), __webpack_require__(17)(ngModule), __webpack_require__(18)(ngModule);
        }, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addCheckboxType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "checkbox",
                    template: __webpack_require__(11),
                    wrapper: [ "bootstrapHasError" ],
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                label: check.string
                            }
                        };
                    }
                });
            }
            ngModule.config(addCheckboxType), addCheckboxType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = '<div class="checkbox">\n	<label>\n		<input type="checkbox"\n           class="formly-field-checkbox"\n		       ng-model="model[options.key]">\n		{{to.label}}\n		{{to.required ? \'*\' : \'\'}}\n	</label>\n</div>\n';
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addCheckboxType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "multiCheckbox",
                    template: __webpack_require__(13),
                    wrapper: [ "bootstrapLabel", "bootstrapHasError" ],
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                options: check.arrayOf(check.object),
                                labelProp: check.string.optional,
                                valueProp: check.string.optional
                            }
                        };
                    },
                    defaultOptions: {
                        noFormControl: !1,
                        ngModelAttrs: {
                            required: {
                                attribute: "",
                                bound: ""
                            }
                        }
                    },
                    controller: [ "$scope", function($scope) {
                        function checkValidity(expressionValue) {
                            var valid;
                            $scope.to.required && (valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue, 
                            $scope.fc.$setValidity("required", valid));
                        }
                        function setModel() {
                            $scope.model[opts.key] = [], angular.forEach($scope.multiCheckbox.checked, function(checkbox, index) {
                                checkbox && $scope.model[opts.key].push(to.options[index][to.valueProp || "value"]);
                            }), $scope.fc.$setTouched(), checkValidity(!0), $scope.to.onChange && $scope.to.onChange();
                        }
                        var to = $scope.to, opts = $scope.options;
                        if ($scope.multiCheckbox = {
                            checked: [],
                            change: setModel
                        }, $scope.$watch("model", function(newModelValue) {
                            var modelValue, valueProp;
                            Object.keys(newModelValue).length && (modelValue = newModelValue[opts.key], $scope.$watch("to.options", function(newOptionsValues) {
                                if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {
                                    valueProp = to.valueProp || "value";
                                    for (var index = 0; index < newOptionsValues.length; index++) $scope.multiCheckbox.checked[index] = -1 !== modelValue.indexOf(newOptionsValues[index][valueProp]);
                                }
                            }));
                        }, !0), opts.expressionProperties && opts.expressionProperties["templateOptions.required"] && $scope.$watch(function() {
                            return $scope.to.required;
                        }, function(newValue) {
                            checkValidity(newValue);
                        }), $scope.to.required) var unwatchFormControl = $scope.$watch("fc", function(newValue) {
                            newValue && (checkValidity(!0), unwatchFormControl());
                        });
                    } ]
                });
            }
            ngModule.config(addCheckboxType), addCheckboxType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = '<div class="radio-group">\n  <div ng-repeat="(key, option) in to.options" class="checkbox">\n    <label>\n      <input type="checkbox"\n             id="{{id + \'_\'+ $index}}"\n             ng-model="multiCheckbox.checked[$index]"\n             ng-change="multiCheckbox.change()">\n      {{option[to.labelProp || \'name\']}}\n    </label>\n  </div>\n</div>\n';
    }, function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addInputType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "input",
                    template: '<input class="form-control" ng-model="model[options.key]">',
                    wrapper: [ "bootstrapLabel", "bootstrapHasError" ]
                });
            }
            ngModule.config(addInputType), addInputType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addRadioType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "radio",
                    template: __webpack_require__(16),
                    wrapper: [ "bootstrapLabel", "bootstrapHasError" ],
                    defaultOptions: {
                        noFormControl: !1
                    },
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                options: check.arrayOf(check.object),
                                labelProp: check.string.optional,
                                valueProp: check.string.optional
                            }
                        };
                    }
                });
            }
            ngModule.config(addRadioType), addRadioType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = '<div class="radio-group">\n  <div ng-repeat="(key, option) in to.options" class="radio">\n    <label>\n      <input type="radio"\n             id="{{id + \'_\'+ $index}}"\n             tabindex="0"\n             ng-value="option[to.valueProp || \'value\']"\n             ng-model="model[options.key]">\n      {{option[to.labelProp || \'name\']}}\n    </label>\n  </div>\n</div>\n';
    }, function(module, exports) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addSelectType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "select",
                    template: template,
                    wrapper: [ "bootstrapLabel", "bootstrapHasError" ],
                    defaultOptions: function(options) {
                        var ngOptions = options.templateOptions.ngOptions || "option[to.valueProp || 'value'] as option[to.labelProp || 'name'] group by option[to.groupProp || 'group'] for option in to.options";
                        return {
                            ngModelAttrs: _defineProperty({}, ngOptions, {
                                value: options.templateOptions.optionsAttr || "ng-options"
                            })
                        };
                    },
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                options: check.arrayOf(check.object),
                                optionsAttr: check.string.optional,
                                labelProp: check.string.optional,
                                valueProp: check.string.optional,
                                groupProp: check.string.optional
                            }
                        };
                    }
                });
            }
            ngModule.config(addSelectType);
            var template = '<select class="form-control" ng-model="model[options.key]"></select>';
            addSelectType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addTextareaType(formlyConfigProvider) {
                formlyConfigProvider.setType({
                    name: "textarea",
                    template: '<textarea class="form-control" ng-model="model[options.key]"></textarea>',
                    wrapper: [ "bootstrapLabel", "bootstrapHasError" ],
                    defaultOptions: {
                        ngModelAttrs: {
                            rows: {
                                attribute: "rows"
                            },
                            cols: {
                                attribute: "cols"
                            }
                        }
                    },
                    apiCheck: function(check) {
                        return {
                            templateOptions: {
                                rows: check.number.optional,
                                cols: check.number.optional
                            }
                        };
                    }
                });
            }
            ngModule.config(addTextareaType), addTextareaType.$inject = [ "formlyConfigProvider" ];
        }, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _addons = __webpack_require__(20), _addons2 = _interopRequireDefault(_addons), _description = __webpack_require__(22), _description2 = _interopRequireDefault(_description);
        exports["default"] = function(ngModule) {
            _addons2["default"](ngModule), _description2["default"](ngModule);
        }, module.exports = exports["default"];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {
                var addonTemplate = __webpack_require__(21), addonChecker = formlyBootstrapApiCheck.shape({
                    "class": formlyBootstrapApiCheck.string.optional,
                    text: formlyBootstrapApiCheck.string.optional,
                    onClick: formlyBootstrapApiCheck.func.optional
                }).strict.optional, api = formlyBootstrapApiCheck.shape({
                    templateOptions: formlyBootstrapApiCheck.shape({
                        addonLeft: addonChecker,
                        addonRight: addonChecker
                    })
                });
                formlyConfig.templateManipulators.preWrapper.push(function(template, options) {
                    return options.templateOptions.addonLeft || options.templateOptions.addonRight ? (formlyBootstrapApiCheck.warn([ api ], [ options ]), 
                    addonTemplate.replace("<formly-transclude></formly-transclude>", template)) : template;
                });
            }
            ngModule.run(addAddonsManipulator), addAddonsManipulator.$inject = [ "formlyConfig", "formlyBootstrapApiCheck" ];
        }, module.exports = exports["default"];
    }, function(module, exports) {
        module.exports = '<div ng-class="{\'input-group\': to.addonLeft || to.addonRight}">\n    <div class="input-group-addon"\n         ng-if="to.addonLeft"\n         ng-style="{cursor: to.addonLeft.onClick ? \'pointer\' : \'inherit\'}"\n         ng-click="to.addonLeft.onClick(options, this, $event)">\n        <i class="{{to.addonLeft.class}}" ng-if="to.addonLeft.class"></i>\n        <span ng-if="to.addonLeft.text">{{to.addonLeft.text}}</span>\n    </div>\n    <formly-transclude></formly-transclude>\n    <div class="input-group-addon"\n         ng-if="to.addonRight"\n         ng-style="{cursor: to.addonRight.onClick ? \'pointer\' : \'inherit\'}"\n         ng-click="to.addonRight.onClick(options, this, $event)">\n        <i class="{{to.addonRight.class}}" ng-if="to.addonRight.class"></i>\n        <span ng-if="to.addonRight.text">{{to.addonRight.text}}</span>\n    </div>\n</div>\n';
    }, function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports["default"] = function(ngModule) {
            function addDescriptionManipulator(formlyConfig) {
                formlyConfig.templateManipulators.preWrapper.push(function(template, options, scope) {
                    if (angular.isDefined(options.templateOptions.description)) {
                        var el = document.createElement("div");
                        el.appendChild(angular.element(template)[0]), el.appendChild(angular.element('<p id="' + scope.id + '_description"class="help-block"ng-if="to.description">{{to.description}}</p>')[0]);
                        var modelEls = angular.element(el.querySelectorAll("[ng-model]"));
                        return modelEls && modelEls.attr("aria-describedby", scope.id + "_description"), 
                        el.innerHTML;
                    }
                    return template;
                });
            }
            ngModule.run(addDescriptionManipulator), addDescriptionManipulator.$inject = [ "formlyConfig" ];
        }, module.exports = exports["default"];
    } ]);
}), angular.module("fluro.access", [ "fluro.content" ]), angular.module("fluro.access").service("FluroAccess", [ "$rootScope", "$q", "FluroContent", function($rootScope, $q, FluroContent) {
    var controller = {};
    return controller.isFluroAdmin = function() {
        return $rootScope.user ? "administrator" == $rootScope.user.accountType : !1;
    }, controller.getPermissionSets = function() {
        return $rootScope.user ? $rootScope.user.permissionSets : [];
    }, controller.has = function(permission) {
        if (!$rootScope.user) return !1;
        var permissionSets = $rootScope.user.permissionSets, permissions = _.chain(permissionSets).map(function(permissionSet) {
            return permissionSet.permissions;
        }).flatten().uniq().value();
        return _.includes(permissions, permission);
    }, controller.canAccess = function(type, parentType) {
        if (!$rootScope.user) return !1;
        if (controller.isFluroAdmin()) return !0;
        var canViewOwnRealms = (controller.retrieveActionableRealms("create " + type), controller.retrieveActionableRealms("view own " + type)), canViewAnyRealms = controller.retrieveActionableRealms("view any " + type), canEditOwnRealms = controller.retrieveActionableRealms("edit own " + type), canEditAnyRealms = controller.retrieveActionableRealms("edit any " + type), totalRealms = [];
        if (totalRealms = totalRealms.concat(canViewOwnRealms), totalRealms = totalRealms.concat(canViewAnyRealms), 
        totalRealms = totalRealms.concat(canEditOwnRealms), totalRealms = totalRealms.concat(canEditAnyRealms), 
        totalRealms.length) return !0;
        if (parentType && parentType.length) {
            var includeDefined = controller.retrieveActionableRealms("include defined " + parentType);
            if (!includeDefined.length) return !1;
            var canViewOwnRealmsOnParentType = (controller.retrieveActionableRealms("create " + parentType), 
            controller.retrieveActionableRealms("view own " + parentType)), canViewAnyRealmsOnParentType = controller.retrieveActionableRealms("view any " + parentType), canEditOwnRealmsOnParentType = controller.retrieveActionableRealms("edit own " + parentType), canEditAnyRealmsOnParentType = controller.retrieveActionableRealms("edit any " + parentType), totalRealms = [];
            if (totalRealms = totalRealms.concat(canViewOwnRealmsOnParentType), totalRealms = totalRealms.concat(canViewAnyRealmsOnParentType), 
            totalRealms = totalRealms.concat(canEditOwnRealmsOnParentType), totalRealms = totalRealms.concat(canEditAnyRealmsOnParentType), 
            totalRealms.length) return !0;
        }
        return !1;
    }, controller.retrieveActionableRealms = function(action) {
        if (!$rootScope.user) return [];
        var permissionSets = $rootScope.user.permissionSets;
        return _.chain(permissionSets).map(function(realmSet, key) {
            var searchString = action;
            return _.includes(realmSet.permissions, searchString) ? key.toString() : void 0;
        }).compact().value();
    }, controller.retrieveSelectableRealms = function(action, type, parentType, noCache) {
        if (!$rootScope.user) return [];
        var realms;
        if (controller.isFluroAdmin()) realms = FluroContent.resource("realm", !1, noCache).query({
            list: !0,
            sort: "title"
        }); else {
            var permissionSets = $rootScope.user.permissionSets, searchString = action + " " + type, createableRealms = _.chain(permissionSets).filter(function(realmSet, key) {
                var includedFromParent, includesType = _.includes(realmSet.permissions, searchString);
                if (parentType && parentType.length) {
                    var includesParent = _.includes(realmSet.permissions, action + " " + parentType), includesVariations = _.includes(realmSet.permissions, "include defined " + parentType);
                    includedFromParent = includesParent && includesVariations;
                }
                return includesType || includedFromParent;
            }).compact().sortBy("title").value();
            realms = createableRealms;
        }
        return realms;
    }, controller.can = function(action, type, parentType) {
        if (!$rootScope.user) return !1;
        if (controller.isFluroAdmin()) return !0;
        var perm = action + " " + type, realms = [];
        switch (action) {
          case "view any":
            var canViewAnyRealms = controller.retrieveActionableRealms("view any " + type), canEditAnyRealms = controller.retrieveActionableRealms("edit any " + type);
            realms = realms.concat(canViewAnyRealms), realms = realms.concat(canEditAnyRealms);
            break;

          case "view own":
            var canViewOwnRealms = controller.retrieveActionableRealms("view own " + type), canEditOwnRealms = controller.retrieveActionableRealms("edit own " + type);
            realms = realms.concat(canViewOwnRealms), realms = realms.concat(canEditOwnRealms);
            break;

          default:
            realms = controller.retrieveActionableRealms(perm);
        }
        if (realms.length) return !0;
        if (parentType && parentType.length) {
            var includeDefined = controller.retrieveActionableRealms("include defined " + parentType);
            if (!includeDefined.length) return !1;
            switch (action) {
              case "view any":
                controller.retrieveActionableRealms("view any " + parentType), controller.retrieveActionableRealms("edit any " + parentType);
                realms = realms.concat(canViewAnyRealms), realms = realms.concat(canEditAnyRealms);
                break;

              case "view own":
                var canViewOwnParentRealms = controller.retrieveActionableRealms("view own " + parentType), canEditOwnParentRealms = controller.retrieveActionableRealms("edit own " + parentType);
                realms = realms.concat(canViewOwnParentRealms), realms = realms.concat(canEditOwnParentRealms);
                break;

              default:
                realms = controller.retrieveActionableRealms(action + " " + parentType);
            }
            if (realms.length) return !0;
        }
        return !1;
    }, controller.isAuthor = function(item) {
        if (!$rootScope.user) return !1;
        var author = !1;
        return author = _.isObject(item.author) ? item.author._id == $rootScope.user._id : item.author == $rootScope.user._id, 
        !author && item.owners && item.owners.length && (author = _.some(item.owners, function(owner) {
            var ownerId = owner;
            return ownerId && ownerId._id && (ownerId = ownerId._id), ownerId == $rootScope.user._id;
        })), $rootScope.user._id == item._id && (author = !0), author;
    }, controller.canEditItem = function(item, user) {
        if (!item) return console.log("No item"), !1;
        if (!$rootScope.user) return console.log("No user"), !1;
        var userAccountID = $rootScope.user.account;
        userAccountID && (userAccountID = userAccountID._id);
        var contentAccountID = item.account;
        if (contentAccountID && contentAccountID._id && (contentAccountID = contentAccountID._id), 
        contentAccountID && contentAccountID != userAccountID) return !1;
        if (controller.isFluroAdmin()) return !0;
        var parentType, definitionName = item._type;
        item.definition && (definitionName = item.definition, parentType = item._type);
        var author = controller.isAuthor(item);
        if (user && (definitionName = "user", author)) return !0;
        switch (definitionName) {
          case "realm":
            return author ? controller.has("edit own realm") : controller.has("edit any realm");
        }
        var editAnyRealms = controller.retrieveActionableRealms("edit any " + definitionName), editOwnRealms = controller.retrieveActionableRealms("edit own " + definitionName), contentRealmIds = _.map(item.realms, function(realm) {
            return realm._id ? realm._id : realm;
        });
        if (parentType && parentType.length) {
            var includeDefined = controller.retrieveActionableRealms("include defined " + parentType);
            if (includeDefined.length) {
                var canEditAnyParentRealms = controller.retrieveActionableRealms("edit any " + parentType);
                editAnyRealms = editAnyRealms.concat(canEditAnyParentRealms);
                var canEditOwnParentRealms = controller.retrieveActionableRealms("edit own " + parentType);
                editOwnRealms = editOwnRealms.concat(canEditOwnParentRealms);
            }
        }
        var matchedAnyRealms = _.intersection(editAnyRealms, contentRealmIds);
        if (matchedAnyRealms.length) return !0;
        if (author) {
            var matchedOwnRealms = _.intersection(editOwnRealms, contentRealmIds);
            if (matchedOwnRealms.length) return !0;
        }
        console.log("No Realms", definitionName, contentRealmIds, editOwnRealms, matchedOwnRealms, matchedAnyRealms);
    }, controller.canViewItem = function(item, user) {
        if (!$rootScope.user) return !1;
        if (controller.isFluroAdmin()) return !0;
        var parentType, definitionName = item._type;
        item.definition && (definitionName = item.definition, parentType = item._type);
        var author = controller.isAuthor(item);
        if (user && (definitionName = "user", author)) return !0;
        var viewAnyRealms = controller.retrieveActionableRealms("view any " + definitionName), viewOwnRealms = controller.retrieveActionableRealms("view own " + definitionName), editAnyRealms = controller.retrieveActionableRealms("edit any " + definitionName), editOwnRealms = controller.retrieveActionableRealms("edit own " + definitionName), combinedAnyRealms = [];
        combinedAnyRealms = combinedAnyRealms.concat(viewAnyRealms), combinedAnyRealms = combinedAnyRealms.concat(editAnyRealms);
        var combinedOwnRealms = [];
        combinedOwnRealms = combinedOwnRealms.concat(viewOwnRealms), combinedOwnRealms = combinedOwnRealms.concat(editOwnRealms);
        var contentRealmIds = _.map(item.realms, function(realm) {
            return realm._id ? realm._id : realm;
        });
        if (parentType && parentType.length) {
            var includeDefined = controller.retrieveActionableRealms("include defined " + parentType);
            if (includeDefined.length) {
                var canEditAnyParentRealms = controller.retrieveActionableRealms("edit any " + parentType), canViewAnyParentRealms = controller.retrieveActionableRealms("view any " + parentType);
                combinedAnyRealms = combinedAnyRealms.concat(canEditAnyParentRealms, canViewAnyParentRealms);
                var canEditOwnParentRealms = controller.retrieveActionableRealms("edit own " + parentType), canViewOwnParentRealms = controller.retrieveActionableRealms("view own " + parentType);
                combinedOwnRealms = combinedOwnRealms.concat(canEditOwnParentRealms, canViewOwnParentRealms);
            }
        }
        var matchedAnyRealms = _.intersection(combinedAnyRealms, contentRealmIds);
        if (matchedAnyRealms.length) return !0;
        if (author) {
            var matchedOwnRealms = _.intersection(combinedOwnRealms, contentRealmIds);
            if (matchedOwnRealms.length) return !0;
        }
    }, controller.canDeleteItem = function(item, user) {
        if (!$rootScope.user) return !1;
        var userAccountID = $rootScope.user.account;
        userAccountID && (userAccountID = userAccountID._id);
        var contentAccountID = item.account;
        if (contentAccountID && contentAccountID._id && (contentAccountID = contentAccountID._id), 
        contentAccountID && contentAccountID != userAccountID) return !1;
        if (controller.isFluroAdmin()) return !0;
        var parentType, definitionName = item._type;
        item.definition && (definitionName = item.definition, parentType = item._type);
        var author = controller.isAuthor(item);
        if (user && (definitionName = "user", author)) return !0;
        switch (definitionName) {
          case "realm":
            return author ? controller.has("delete own realm") : controller.has("delete any realm");
        }
        var deleteAnyRealms = controller.retrieveActionableRealms("delete any " + definitionName), deleteOwnRealms = controller.retrieveActionableRealms("delete own " + definitionName), contentRealmIds = _.map(item.realms, function(realm) {
            return realm && realm._id ? realm._id : realm;
        });
        if (parentType && parentType.length) {
            var includeDefined = controller.retrieveActionableRealms("include defined " + parentType);
            if (includeDefined.length) {
                var canDeleteAnyParentRealms = controller.retrieveActionableRealms("delete any " + parentType);
                deleteAnyRealms = deleteAnyRealms.concat(canDeleteAnyParentRealms);
                var canDeleteOwnParentRealms = controller.retrieveActionableRealms("delete own " + parentType);
                deleteOwnRealms = deleteOwnRealms.concat(canDeleteOwnParentRealms);
            }
        }
        var matchedAnyRealms = _.intersection(deleteAnyRealms, contentRealmIds);
        if (matchedAnyRealms.length) return !0;
        if (author) {
            var matchedOwnRealms = _.intersection(deleteOwnRealms, contentRealmIds);
            if (matchedOwnRealms.length) return !0;
        }
    }, controller.resolveIf = function(bool) {
        var deferred = $q.defer();
        return bool ? deferred.resolve() : deferred.reject(), deferred.promise;
    }, controller;
} ]), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.validator = factory();
}(this, function() {
    "use strict";
    function assertString(input) {
        if ("string" != typeof input) throw new TypeError("This library (validator.js) validates strings only");
    }
    function toDate(date) {
        return assertString(date), date = Date.parse(date), isNaN(date) ? null : new Date(date);
    }
    function toFloat(str) {
        return assertString(str), parseFloat(str);
    }
    function toInt(str, radix) {
        return assertString(str), parseInt(str, radix || 10);
    }
    function toBoolean(str, strict) {
        return assertString(str), strict ? "1" === str || "true" === str : "0" !== str && "false" !== str && "" !== str;
    }
    function equals(str, comparison) {
        return assertString(str), str === comparison;
    }
    function toString(input) {
        return "object" === ("undefined" == typeof input ? "undefined" : _typeof(input)) && null !== input ? input = "function" == typeof input.toString ? input.toString() : "[object Object]" : (null === input || "undefined" == typeof input || isNaN(input) && !input.length) && (input = ""), 
        String(input);
    }
    function contains(str, elem) {
        return assertString(str), str.indexOf(toString(elem)) >= 0;
    }
    function matches(str, pattern, modifiers) {
        return assertString(str), "[object RegExp]" !== Object.prototype.toString.call(pattern) && (pattern = new RegExp(pattern, modifiers)), 
        pattern.test(str);
    }
    function merge() {
        var obj = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, defaults = arguments[1];
        for (var key in defaults) "undefined" == typeof obj[key] && (obj[key] = defaults[key]);
        return obj;
    }
    function isByteLength(str, options) {
        assertString(str);
        var min = void 0, max = void 0;
        "object" === ("undefined" == typeof options ? "undefined" : _typeof(options)) ? (min = options.min || 0, 
        max = options.max) : (min = arguments[1], max = arguments[2]);
        var len = encodeURI(str).split(/%..|./).length - 1;
        return len >= min && ("undefined" == typeof max || max >= len);
    }
    function isFDQN(str, options) {
        assertString(str), options = merge(options, default_fqdn_options), options.allow_trailing_dot && "." === str[str.length - 1] && (str = str.substring(0, str.length - 1));
        var parts = str.split(".");
        if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) return !1;
        }
        for (var part, i = 0; i < parts.length; i++) {
            if (part = parts[i], options.allow_underscores && (part = part.replace(/_/g, "")), 
            !/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) return !1;
            if (/[\uff01-\uff5e]/.test(part)) return !1;
            if ("-" === part[0] || "-" === part[part.length - 1]) return !1;
        }
        return !0;
    }
    function isEmail(str, options) {
        if (assertString(str), options = merge(options, default_email_options), options.require_display_name || options.allow_display_name) {
            var display_email = str.match(displayName);
            if (display_email) str = display_email[1]; else if (options.require_display_name) return !1;
        }
        var parts = str.split("@"), domain = parts.pop(), user = parts.join("@"), lower_domain = domain.toLowerCase();
        if (("gmail.com" === lower_domain || "googlemail.com" === lower_domain) && (user = user.replace(/\./g, "").toLowerCase()), 
        !isByteLength(user, {
            max: 64
        }) || !isByteLength(domain, {
            max: 256
        })) return !1;
        if (!isFDQN(domain, {
            require_tld: options.require_tld
        })) return !1;
        if ('"' === user[0]) return user = user.slice(1, user.length - 1), options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
        for (var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart, user_parts = user.split("."), i = 0; i < user_parts.length; i++) if (!pattern.test(user_parts[i])) return !1;
        return !0;
    }
    function isIP(str) {
        var version = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        if (assertString(str), version = String(version), !version) return isIP(str, 4) || isIP(str, 6);
        if ("4" === version) {
            if (!ipv4Maybe.test(str)) return !1;
            var parts = str.split(".").sort(function(a, b) {
                return a - b;
            });
            return parts[3] <= 255;
        }
        if ("6" === version) {
            var blocks = str.split(":"), foundOmissionBlock = !1, foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4), expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
            if (blocks.length > expectedNumberOfBlocks) return !1;
            if ("::" === str) return !0;
            "::" === str.substr(0, 2) ? (blocks.shift(), blocks.shift(), foundOmissionBlock = !0) : "::" === str.substr(str.length - 2) && (blocks.pop(), 
            blocks.pop(), foundOmissionBlock = !0);
            for (var i = 0; i < blocks.length; ++i) if ("" === blocks[i] && i > 0 && i < blocks.length - 1) {
                if (foundOmissionBlock) return !1;
                foundOmissionBlock = !0;
            } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ; else if (!ipv6Block.test(blocks[i])) return !1;
            return foundOmissionBlock ? blocks.length >= 1 : blocks.length === expectedNumberOfBlocks;
        }
        return !1;
    }
    function isRegExp(obj) {
        return "[object RegExp]" === Object.prototype.toString.call(obj);
    }
    function checkHost(host, matches) {
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            if (host === match || isRegExp(match) && match.test(host)) return !0;
        }
        return !1;
    }
    function isURL(url, options) {
        if (assertString(url), !url || url.length >= 2083 || /[\s<>]/.test(url)) return !1;
        if (0 === url.indexOf("mailto:")) return !1;
        options = merge(options, default_url_options);
        var protocol = void 0, auth = void 0, host = void 0, hostname = void 0, port = void 0, port_str = void 0, split = void 0, ipv6 = void 0;
        if (split = url.split("#"), url = split.shift(), split = url.split("?"), url = split.shift(), 
        split = url.split("://"), split.length > 1) {
            if (protocol = split.shift(), options.require_valid_protocol && -1 === options.protocols.indexOf(protocol)) return !1;
        } else {
            if (options.require_protocol) return !1;
            options.allow_protocol_relative_urls && "//" === url.substr(0, 2) && (split[0] = url.substr(2));
        }
        if (url = split.join("://"), split = url.split("/"), url = split.shift(), "" === url && !options.require_host) return !0;
        if (split = url.split("@"), split.length > 1 && (auth = split.shift(), auth.indexOf(":") >= 0 && auth.split(":").length > 2)) return !1;
        hostname = split.join("@"), port_str = ipv6 = null;
        var ipv6_match = hostname.match(wrapped_ipv6);
        return ipv6_match ? (host = "", ipv6 = ipv6_match[1], port_str = ipv6_match[2] || null) : (split = hostname.split(":"), 
        host = split.shift(), split.length && (port_str = split.join(":"))), null !== port_str && (port = parseInt(port_str, 10), 
        !/^[0-9]+$/.test(port_str) || 0 >= port || port > 65535) ? !1 : isIP(host) || isFDQN(host, options) || ipv6 && isIP(ipv6, 6) || "localhost" === host ? (host = host || ipv6, 
        options.host_whitelist && !checkHost(host, options.host_whitelist) ? !1 : options.host_blacklist && checkHost(host, options.host_blacklist) ? !1 : !0) : !1;
    }
    function isMACAddress(str) {
        return assertString(str), macAddress.test(str);
    }
    function isBoolean(str) {
        return assertString(str), [ "true", "false", "1", "0" ].indexOf(str) >= 0;
    }
    function isAlpha(str) {
        var locale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US";
        if (assertString(str), locale in alpha) return alpha[locale].test(str);
        throw new Error("Invalid locale '" + locale + "'");
    }
    function isAlphanumeric(str) {
        var locale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US";
        if (assertString(str), locale in alphanumeric) return alphanumeric[locale].test(str);
        throw new Error("Invalid locale '" + locale + "'");
    }
    function isNumeric(str) {
        return assertString(str), numeric.test(str);
    }
    function isLowercase(str) {
        return assertString(str), str === str.toLowerCase();
    }
    function isUppercase(str) {
        return assertString(str), str === str.toUpperCase();
    }
    function isAscii(str) {
        return assertString(str), ascii.test(str);
    }
    function isFullWidth(str) {
        return assertString(str), fullWidth.test(str);
    }
    function isHalfWidth(str) {
        return assertString(str), halfWidth.test(str);
    }
    function isVariableWidth(str) {
        return assertString(str), fullWidth.test(str) && halfWidth.test(str);
    }
    function isMultibyte(str) {
        return assertString(str), multibyte.test(str);
    }
    function isSurrogatePair(str) {
        return assertString(str), surrogatePair.test(str);
    }
    function isInt(str, options) {
        assertString(str), options = options || {};
        var regex = options.hasOwnProperty("allow_leading_zeroes") && !options.allow_leading_zeroes ? int : intLeadingZeroes, minCheckPassed = !options.hasOwnProperty("min") || str >= options.min, maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max, ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt, gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
        return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }
    function isFloat(str, options) {
        return assertString(str), options = options || {}, "" === str || "." === str ? !1 : float.test(str) && (!options.hasOwnProperty("min") || str >= options.min) && (!options.hasOwnProperty("max") || str <= options.max) && (!options.hasOwnProperty("lt") || str < options.lt) && (!options.hasOwnProperty("gt") || str > options.gt);
    }
    function isDecimal(str) {
        return assertString(str), "" !== str && decimal.test(str);
    }
    function isHexadecimal(str) {
        return assertString(str), hexadecimal.test(str);
    }
    function isDivisibleBy(str, num) {
        return assertString(str), toFloat(str) % parseInt(num, 10) === 0;
    }
    function isHexColor(str) {
        return assertString(str), hexcolor.test(str);
    }
    function isMD5(str) {
        return assertString(str), md5.test(str);
    }
    function isJSON(str) {
        assertString(str);
        try {
            var obj = JSON.parse(str);
            return !!obj && "object" === ("undefined" == typeof obj ? "undefined" : _typeof(obj));
        } catch (e) {}
        return !1;
    }
    function isEmpty(str) {
        return assertString(str), 0 === str.length;
    }
    function isLength(str, options) {
        assertString(str);
        var min = void 0, max = void 0;
        "object" === ("undefined" == typeof options ? "undefined" : _typeof(options)) ? (min = options.min || 0, 
        max = options.max) : (min = arguments[1], max = arguments[2]);
        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [], len = str.length - surrogatePairs.length;
        return len >= min && ("undefined" == typeof max || max >= len);
    }
    function isUUID(str) {
        var version = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "all";
        assertString(str);
        var pattern = uuid[version];
        return pattern && pattern.test(str);
    }
    function isMongoId(str) {
        return assertString(str), isHexadecimal(str) && 24 === str.length;
    }
    function isISO8601(str) {
        return assertString(str), iso8601.test(str);
    }
    function getTimezoneOffset(str) {
        var iso8601Parts = str.match(iso8601), timezone = void 0, sign = void 0, hours = void 0, minutes = void 0;
        if (iso8601Parts) {
            if (timezone = iso8601Parts[21], !timezone) return iso8601Parts[12] ? null : 0;
            if ("z" === timezone || "Z" === timezone) return 0;
            sign = iso8601Parts[22], -1 !== timezone.indexOf(":") ? (hours = parseInt(iso8601Parts[23], 10), 
            minutes = parseInt(iso8601Parts[24], 10)) : (hours = 0, minutes = parseInt(iso8601Parts[23], 10));
        } else {
            if (str = str.toLowerCase(), timezone = str.match(/(?:\s|gmt\s*)(-|\+)(\d{1,4})(\s|$)/), 
            !timezone) return -1 !== str.indexOf("gmt") ? 0 : null;
            sign = timezone[1];
            var offset = timezone[2];
            3 === offset.length && (offset = "0" + offset), offset.length <= 2 ? (hours = 0, 
            minutes = parseInt(offset, 10)) : (hours = parseInt(offset.slice(0, 2), 10), minutes = parseInt(offset.slice(2, 4), 10));
        }
        return (60 * hours + minutes) * ("-" === sign ? 1 : -1);
    }
    function isDate(str) {
        assertString(str);
        var normalizedDate = new Date(Date.parse(str));
        if (isNaN(normalizedDate)) return !1;
        var timezoneOffset = getTimezoneOffset(str);
        if (null !== timezoneOffset) {
            var timezoneDifference = normalizedDate.getTimezoneOffset() - timezoneOffset;
            normalizedDate = new Date(normalizedDate.getTime() + 6e4 * timezoneDifference);
        }
        var day = String(normalizedDate.getDate()), dayOrYear = void 0, dayOrYearMatches = void 0, year = void 0;
        return (dayOrYearMatches = str.match(/(^|[^:\d])[23]\d([^T:\d]|$)/g)) ? (dayOrYear = dayOrYearMatches.map(function(digitString) {
            return digitString.match(/\d+/g)[0];
        }).join("/"), year = String(normalizedDate.getFullYear()).slice(-2), dayOrYear === day || dayOrYear === year ? !0 : dayOrYear === "" + day / year || dayOrYear === "" + year / day ? !0 : !1) : !0;
    }
    function isAfter(str) {
        var date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : String(new Date());
        assertString(str);
        var comparison = toDate(date), original = toDate(str);
        return !!(original && comparison && original > comparison);
    }
    function isBefore(str) {
        var date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : String(new Date());
        assertString(str);
        var comparison = toDate(date), original = toDate(str);
        return !!(original && comparison && comparison > original);
    }
    function isIn(str, options) {
        assertString(str);
        var i = void 0;
        if ("[object Array]" === Object.prototype.toString.call(options)) {
            var array = [];
            for (i in options) ({}).hasOwnProperty.call(options, i) && (array[i] = toString(options[i]));
            return array.indexOf(str) >= 0;
        }
        return "object" === ("undefined" == typeof options ? "undefined" : _typeof(options)) ? options.hasOwnProperty(str) : options && "function" == typeof options.indexOf ? options.indexOf(str) >= 0 : !1;
    }
    function isCreditCard(str) {
        assertString(str);
        var sanitized = str.replace(/[^0-9]+/g, "");
        if (!creditCard.test(sanitized)) return !1;
        for (var sum = 0, digit = void 0, tmpNum = void 0, shouldDouble = void 0, i = sanitized.length - 1; i >= 0; i--) digit = sanitized.substring(i, i + 1), 
        tmpNum = parseInt(digit, 10), shouldDouble ? (tmpNum *= 2, sum += tmpNum >= 10 ? tmpNum % 10 + 1 : tmpNum) : sum += tmpNum, 
        shouldDouble = !shouldDouble;
        return !!(sum % 10 === 0 ? sanitized : !1);
    }
    function isISIN(str) {
        if (assertString(str), !isin.test(str)) return !1;
        for (var checksumStr = str.replace(/[A-Z]/g, function(character) {
            return parseInt(character, 36);
        }), sum = 0, digit = void 0, tmpNum = void 0, shouldDouble = !0, i = checksumStr.length - 2; i >= 0; i--) digit = checksumStr.substring(i, i + 1), 
        tmpNum = parseInt(digit, 10), shouldDouble ? (tmpNum *= 2, sum += tmpNum >= 10 ? tmpNum + 1 : tmpNum) : sum += tmpNum, 
        shouldDouble = !shouldDouble;
        return parseInt(str.substr(str.length - 1), 10) === (1e4 - sum) % 10;
    }
    function isISBN(str) {
        var version = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        if (assertString(str), version = String(version), !version) return isISBN(str, 10) || isISBN(str, 13);
        var sanitized = str.replace(/[\s-]+/g, ""), checksum = 0, i = void 0;
        if ("10" === version) {
            if (!isbn10Maybe.test(sanitized)) return !1;
            for (i = 0; 9 > i; i++) checksum += (i + 1) * sanitized.charAt(i);
            if (checksum += "X" === sanitized.charAt(9) ? 100 : 10 * sanitized.charAt(9), checksum % 11 === 0) return !!sanitized;
        } else if ("13" === version) {
            if (!isbn13Maybe.test(sanitized)) return !1;
            for (i = 0; 12 > i; i++) checksum += factor[i % 2] * sanitized.charAt(i);
            if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) return !!sanitized;
        }
        return !1;
    }
    function isISSN(str) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        assertString(str);
        var testIssn = issn;
        if (testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn, testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i"), 
        !testIssn.test(str)) return !1;
        var issnDigits = str.replace("-", ""), position = 8, checksum = 0, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
        try {
            for (var _step, _iterator = issnDigits[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                var digit = _step.value, digitValue = "X" === digit.toUpperCase() ? 10 : +digit;
                checksum += digitValue * position, --position;
            }
        } catch (err) {
            _didIteratorError = !0, _iteratorError = err;
        } finally {
            try {
                !_iteratorNormalCompletion && _iterator["return"] && _iterator["return"]();
            } finally {
                if (_didIteratorError) throw _iteratorError;
            }
        }
        return checksum % 11 === 0;
    }
    function isMobilePhone(str, locale) {
        return assertString(str), locale in phones ? phones[locale].test(str) : !1;
    }
    function currencyRegex(options) {
        var symbol = "(\\" + options.symbol.replace(/\./g, "\\.") + ")" + (options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\" + options.thousands_separator + "\\d{3})*", valid_whole_dollar_amounts = [ "0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep ], whole_dollar_amount = "(" + valid_whole_dollar_amounts.join("|") + ")?", decimal_amount = "(\\" + options.decimal_separator + "\\d{2})?", pattern = whole_dollar_amount + decimal_amount;
        return options.allow_negatives && !options.parens_for_negatives && (options.negative_sign_after_digits ? pattern += negative : options.negative_sign_before_digits && (pattern = negative + pattern)), 
        options.allow_negative_sign_placeholder ? pattern = "( (?!\\-))?" + pattern : options.allow_space_after_symbol ? pattern = " ?" + pattern : options.allow_space_after_digits && (pattern += "( (?!$))?"), 
        options.symbol_after_digits ? pattern += symbol : pattern = symbol + pattern, options.allow_negatives && (options.parens_for_negatives ? pattern = "(\\(" + pattern + "\\)|" + pattern + ")" : options.negative_sign_before_digits || options.negative_sign_after_digits || (pattern = negative + pattern)), 
        new RegExp("^(?!-? )(?=.*\\d)" + pattern + "$");
    }
    function isCurrency(str, options) {
        return assertString(str), options = merge(options, default_currency_options), currencyRegex(options).test(str);
    }
    function isBase64(str) {
        assertString(str);
        var len = str.length;
        if (!len || len % 4 !== 0 || notBase64.test(str)) return !1;
        var firstPaddingChar = str.indexOf("=");
        return -1 === firstPaddingChar || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && "=" === str[len - 1];
    }
    function isDataURI(str) {
        return assertString(str), dataURI.test(str);
    }
    function ltrim(str, chars) {
        assertString(str);
        var pattern = chars ? new RegExp("^[" + chars + "]+", "g") : /^\s+/g;
        return str.replace(pattern, "");
    }
    function rtrim(str, chars) {
        assertString(str);
        for (var pattern = chars ? new RegExp("[" + chars + "]") : /\s/, idx = str.length - 1; idx >= 0 && pattern.test(str[idx]); ) idx--;
        return idx < str.length ? str.substr(0, idx + 1) : str;
    }
    function trim(str, chars) {
        return rtrim(ltrim(str, chars), chars);
    }
    function escape(str) {
        return assertString(str), str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
    }
    function unescape(str) {
        return assertString(str), str.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#96;/g, "`");
    }
    function blacklist(str, chars) {
        return assertString(str), str.replace(new RegExp("[" + chars + "]+", "g"), "");
    }
    function stripLow(str, keep_new_lines) {
        assertString(str);
        var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
        return blacklist(str, chars);
    }
    function whitelist(str, chars) {
        return assertString(str), str.replace(new RegExp("[^" + chars + "]+", "g"), "");
    }
    function isWhitelisted(str, chars) {
        assertString(str);
        for (var i = str.length - 1; i >= 0; i--) if (-1 === chars.indexOf(str[i])) return !1;
        return !0;
    }
    function normalizeEmail(email, options) {
        if (options = merge(options, default_normalize_email_options), !isEmail(email)) return !1;
        var raw_parts = email.split("@"), domain = raw_parts.pop(), user = raw_parts.join("@"), parts = [ user, domain ];
        if (parts[1] = parts[1].toLowerCase(), "gmail.com" === parts[1] || "googlemail.com" === parts[1]) {
            if (options.gmail_remove_subaddress && (parts[0] = parts[0].split("+")[0]), options.gmail_remove_dots && (parts[0] = parts[0].replace(/\./g, "")), 
            !parts[0].length) return !1;
            (options.all_lowercase || options.gmail_lowercase) && (parts[0] = parts[0].toLowerCase()), 
            parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
        } else if (~icloud_domains.indexOf(parts[1])) {
            if (options.icloud_remove_subaddress && (parts[0] = parts[0].split("+")[0]), !parts[0].length) return !1;
            (options.all_lowercase || options.icloud_lowercase) && (parts[0] = parts[0].toLowerCase());
        } else if (~outlookdotcom_domains.indexOf(parts[1])) {
            if (options.outlookdotcom_remove_subaddress && (parts[0] = parts[0].split("+")[0]), 
            !parts[0].length) return !1;
            (options.all_lowercase || options.outlookdotcom_lowercase) && (parts[0] = parts[0].toLowerCase());
        } else if (~yahoo_domains.indexOf(parts[1])) {
            if (options.yahoo_remove_subaddress) {
                var components = parts[0].split("-");
                parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
            }
            if (!parts[0].length) return !1;
            (options.all_lowercase || options.yahoo_lowercase) && (parts[0] = parts[0].toLowerCase());
        } else options.all_lowercase && (parts[0] = parts[0].toLowerCase());
        return parts.join("@");
    }
    for (var locale, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, default_fqdn_options = (function() {
        function AwaitValue(value) {
            this.value = value;
        }
        function AsyncGenerator(gen) {
            function send(key, arg) {
                return new Promise(function(resolve, reject) {
                    var request = {
                        key: key,
                        arg: arg,
                        resolve: resolve,
                        reject: reject,
                        next: null
                    };
                    back ? back = back.next = request : (front = back = request, resume(key, arg));
                });
            }
            function resume(key, arg) {
                try {
                    var result = gen[key](arg), value = result.value;
                    value instanceof AwaitValue ? Promise.resolve(value.value).then(function(arg) {
                        resume("next", arg);
                    }, function(arg) {
                        resume("throw", arg);
                    }) : settle(result.done ? "return" : "normal", result.value);
                } catch (err) {
                    settle("throw", err);
                }
            }
            function settle(type, value) {
                switch (type) {
                  case "return":
                    front.resolve({
                        value: value,
                        done: !0
                    });
                    break;

                  case "throw":
                    front.reject(value);
                    break;

                  default:
                    front.resolve({
                        value: value,
                        done: !1
                    });
                }
                front = front.next, front ? resume(front.key, front.arg) : back = null;
            }
            var front, back;
            this._invoke = send, "function" != typeof gen["return"] && (this["return"] = void 0);
        }
        return "function" == typeof Symbol && Symbol.asyncIterator && (AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
            return this;
        }), AsyncGenerator.prototype.next = function(arg) {
            return this._invoke("next", arg);
        }, AsyncGenerator.prototype["throw"] = function(arg) {
            return this._invoke("throw", arg);
        }, AsyncGenerator.prototype["return"] = function(arg) {
            return this._invoke("return", arg);
        }, {
            wrap: function(fn) {
                return function() {
                    return new AsyncGenerator(fn.apply(this, arguments));
                };
            },
            await: function(value) {
                return new AwaitValue(value);
            }
        };
    }(), {
        require_tld: !0,
        allow_underscores: !1,
        allow_trailing_dot: !1
    }), default_email_options = {
        allow_display_name: !1,
        require_display_name: !1,
        allow_utf8_local_part: !0,
        require_tld: !0
    }, displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i, emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i, quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i, emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i, quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i, ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/, ipv6Block = /^[0-9A-F]{1,4}$/i, default_url_options = {
        protocols: [ "http", "https", "ftp" ],
        require_tld: !0,
        require_protocol: !1,
        require_host: !0,
        require_valid_protocol: !0,
        allow_underscores: !1,
        allow_trailing_dot: !1,
        allow_protocol_relative_urls: !1
    }, wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/, macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/, alpha = {
        "en-US": /^[A-Z]+$/i,
        "cs-CZ": /^[A-Z]+$/i,
        "da-DK": /^[A-Z]+$/i,
        "de-DE": /^[A-Z]+$/i,
        "es-ES": /^[A-Z]+$/i,
        "fr-FR": /^[A-Z]+$/i,
        "nl-NL": /^[A-Z]+$/i,
        "hu-HU": /^[A-Z]+$/i,
        "pl-PL": /^[A-Z]+$/i,
        "pt-PT": /^[A-Z]+$/i,
        "ru-RU": /^[-]+$/i,
        "sr-RS@latin": /^[A-Z]+$/i,
        "sr-RS": /^[-]+$/i,
        "tr-TR": /^[A-Z]+$/i,
        "uk-UA": /^[-I]+$/i,
        ar: /^[]+$/
    }, alphanumeric = {
        "en-US": /^[0-9A-Z]+$/i,
        "cs-CZ": /^[0-9A-Z]+$/i,
        "da-DK": /^[0-9A-Z]$/i,
        "de-DE": /^[0-9A-Z]+$/i,
        "es-ES": /^[0-9A-Z]+$/i,
        "fr-FR": /^[0-9A-Z]+$/i,
        "hu-HU": /^[0-9A-Z]+$/i,
        "nl-NL": /^[0-9A-Z]+$/i,
        "pl-PL": /^[0-9A-Z]+$/i,
        "pt-PT": /^[0-9A-Z]+$/i,
        "ru-RU": /^[0-9-]+$/i,
        "sr-RS@latin": /^[0-9A-Z]+$/i,
        "sr-RS": /^[0-9-]+$/i,
        "tr-TR": /^[0-9A-Z]+$/i,
        "uk-UA": /^[0-9-I]+$/i,
        ar: /^[0-9]+$/
    }, englishLocales = [ "AU", "GB", "HK", "IN", "NZ", "ZA", "ZM" ], i = 0; i < englishLocales.length; i++) locale = "en-" + englishLocales[i], 
    alpha[locale] = alpha["en-US"], alphanumeric[locale] = alphanumeric["en-US"];
    alpha["pt-BR"] = alpha["pt-PT"], alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    for (var _locale, arabicLocales = [ "AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE" ], _i = 0; _i < arabicLocales.length; _i++) _locale = "ar-" + arabicLocales[_i], 
    alpha[_locale] = alpha.ar, alphanumeric[_locale] = alphanumeric.ar;
    var numeric = /^[-+]?[0-9]+$/, ascii = /^[\x00-\x7F]+$/, fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/, halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/, multibyte = /[^\x00-\x7F]/, surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/, int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/, intLeadingZeroes = /^[-+]?[0-9]+$/, float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/, decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/, hexadecimal = /^[0-9A-F]+$/i, hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i, md5 = /^[a-f0-9]{32}$/, uuid = {
        3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    }, iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/, creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})|62[0-9]{14}$/, isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/, isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/, isbn13Maybe = /^(?:[0-9]{13})$/, factor = [ 1, 3 ], issn = "^\\d{4}-?\\d{3}[\\dX]$", phones = {
        "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
        "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
        "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
        "en-US": /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
        "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "de-DE": /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
        "da-DK": /^(\+?45)?(\d{8})$/,
        "el-GR": /^(\+?30)?(69\d{8})$/,
        "en-AU": /^(\+?61|0)4\d{8}$/,
        "en-GB": /^(\+?44|0)7\d{9}$/,
        "en-HK": /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
        "en-IN": /^(\+?91|0)?[789]\d{9}$/,
        "en-NZ": /^(\+?64|0)2\d{7,9}$/,
        "en-ZA": /^(\+?27|0)\d{9}$/,
        "en-ZM": /^(\+?26)?09[567]\d{7}$/,
        "es-ES": /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
        "fi-FI": /^(\+?358|0)\s?(4(0|1|2|4|5)?|50)\s?(\d\s?){4,8}\d$/,
        "fr-FR": /^(\+?33|0)[67]\d{8}$/,
        "he-IL": /^(\+972|0)([23489]|5[0248]|77)[1-9]\d{6}/,
        "hu-HU": /^(\+?36)(20|30|70)\d{7}$/,
        "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
        "ja-JP": /^(\+?81|0)\d{1,4}[ \-]?\d{1,4}[ \-]?\d{4}$/,
        "ms-MY": /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
        "nb-NO": /^(\+?47)?[49]\d{7}$/,
        "nl-BE": /^(\+?32|0)4?\d{8}$/,
        "nn-NO": /^(\+?47)?[49]\d{7}$/,
        "pl-PL": /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
        "pt-BR": /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
        "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
        "ru-RU": /^(\+?7|8)?9\d{9}$/,
        "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
        "tr-TR": /^(\+?90|0)?5\d{9}$/,
        "vi-VN": /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
        "zh-CN": /^(\+?0?86\-?)?1[345789]\d{9}$/,
        "zh-TW": /^(\+?886\-?|0)?9\d{8}$/
    };
    phones["en-CA"] = phones["en-US"], phones["fr-BE"] = phones["nl-BE"];
    var default_currency_options = {
        symbol: "$",
        require_symbol: !1,
        allow_space_after_symbol: !1,
        symbol_after_digits: !1,
        allow_negatives: !0,
        parens_for_negatives: !1,
        negative_sign_before_digits: !1,
        negative_sign_after_digits: !1,
        allow_negative_sign_placeholder: !1,
        thousands_separator: ",",
        decimal_separator: ".",
        allow_space_after_digits: !1
    }, notBase64 = /[^A-Z0-9+\/=]/i, dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i, default_normalize_email_options = {
        all_lowercase: !0,
        gmail_lowercase: !0,
        gmail_remove_dots: !0,
        gmail_remove_subaddress: !0,
        gmail_convert_googlemaildotcom: !0,
        outlookdotcom_lowercase: !0,
        outlookdotcom_remove_subaddress: !0,
        yahoo_lowercase: !0,
        yahoo_remove_subaddress: !0,
        icloud_lowercase: !0,
        icloud_remove_subaddress: !0
    }, icloud_domains = [ "icloud.com", "me.com" ], outlookdotcom_domains = [ "hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com" ], yahoo_domains = [ "rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com" ], version = "6.2.1", validator = {
        version: version,
        toDate: toDate,
        toFloat: toFloat,
        toInt: toInt,
        toBoolean: toBoolean,
        equals: equals,
        contains: contains,
        matches: matches,
        isEmail: isEmail,
        isURL: isURL,
        isMACAddress: isMACAddress,
        isIP: isIP,
        isFQDN: isFDQN,
        isBoolean: isBoolean,
        isAlpha: isAlpha,
        isAlphanumeric: isAlphanumeric,
        isNumeric: isNumeric,
        isLowercase: isLowercase,
        isUppercase: isUppercase,
        isAscii: isAscii,
        isFullWidth: isFullWidth,
        isHalfWidth: isHalfWidth,
        isVariableWidth: isVariableWidth,
        isMultibyte: isMultibyte,
        isSurrogatePair: isSurrogatePair,
        isInt: isInt,
        isFloat: isFloat,
        isDecimal: isDecimal,
        isHexadecimal: isHexadecimal,
        isDivisibleBy: isDivisibleBy,
        isHexColor: isHexColor,
        isMD5: isMD5,
        isJSON: isJSON,
        isEmpty: isEmpty,
        isLength: isLength,
        isByteLength: isByteLength,
        isUUID: isUUID,
        isMongoId: isMongoId,
        isDate: isDate,
        isAfter: isAfter,
        isBefore: isBefore,
        isIn: isIn,
        isCreditCard: isCreditCard,
        isISIN: isISIN,
        isISBN: isISBN,
        isISSN: isISSN,
        isMobilePhone: isMobilePhone,
        isCurrency: isCurrency,
        isISO8601: isISO8601,
        isBase64: isBase64,
        isDataURI: isDataURI,
        ltrim: ltrim,
        rtrim: rtrim,
        trim: trim,
        escape: escape,
        unescape: unescape,
        stripLow: stripLow,
        whitelist: whitelist,
        blacklist: blacklist,
        isWhitelisted: isWhitelisted,
        normalizeEmail: normalizeEmail,
        toString: toString
    };
    return validator;
}), angular.module("fluro.validate", []), angular.module("fluro.validate").service("FluroValidate", function() {
    var controller = {};
    return controller.validate = function(entry, field) {
        if (field.minimum > 0 && !entry) return !1;
        if (_.isArray(entry)) {
            var array = entry;
            if (1 == field.minimum && 1 == field.maximum && "array" != field.type) return !1;
            if (array.length < field.minimum) return !1;
            if (field.maximum && array.length > field.maximum) return !1;
            var invalidEntries = _.filter(array, function(obj) {
                var allowed = !0;
                field.allowedValues && field.allowedValues.length && (allowed = _.contains(field.allowedValues, obj));
                var correctType = controller.validateType(obj, field.type);
                return allowed && correctType ? !1 : !0;
            });
            if (invalidEntries.length) return !1;
        } else {
            if (field.minimum > 1) return !1;
            if (field.minimum > 0) {
                var correctType = controller.validateType(entry, field.type);
                if (!correctType) return !1;
            }
            if (entry && field.allowedValues && field.allowedValues.length) {
                var allowed = _.contains(field.allowedValues, entry);
                if (!allowed) return !1;
            }
        }
        return !0;
    }, controller.validateType = function(field, fieldType) {
        switch (fieldType.toLowerCase()) {
          case "reference":
            return _.isString(field) ? validator.isMongoId(field) : validator.isMongoId(field._id);

          case "email":
            return validator.isEmail(field);

          case "url":
            return validator.isURL(field);

          case "array":
            return _.isArray(field);

          case "decimal":
          case "float":
          case "number":
            var numberised = Number(field), isActual = _.isFinite(numberised) && !_.isNaN(numberised);
            return isActual;

          case "integer":
            return validator.isInt(field);

          case "string":
            return _.isString(field);

          case "object":
            return _.isObject(field);

          case "date":
            return _.isDate(field);

          case "boolean":
            return _.isBoolean(field);

          case "void":
            return !0;
        }
    }, controller;
}), angular.module("fluro.interactions", [ "fluro.util", "fluro.content", "fluro.validate" ]), 
angular.module("fluro.interactions").service("FluroInteraction", [ "Fluro", "FluroContent", function(Fluro, FluroContent) {
    var controller = {};
    return controller.interact = function(title, key, interactionData, payment, event) {
        var submission = {};
        return submission.title = title, submission.key = key, event && event.length && (submission.event = event), 
        payment && (submission.payment = payment), interactionData._contact ? submission.contact = interactionData._contact : submission.contact = {}, 
        interactionData._contacts ? submission.contacts = interactionData._contacts : submission.contacts = [], 
        interactionData._firstName && (submission.contact.firstName = interactionData._firstName), 
        interactionData._lastName && (submission.contact.lastName = interactionData._lastName), 
        interactionData._email && (submission.contact.emails = [ interactionData._email ]), 
        interactionData._emails && (submission.contact.emails = interactionData._emails), 
        interactionData._phoneNumber && (submission.contact.phoneNumbers = [ interactionData._phoneNumber ]), 
        interactionData._phoneNumbers && (submission.contact.phoneNumbers = interactionData._phoneNumbers), 
        interactionData._dob && (submission.contact.dob = interactionData._dob), interactionData._gender && (submission.contact.gender = interactionData._gender), 
        submission.interaction = interactionData, FluroContent.endpoint("interact/" + key).save(submission).$promise;
    }, controller;
} ]), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports) : "function" == typeof define && define.amd ? define([ "exports" ], factory) : factory(global.async = global.async || {});
}(this, function(exports) {
    "use strict";
    function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    function overRest$1(func, start, transform) {
        return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
            index = -1;
            for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
            return otherArgs[start] = transform(array), apply(func, this, otherArgs);
        };
    }
    function identity(value) {
        return value;
    }
    function rest(func, start) {
        return overRest$1(func, start, identity);
    }
    function applyEach$1(eachfn) {
        return rest(function(fns, args) {
            var go = initialParams(function(args, callback) {
                var that = this;
                return eachfn(fns, function(fn, cb) {
                    fn.apply(that, args.concat([ cb ]));
                }, callback);
            });
            return args.length ? go.apply(this, args) : go;
        });
    }
    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
            value[symToStringTag$1] = void 0;
            var unmasked = !0;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag$1] = tag : delete value[symToStringTag$1]), 
        result;
    }
    function objectToString(value) {
        return nativeObjectToString$1.call(value);
    }
    function baseGetTag(value) {
        return null == value ? void 0 === value ? undefinedTag : nullTag : (value = Object(value), 
        symToStringTag && symToStringTag in value ? getRawTag(value) : objectToString(value));
    }
    function isObject(value) {
        var type = typeof value;
        return null != value && ("object" == type || "function" == type);
    }
    function isFunction(value) {
        if (!isObject(value)) return !1;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
        return "number" == typeof value && value > -1 && value % 1 == 0 && MAX_SAFE_INTEGER >= value;
    }
    function isArrayLike(value) {
        return null != value && isLength(value.length) && !isFunction(value);
    }
    function noop() {}
    function once(fn) {
        return function() {
            if (null !== fn) {
                var callFn = fn;
                fn = null, callFn.apply(this, arguments);
            }
        };
    }
    function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
        return result;
    }
    function isObjectLike(value) {
        return null != value && "object" == typeof value;
    }
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function stubFalse() {
        return !1;
    }
    function isIndex(value, length) {
        return length = null == length ? MAX_SAFE_INTEGER$1 : length, !!length && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && length > value;
    }
    function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
        return function(value) {
            return func(value);
        };
    }
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) !inherited && !hasOwnProperty$1.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
        return result;
    }
    function isPrototype(value) {
        var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto$5;
        return value === proto;
    }
    function overArg(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }
    function baseKeys(object) {
        if (!isPrototype(object)) return nativeKeys(object);
        var result = [];
        for (var key in Object(object)) hasOwnProperty$3.call(object, key) && "constructor" != key && result.push(key);
        return result;
    }
    function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function createArrayIterator(coll) {
        var i = -1, len = coll.length;
        return function() {
            return ++i < len ? {
                value: coll[i],
                key: i
            } : null;
        };
    }
    function createES2015Iterator(iterator) {
        var i = -1;
        return function() {
            var item = iterator.next();
            return item.done ? null : (i++, {
                value: item.value,
                key: i
            });
        };
    }
    function createObjectIterator(obj) {
        var okeys = keys(obj), i = -1, len = okeys.length;
        return function() {
            var key = okeys[++i];
            return len > i ? {
                value: obj[key],
                key: key
            } : null;
        };
    }
    function iterator(coll) {
        if (isArrayLike(coll)) return createArrayIterator(coll);
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
        return function() {
            if (null === fn) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null, callFn.apply(this, arguments);
        };
    }
    function _eachOfLimit(limit) {
        return function(obj, iteratee, callback) {
            function iterateeCallback(err, value) {
                if (running -= 1, err) done = !0, callback(err); else {
                    if (value === breakLoop || done && 0 >= running) return done = !0, callback(null);
                    replenish();
                }
            }
            function replenish() {
                for (;limit > running && !done; ) {
                    var elem = nextElem();
                    if (null === elem) return done = !0, void (0 >= running && callback(null));
                    running += 1, iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
            }
            if (callback = once(callback || noop), 0 >= limit || !obj) return callback(null);
            var nextElem = iterator(obj), done = !1, running = 0;
            replenish();
        };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, iteratee, callback);
    }
    function doLimit(fn, limit) {
        return function(iterable, iteratee, callback) {
            return fn(iterable, limit, iteratee, callback);
        };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
        function iteratorCallback(err) {
            err ? callback(err) : ++completed === length && callback(null);
        }
        callback = once(callback || noop);
        var index = 0, completed = 0, length = coll.length;
        for (0 === length && callback(null); length > index; index++) iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
    function doParallel(fn) {
        return function(obj, iteratee, callback) {
            return fn(eachOf, obj, iteratee, callback);
        };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
        callback = callback || noop, arr = arr || [];
        var results = [], counter = 0;
        eachfn(arr, function(value, _, callback) {
            var index = counter++;
            iteratee(value, function(err, v) {
                results[index] = v, callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
    function doParallelLimit(fn) {
        return function(obj, limit, iteratee, callback) {
            return fn(_eachOfLimit(limit), obj, iteratee, callback);
        };
    }
    function asyncify(func) {
        return initialParams(function(args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            isObject(result) && "function" == typeof result.then ? result.then(function(value) {
                callback(null, value);
            }, function(err) {
                callback(err.message ? err : new Error(err));
            }) : callback(null, result);
        });
    }
    function arrayEach(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1; ) ;
        return array;
    }
    function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
            for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === !1) break;
            }
            return object;
        };
    }
    function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
        return -1;
    }
    function baseIsNaN(value) {
        return value !== value;
    }
    function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function arrayMap(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
        return result;
    }
    function isSymbol(value) {
        return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function baseToString(value) {
        if ("string" == typeof value) return value;
        if (isArray(value)) return arrayMap(value, baseToString) + "";
        if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
        var result = value + "";
        return "0" == result && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        0 > start && (start = -start > length ? 0 : length + start), end = end > length ? length : end, 
        0 > end && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
        for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
        return result;
    }
    function castSlice(array, start, end) {
        var length = array.length;
        return end = void 0 === end ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function asciiToArray(string) {
        return string.split("");
    }
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function toString(value) {
        return null == value ? "" : baseToString(value);
    }
    function trim(string, chars, guard) {
        if (string = toString(string), string && (guard || void 0 === chars)) return string.replace(reTrim, "");
        if (!string || !(chars = baseToString(chars))) return string;
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
    }
    function parseParams(func) {
        return func = func.toString().replace(STRIP_COMMENTS, ""), func = func.match(FN_ARGS)[2].replace(" ", ""), 
        func = func ? func.split(FN_ARG_SPLIT) : [], func = func.map(function(arg) {
            return trim(arg.replace(FN_ARG, ""));
        });
    }
    function autoInject(tasks, callback) {
        var newTasks = {};
        baseForOwn(tasks, function(taskFn, key) {
            function newTask(results, taskCb) {
                var newArgs = arrayMap(params, function(name) {
                    return results[name];
                });
                newArgs.push(taskCb), taskFn.apply(null, newArgs);
            }
            var params;
            if (isArray(taskFn)) params = taskFn.slice(0, -1), taskFn = taskFn[taskFn.length - 1], 
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn); else if (1 === taskFn.length) newTasks[key] = taskFn; else {
                if (params = parseParams(taskFn), 0 === taskFn.length && 0 === params.length) throw new Error("autoInject task functions require explicit parameters.");
                params.pop(), newTasks[key] = params.concat(newTask);
            }
        }), auto(newTasks, callback);
    }
    function fallback(fn) {
        setTimeout(fn, 0);
    }
    function wrap(defer) {
        return rest(function(fn, args) {
            defer(function() {
                fn.apply(null, args);
            });
        });
    }
    function DLL() {
        this.head = this.tail = null, this.length = 0;
    }
    function setInitial(dll, node) {
        dll.length = 1, dll.head = dll.tail = node;
    }
    function queue(worker, concurrency, payload) {
        function _insert(data, insertAtFront, callback) {
            if (null != callback && "function" != typeof callback) throw new Error("task callback must be a function");
            if (q.started = !0, isArray(data) || (data = [ data ]), 0 === data.length && q.idle()) return setImmediate$1(function() {
                q.drain();
            });
            for (var i = 0, l = data.length; l > i; i++) {
                var item = {
                    data: data[i],
                    callback: callback || noop
                };
                insertAtFront ? q._tasks.unshift(item) : q._tasks.push(item);
            }
            setImmediate$1(q.process);
        }
        function _next(tasks) {
            return rest(function(args) {
                workers -= 1;
                for (var i = 0, l = tasks.length; l > i; i++) {
                    var task = tasks[i], index = baseIndexOf(workersList, task, 0);
                    index >= 0 && workersList.splice(index), task.callback.apply(task, args), null != args[0] && q.error(args[0], task.data);
                }
                workers <= q.concurrency - q.buffer && q.unsaturated(), q.idle() && q.drain(), q.process();
            });
        }
        if (null == concurrency) concurrency = 1; else if (0 === concurrency) throw new Error("Concurrency must not be zero");
        var workers = 0, workersList = [], q = {
            _tasks: new DLL(),
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            unsaturated: noop,
            buffer: concurrency / 4,
            empty: noop,
            drain: noop,
            error: noop,
            started: !1,
            paused: !1,
            push: function(data, callback) {
                _insert(data, !1, callback);
            },
            kill: function() {
                q.drain = noop, q._tasks.empty();
            },
            unshift: function(data, callback) {
                _insert(data, !0, callback);
            },
            process: function() {
                for (;!q.paused && workers < q.concurrency && q._tasks.length; ) {
                    var tasks = [], data = [], l = q._tasks.length;
                    q.payload && (l = Math.min(l, q.payload));
                    for (var i = 0; l > i; i++) {
                        var node = q._tasks.shift();
                        tasks.push(node), data.push(node.data);
                    }
                    0 === q._tasks.length && q.empty(), workers += 1, workersList.push(tasks[0]), workers === q.concurrency && q.saturated();
                    var cb = onlyOnce(_next(tasks));
                    worker(data, cb);
                }
            },
            length: function() {
                return q._tasks.length;
            },
            running: function() {
                return workers;
            },
            workersList: function() {
                return workersList;
            },
            idle: function() {
                return q._tasks.length + workers === 0;
            },
            pause: function() {
                q.paused = !0;
            },
            resume: function() {
                if (q.paused !== !1) {
                    q.paused = !1;
                    for (var resumeCount = Math.min(q.concurrency, q._tasks.length), w = 1; resumeCount >= w; w++) setImmediate$1(q.process);
                }
            }
        };
        return q;
    }
    function cargo(worker, payload) {
        return queue(worker, 1, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
        callback = once(callback || noop), eachOfSeries(coll, function(x, i, callback) {
            iteratee(memo, x, function(err, v) {
                memo = v, callback(err);
            });
        }, function(err) {
            callback(err, memo);
        });
    }
    function concat$1(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function(x, index, cb) {
            fn(x, function(err, y) {
                result = result.concat(y || []), cb(err);
            });
        }, function(err) {
            callback(err, result);
        });
    }
    function doSeries(fn) {
        return function(obj, iteratee, callback) {
            return fn(eachOfSeries, obj, iteratee, callback);
        };
    }
    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iteratee, cb) {
            function done() {
                cb && cb(null, getResult(!1));
            }
            function wrappedIteratee(x, _, callback) {
                return cb ? void iteratee(x, function(err, v) {
                    cb && (err || check(v)) ? (err ? cb(err) : cb(err, getResult(!0, x)), cb = iteratee = !1, 
                    callback(err, breakLoop)) : callback();
                }) : callback();
            }
            arguments.length > 3 ? (cb = cb || noop, eachfn(arr, limit, wrappedIteratee, done)) : (cb = iteratee, 
            cb = cb || noop, iteratee = limit, eachfn(arr, wrappedIteratee, done));
        };
    }
    function _findGetResult(v, x) {
        return x;
    }
    function consoleFunc(name) {
        return rest(function(fn, args) {
            fn.apply(null, args.concat([ rest(function(err, args) {
                "object" == typeof console && (err ? console.error && console.error(err) : console[name] && arrayEach(args, function(x) {
                    console[name](x);
                }));
            }) ]));
        });
    }
    function doDuring(fn, test, callback) {
        function check(err, truth) {
            return err ? callback(err) : truth ? void fn(next) : callback(null);
        }
        callback = onlyOnce(callback || noop);
        var next = rest(function(err, args) {
            return err ? callback(err) : (args.push(check), void test.apply(this, args));
        });
        check(null, !0);
    }
    function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback || noop);
        var next = rest(function(err, args) {
            return err ? callback(err) : test.apply(this, args) ? iteratee(next) : void callback.apply(null, [ null ].concat(args));
        });
        iteratee(next);
    }
    function doUntil(fn, test, callback) {
        doWhilst(fn, function() {
            return !test.apply(this, arguments);
        }, callback);
    }
    function during(test, fn, callback) {
        function next(err) {
            return err ? callback(err) : void test(check);
        }
        function check(err, truth) {
            return err ? callback(err) : truth ? void fn(next) : callback(null);
        }
        callback = onlyOnce(callback || noop), test(check);
    }
    function _withoutIndex(iteratee) {
        return function(value, index, callback) {
            return iteratee(value, callback);
        };
    }
    function eachLimit(coll, iteratee, callback) {
        eachOf(coll, _withoutIndex(iteratee), callback);
    }
    function eachLimit$1(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, _withoutIndex(iteratee), callback);
    }
    function ensureAsync(fn) {
        return initialParams(function(args, callback) {
            var sync = !0;
            args.push(function() {
                var innerArgs = arguments;
                sync ? setImmediate$1(function() {
                    callback.apply(null, innerArgs);
                }) : callback.apply(null, innerArgs);
            }), fn.apply(this, args), sync = !1;
        });
    }
    function notId(v) {
        return !v;
    }
    function baseProperty(key) {
        return function(object) {
            return null == object ? void 0 : object[key];
        };
    }
    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, function(x, index, callback) {
            iteratee(x, function(err, v) {
                truthValues[index] = !!v, callback(err);
            });
        }, function(err) {
            if (err) return callback(err);
            for (var results = [], i = 0; i < arr.length; i++) truthValues[i] && results.push(arr[i]);
            callback(null, results);
        });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, function(x, index, callback) {
            iteratee(x, function(err, v) {
                err ? callback(err) : (v && results.push({
                    index: index,
                    value: x
                }), callback());
            });
        }, function(err) {
            err ? callback(err) : callback(null, arrayMap(results.sort(function(a, b) {
                return a.index - b.index;
            }), baseProperty("value")));
        });
    }
    function _filter(eachfn, coll, iteratee, callback) {
        var filter = isArrayLike(coll) ? filterArray : filterGeneric;
        filter(eachfn, coll, iteratee, callback || noop);
    }
    function forever(fn, errback) {
        function next(err) {
            return err ? done(err) : void task(next);
        }
        var done = onlyOnce(errback || noop), task = ensureAsync(fn);
        next();
    }
    function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback || noop);
        var newObj = {};
        eachOfLimit(obj, limit, function(val, key, next) {
            iteratee(val, key, function(err, result) {
                return err ? next(err) : (newObj[key] = result, void next());
            });
        }, function(err) {
            callback(err, newObj);
        });
    }
    function has(obj, key) {
        return key in obj;
    }
    function memoize(fn, hasher) {
        var memo = Object.create(null), queues = Object.create(null);
        hasher = hasher || identity;
        var memoized = initialParams(function(args, callback) {
            var key = hasher.apply(null, args);
            has(memo, key) ? setImmediate$1(function() {
                callback.apply(null, memo[key]);
            }) : has(queues, key) ? queues[key].push(callback) : (queues[key] = [ callback ], 
            fn.apply(null, args.concat([ rest(function(args) {
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; l > i; i++) q[i].apply(null, args);
            }) ])));
        });
        return memoized.memo = memo, memoized.unmemoized = fn, memoized;
    }
    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, function(task, key, callback) {
            task(rest(function(err, args) {
                args.length <= 1 && (args = args[0]), results[key] = args, callback(err);
            }));
        }, function(err) {
            callback(err, results);
        });
    }
    function parallelLimit(tasks, callback) {
        _parallel(eachOf, tasks, callback);
    }
    function parallelLimit$1(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    }
    function race(tasks, callback) {
        if (callback = once(callback || noop), !isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; l > i; i++) tasks[i](callback);
    }
    function reduceRight(array, memo, iteratee, callback) {
        var reversed = slice.call(array).reverse();
        reduce(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
        return initialParams(function(args, reflectCallback) {
            return args.push(rest(function(err, cbArgs) {
                if (err) reflectCallback(null, {
                    error: err
                }); else {
                    var value = null;
                    1 === cbArgs.length ? value = cbArgs[0] : cbArgs.length > 1 && (value = cbArgs), 
                    reflectCallback(null, {
                        value: value
                    });
                }
            })), fn.apply(this, args);
        });
    }
    function reject$1(eachfn, arr, iteratee, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iteratee(value, function(err, v) {
                cb(err, !v);
            });
        }, callback);
    }
    function reflectAll(tasks) {
        var results;
        return isArray(tasks) ? results = arrayMap(tasks, reflect) : (results = {}, baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        })), results;
    }
    function constant$1(value) {
        return function() {
            return value;
        };
    }
    function retry(opts, task, callback) {
        function parseTimes(acc, t) {
            if ("object" == typeof t) acc.times = +t.times || DEFAULT_TIMES, acc.intervalFunc = "function" == typeof t.interval ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL), 
            acc.errorFilter = t.errorFilter; else {
                if ("number" != typeof t && "string" != typeof t) throw new Error("Invalid arguments for async.retry");
                acc.times = +t || DEFAULT_TIMES;
            }
        }
        function retryAttempt() {
            task(function(err) {
                err && attempt++ < options.times && ("function" != typeof options.errorFilter || options.errorFilter(err)) ? setTimeout(retryAttempt, options.intervalFunc(attempt)) : callback.apply(null, arguments);
            });
        }
        var DEFAULT_TIMES = 5, DEFAULT_INTERVAL = 0, options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && "function" == typeof opts ? (callback = task || noop, 
        task = opts) : (parseTimes(options, opts), callback = callback || noop), "function" != typeof task) throw new Error("Invalid arguments for async.retry");
        var attempt = 1;
        retryAttempt();
    }
    function series(tasks, callback) {
        _parallel(eachOfSeries, tasks, callback);
    }
    function sortBy(coll, iteratee, callback) {
        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return b > a ? -1 : a > b ? 1 : 0;
        }
        map(coll, function(x, callback) {
            iteratee(x, function(err, criteria) {
                return err ? callback(err) : void callback(null, {
                    value: x,
                    criteria: criteria
                });
            });
        }, function(err, results) {
            return err ? callback(err) : void callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
        });
    }
    function timeout(asyncFn, milliseconds, info) {
        function injectedCallback() {
            timedOut || (originalCallback.apply(null, arguments), clearTimeout(timer));
        }
        function timeoutCallback() {
            var name = asyncFn.name || "anonymous", error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT", info && (error.info = info), timedOut = !0, originalCallback(error);
        }
        var originalCallback, timer, timedOut = !1;
        return initialParams(function(args, origCallback) {
            originalCallback = origCallback, timer = setTimeout(timeoutCallback, milliseconds), 
            asyncFn.apply(null, args.concat(injectedCallback));
        });
    }
    function baseRange(start, end, step, fromRight) {
        for (var index = -1, length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; ) result[fromRight ? length : ++index] = start, 
        start += step;
        return result;
    }
    function timeLimit(count, limit, iteratee, callback) {
        mapLimit(baseRange(0, count, 1), limit, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
        3 === arguments.length && (callback = iteratee, iteratee = accumulator, accumulator = isArray(coll) ? [] : {}), 
        callback = once(callback || noop), eachOf(coll, function(v, k, cb) {
            iteratee(accumulator, v, k, cb);
        }, function(err) {
            callback(err, accumulator);
        });
    }
    function unmemoize(fn) {
        return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    }
    function whilst(test, iteratee, callback) {
        if (callback = onlyOnce(callback || noop), !test()) return callback(null);
        var next = rest(function(err, args) {
            return err ? callback(err) : test() ? iteratee(next) : void callback.apply(null, [ null ].concat(args));
        });
        iteratee(next);
    }
    function until(test, fn, callback) {
        whilst(function() {
            return !test.apply(this, arguments);
        }, fn, callback);
    }
    var nativeMax = Math.max, initialParams = function(fn) {
        return rest(function(args) {
            var callback = args.pop();
            fn.call(this, args, callback);
        });
    }, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0, objectProto$1 = Object.prototype, nativeObjectToString$1 = objectProto$1.toString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0, asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]", MAX_SAFE_INTEGER = 9007199254740991, iteratorSymbol = "function" == typeof Symbol && Symbol.iterator, getIterator = function(coll) {
        return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    }, argsTag = "[object Arguments]", objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty, propertyIsEnumerable = objectProto$3.propertyIsEnumerable, isArguments = baseIsArguments(function() {
        return arguments;
    }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    }, isArray = Array.isArray, freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer = moduleExports ? root.Buffer : void 0, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse, MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag$1 = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var _defer, freeExports$1 = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && "object" == typeof module && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
        try {
            return freeProcess && freeProcess.binding("util");
        } catch (e) {}
    }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$2 = Object.prototype, hasOwnProperty$1 = objectProto$2.hasOwnProperty, objectProto$5 = Object.prototype, nativeKeys = overArg(Object.keys, Object), objectProto$4 = Object.prototype, hasOwnProperty$3 = objectProto$4.hasOwnProperty, breakLoop = {}, eachOfGeneric = doLimit(eachOfLimit, 1 / 0), eachOf = function(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        eachOfImplementation(coll, iteratee, callback);
    }, map = doParallel(_asyncMap), applyEach = applyEach$1(map), mapLimit = doParallelLimit(_asyncMap), mapSeries = doLimit(mapLimit, 1), applyEachSeries = applyEach$1(mapSeries), apply$2 = rest(function(fn, args) {
        return rest(function(callArgs) {
            return fn.apply(null, args.concat(callArgs));
        });
    }), baseFor = createBaseFor(), auto = function(tasks, concurrency, callback) {
        function enqueueTask(key, task) {
            readyTasks.push(function() {
                runTask(key, task);
            });
        }
        function processQueue() {
            if (0 === readyTasks.length && 0 === runningTasks) return callback(null, results);
            for (;readyTasks.length && concurrency > runningTasks; ) {
                var run = readyTasks.shift();
                run();
            }
        }
        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            taskListeners || (taskListeners = listeners[taskName] = []), taskListeners.push(fn);
        }
        function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            arrayEach(taskListeners, function(fn) {
                fn();
            }), processQueue();
        }
        function runTask(key, task) {
            if (!hasError) {
                var taskCallback = onlyOnce(rest(function(err, args) {
                    if (runningTasks--, args.length <= 1 && (args = args[0]), err) {
                        var safeResults = {};
                        baseForOwn(results, function(val, rkey) {
                            safeResults[rkey] = val;
                        }), safeResults[key] = args, hasError = !0, listeners = [], callback(err, safeResults);
                    } else results[key] = args, taskComplete(key);
                }));
                runningTasks++;
                var taskFn = task[task.length - 1];
                task.length > 1 ? taskFn(results, taskCallback) : taskFn(taskCallback);
            }
        }
        function checkForDeadlocks() {
            for (var currentTask, counter = 0; readyToCheck.length; ) currentTask = readyToCheck.pop(), 
            counter++, arrayEach(getDependents(currentTask), function(dependent) {
                0 === --uncheckedDependencies[dependent] && readyToCheck.push(dependent);
            });
            if (counter !== numTasks) throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
        function getDependents(taskName) {
            var result = [];
            return baseForOwn(tasks, function(task, key) {
                isArray(task) && baseIndexOf(task, taskName, 0) >= 0 && result.push(key);
            }), result;
        }
        "function" == typeof concurrency && (callback = concurrency, concurrency = null), 
        callback = once(callback || noop);
        var keys$$1 = keys(tasks), numTasks = keys$$1.length;
        if (!numTasks) return callback(null);
        concurrency || (concurrency = numTasks);
        var results = {}, runningTasks = 0, hasError = !1, listeners = {}, readyTasks = [], readyToCheck = [], uncheckedDependencies = {};
        baseForOwn(tasks, function(task, key) {
            if (!isArray(task)) return enqueueTask(key, [ task ]), void readyToCheck.push(key);
            var dependencies = task.slice(0, task.length - 1), remainingDependencies = dependencies.length;
            return 0 === remainingDependencies ? (enqueueTask(key, task), void readyToCheck.push(key)) : (uncheckedDependencies[key] = remainingDependencies, 
            void arrayEach(dependencies, function(dependencyName) {
                if (!tasks[dependencyName]) throw new Error("async.auto task `" + key + "` has a non-existent dependency in " + dependencies.join(", "));
                addListener(dependencyName, function() {
                    remainingDependencies--, 0 === remainingDependencies && enqueueTask(key, task);
                });
            }));
        }), checkForDeadlocks(), processQueue();
    }, symbolTag = "[object Symbol]", INFINITY = 1 / 0, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsVarRange = "\\ufe0e\\ufe0f", rsZWJ = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"), rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange$1 = "\\u20d0-\\u20f0", rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo = "[" + rsComboMarksRange$1 + rsComboSymbolsRange$1 + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange$1 + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange$1 + "]?", rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")", reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reTrim = /^\s+|\s+$/g, FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, hasSetImmediate = "function" == typeof setImmediate && setImmediate, hasNextTick = "object" == typeof process && "function" == typeof process.nextTick;
    _defer = hasSetImmediate ? setImmediate : hasNextTick ? process.nextTick : fallback;
    var setImmediate$1 = wrap(_defer);
    DLL.prototype.removeLink = function(node) {
        return node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev, 
        node.prev = node.next = null, this.length -= 1, node;
    }, DLL.prototype.empty = DLL, DLL.prototype.insertAfter = function(node, newNode) {
        newNode.prev = node, newNode.next = node.next, node.next ? node.next.prev = newNode : this.tail = newNode, 
        node.next = newNode, this.length += 1;
    }, DLL.prototype.insertBefore = function(node, newNode) {
        newNode.prev = node.prev, newNode.next = node, node.prev ? node.prev.next = newNode : this.head = newNode, 
        node.prev = newNode, this.length += 1;
    }, DLL.prototype.unshift = function(node) {
        this.head ? this.insertBefore(this.head, node) : setInitial(this, node);
    }, DLL.prototype.push = function(node) {
        this.tail ? this.insertAfter(this.tail, node) : setInitial(this, node);
    }, DLL.prototype.shift = function() {
        return this.head && this.removeLink(this.head);
    }, DLL.prototype.pop = function() {
        return this.tail && this.removeLink(this.tail);
    };
    var _defer$1, eachOfSeries = doLimit(eachOfLimit, 1), seq$1 = rest(function(functions) {
        return rest(function(args) {
            var that = this, cb = args[args.length - 1];
            "function" == typeof cb ? args.pop() : cb = noop, reduce(functions, args, function(newargs, fn, cb) {
                fn.apply(that, newargs.concat([ rest(function(err, nextargs) {
                    cb(err, nextargs);
                }) ]));
            }, function(err, results) {
                cb.apply(that, [ err ].concat(results));
            });
        });
    }), compose = rest(function(args) {
        return seq$1.apply(null, args.reverse());
    }), concat = doParallel(concat$1), concatSeries = doSeries(concat$1), constant = rest(function(values) {
        var args = [ null ].concat(values);
        return initialParams(function(ignoredArgs, callback) {
            return callback.apply(this, args);
        });
    }), detect = _createTester(eachOf, identity, _findGetResult), detectLimit = _createTester(eachOfLimit, identity, _findGetResult), detectSeries = _createTester(eachOfSeries, identity, _findGetResult), dir = consoleFunc("dir"), eachSeries = doLimit(eachLimit$1, 1), every = _createTester(eachOf, notId, notId), everyLimit = _createTester(eachOfLimit, notId, notId), everySeries = doLimit(everyLimit, 1), filter = doParallel(_filter), filterLimit = doParallelLimit(_filter), filterSeries = doLimit(filterLimit, 1), log = consoleFunc("log"), mapValues = doLimit(mapValuesLimit, 1 / 0), mapValuesSeries = doLimit(mapValuesLimit, 1);
    _defer$1 = hasNextTick ? process.nextTick : hasSetImmediate ? setImmediate : fallback;
    var nextTick = wrap(_defer$1), queue$1 = function(worker, concurrency) {
        return queue(function(items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);
    }, priorityQueue = function(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        return q.push = function(data, priority, callback) {
            if (null == callback && (callback = noop), "function" != typeof callback) throw new Error("task callback must be a function");
            if (q.started = !0, isArray(data) || (data = [ data ]), 0 === data.length) return setImmediate$1(function() {
                q.drain();
            });
            priority = priority || 0;
            for (var nextNode = q._tasks.head; nextNode && priority >= nextNode.priority; ) nextNode = nextNode.next;
            for (var i = 0, l = data.length; l > i; i++) {
                var item = {
                    data: data[i],
                    priority: priority,
                    callback: callback
                };
                nextNode ? q._tasks.insertBefore(nextNode, item) : q._tasks.push(item);
            }
            setImmediate$1(q.process);
        }, delete q.unshift, q;
    }, slice = Array.prototype.slice, reject = doParallel(reject$1), rejectLimit = doParallelLimit(reject$1), rejectSeries = doLimit(rejectLimit, 1), retryable = function(opts, task) {
        return task || (task = opts, opts = null), initialParams(function(args, callback) {
            function taskFn(cb) {
                task.apply(null, args.concat([ cb ]));
            }
            opts ? retry(opts, taskFn, callback) : retry(taskFn, callback);
        });
    }, some = _createTester(eachOf, Boolean, identity), someLimit = _createTester(eachOfLimit, Boolean, identity), someSeries = doLimit(someLimit, 1), nativeCeil = Math.ceil, nativeMax$1 = Math.max, times = doLimit(timeLimit, 1 / 0), timesSeries = doLimit(timeLimit, 1), waterfall = function(tasks, callback) {
        function nextTask(args) {
            if (taskIndex === tasks.length) return callback.apply(null, [ null ].concat(args));
            var taskCallback = onlyOnce(rest(function(err, args) {
                return err ? callback.apply(null, [ err ].concat(args)) : void nextTask(args);
            }));
            args.push(taskCallback);
            var task = tasks[taskIndex++];
            task.apply(null, args);
        }
        if (callback = once(callback || noop), !isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        nextTask([]);
    }, index = {
        applyEach: applyEach,
        applyEachSeries: applyEachSeries,
        apply: apply$2,
        asyncify: asyncify,
        auto: auto,
        autoInject: autoInject,
        cargo: cargo,
        compose: compose,
        concat: concat,
        concatSeries: concatSeries,
        constant: constant,
        detect: detect,
        detectLimit: detectLimit,
        detectSeries: detectSeries,
        dir: dir,
        doDuring: doDuring,
        doUntil: doUntil,
        doWhilst: doWhilst,
        during: during,
        each: eachLimit,
        eachLimit: eachLimit$1,
        eachOf: eachOf,
        eachOfLimit: eachOfLimit,
        eachOfSeries: eachOfSeries,
        eachSeries: eachSeries,
        ensureAsync: ensureAsync,
        every: every,
        everyLimit: everyLimit,
        everySeries: everySeries,
        filter: filter,
        filterLimit: filterLimit,
        filterSeries: filterSeries,
        forever: forever,
        log: log,
        map: map,
        mapLimit: mapLimit,
        mapSeries: mapSeries,
        mapValues: mapValues,
        mapValuesLimit: mapValuesLimit,
        mapValuesSeries: mapValuesSeries,
        memoize: memoize,
        nextTick: nextTick,
        parallel: parallelLimit,
        parallelLimit: parallelLimit$1,
        priorityQueue: priorityQueue,
        queue: queue$1,
        race: race,
        reduce: reduce,
        reduceRight: reduceRight,
        reflect: reflect,
        reflectAll: reflectAll,
        reject: reject,
        rejectLimit: rejectLimit,
        rejectSeries: rejectSeries,
        retry: retry,
        retryable: retryable,
        seq: seq$1,
        series: series,
        setImmediate: setImmediate$1,
        some: some,
        someLimit: someLimit,
        someSeries: someSeries,
        sortBy: sortBy,
        timeout: timeout,
        times: times,
        timesLimit: timeLimit,
        timesSeries: timesSeries,
        transform: transform,
        unmemoize: unmemoize,
        until: until,
        waterfall: waterfall,
        whilst: whilst,
        all: every,
        any: some,
        forEach: eachLimit,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf,
        forEachOfSeries: eachOfSeries,
        forEachOfLimit: eachOfLimit,
        inject: reduce,
        foldl: reduce,
        foldr: reduceRight,
        select: filter,
        selectLimit: filterLimit,
        selectSeries: filterSeries,
        wrapSync: asyncify
    };
    exports["default"] = index, exports.applyEach = applyEach, exports.applyEachSeries = applyEachSeries, 
    exports.apply = apply$2, exports.asyncify = asyncify, exports.auto = auto, exports.autoInject = autoInject, 
    exports.cargo = cargo, exports.compose = compose, exports.concat = concat, exports.concatSeries = concatSeries, 
    exports.constant = constant, exports.detect = detect, exports.detectLimit = detectLimit, 
    exports.detectSeries = detectSeries, exports.dir = dir, exports.doDuring = doDuring, 
    exports.doUntil = doUntil, exports.doWhilst = doWhilst, exports.during = during, 
    exports.each = eachLimit, exports.eachLimit = eachLimit$1, exports.eachOf = eachOf, 
    exports.eachOfLimit = eachOfLimit, exports.eachOfSeries = eachOfSeries, exports.eachSeries = eachSeries, 
    exports.ensureAsync = ensureAsync, exports.every = every, exports.everyLimit = everyLimit, 
    exports.everySeries = everySeries, exports.filter = filter, exports.filterLimit = filterLimit, 
    exports.filterSeries = filterSeries, exports.forever = forever, exports.log = log, 
    exports.map = map, exports.mapLimit = mapLimit, exports.mapSeries = mapSeries, exports.mapValues = mapValues, 
    exports.mapValuesLimit = mapValuesLimit, exports.mapValuesSeries = mapValuesSeries, 
    exports.memoize = memoize, exports.nextTick = nextTick, exports.parallel = parallelLimit, 
    exports.parallelLimit = parallelLimit$1, exports.priorityQueue = priorityQueue, 
    exports.queue = queue$1, exports.race = race, exports.reduce = reduce, exports.reduceRight = reduceRight, 
    exports.reflect = reflect, exports.reflectAll = reflectAll, exports.reject = reject, 
    exports.rejectLimit = rejectLimit, exports.rejectSeries = rejectSeries, exports.retry = retry, 
    exports.retryable = retryable, exports.seq = seq$1, exports.series = series, exports.setImmediate = setImmediate$1, 
    exports.some = some, exports.someLimit = someLimit, exports.someSeries = someSeries, 
    exports.sortBy = sortBy, exports.timeout = timeout, exports.times = times, exports.timesLimit = timeLimit, 
    exports.timesSeries = timesSeries, exports.transform = transform, exports.unmemoize = unmemoize, 
    exports.until = until, exports.waterfall = waterfall, exports.whilst = whilst, exports.all = every, 
    exports.allLimit = everyLimit, exports.allSeries = everySeries, exports.any = some, 
    exports.anyLimit = someLimit, exports.anySeries = someSeries, exports.find = detect, 
    exports.findLimit = detectLimit, exports.findSeries = detectSeries, exports.forEach = eachLimit, 
    exports.forEachSeries = eachSeries, exports.forEachLimit = eachLimit$1, exports.forEachOf = eachOf, 
    exports.forEachOfSeries = eachOfSeries, exports.forEachOfLimit = eachOfLimit, exports.inject = reduce, 
    exports.foldl = reduce, exports.foldr = reduceRight, exports.select = filter, exports.selectLimit = filterLimit, 
    exports.selectSeries = filterSeries, exports.wrapSync = asyncify, Object.defineProperty(exports, "__esModule", {
        value: !0
    });
}), function() {
    function fillString(str) {
        var i, blockAmount = (str.length + 8 >> 6) + 1, blocks = [];
        for (i = 0; 16 * blockAmount > i; i++) blocks[i] = 0;
        for (i = 0; i < str.length; i++) blocks[i >> 2] |= str.charCodeAt(i) << 24 - 8 * (3 & i);
        return blocks[i >> 2] |= 128 << 24 - 8 * (3 & i), blocks[16 * blockAmount - 1] = 8 * str.length, 
        blocks;
    }
    function binToHex(binArray) {
        var i, hexString = "0123456789abcdef", str = "";
        for (i = 0; i < 4 * binArray.length; i++) str += hexString.charAt(binArray[i >> 2] >> 8 * (3 - i % 4) + 4 & 15) + hexString.charAt(binArray[i >> 2] >> 8 * (3 - i % 4) & 15);
        return str;
    }
    function coreFunction(blockArray) {
        var olda, oldb, oldc, oldd, olde, t, i, j, w = [], a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, e = 3285377520;
        for (i = 0; i < blockArray.length; i += 16) {
            for (olda = a, oldb = b, oldc = c, oldd = d, olde = e, j = 0; 80 > j; j++) 16 > j ? w[j] = blockArray[i + j] : w[j] = cyclicShift(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1), 
            t = modPlus(modPlus(cyclicShift(a, 5), ft(j, b, c, d)), modPlus(modPlus(e, w[j]), kt(j))), 
            e = d, d = c, c = cyclicShift(b, 30), b = a, a = t;
            a = modPlus(a, olda), b = modPlus(b, oldb), c = modPlus(c, oldc), d = modPlus(d, oldd), 
            e = modPlus(e, olde);
        }
        return [ a, b, c, d, e ];
    }
    function ft(t, b, c, d) {
        return 20 > t ? b & c | ~b & d : 40 > t ? b ^ c ^ d : 60 > t ? b & c | b & d | c & d : b ^ c ^ d;
    }
    function kt(t) {
        return 20 > t ? 1518500249 : 40 > t ? 1859775393 : 60 > t ? 2400959708 : 3395469782;
    }
    function modPlus(x, y) {
        var low = (65535 & x) + (65535 & y), high = (x >> 16) + (y >> 16) + (low >> 16);
        return high << 16 | 65535 & low;
    }
    function cyclicShift(num, k) {
        return num << k | num >>> 32 - k;
    }
    function sha1(s) {
        return binToHex(coreFunction(fillString(s)));
    }
    var root = this;
    "function" == typeof define ? define(function() {
        return sha1;
    }) : "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = sha1), 
    exports.sha1 = sha1) : root.sha1 = sha1;
}.call(this), function(angular, analytics) {
    "use strict";
    function $analytics() {
        function bufferedHandler(handlerName) {
            return function() {
                angulartics.waitForVendorCount && (cache[handlerName] || (cache[handlerName] = []), 
                cache[handlerName].push(arguments));
            };
        }
        function updateHandlers(handlerName, fn, options) {
            return handlers[handlerName] || (handlers[handlerName] = []), handlers[handlerName].push(fn), 
            handlerOptions[fn] = options, function() {
                if (!this.settings.optOut) {
                    var handlerArgs = Array.prototype.slice.apply(arguments);
                    return this.$inject([ "$q", angular.bind(this, function($q) {
                        return $q.all(handlers[handlerName].map(function(handlerFn) {
                            var options = handlerOptions[handlerFn] || {};
                            if (options.async) {
                                var deferred = $q.defer(), currentArgs = angular.copy(handlerArgs);
                                return currentArgs.unshift(deferred.resolve), handlerFn.apply(this, currentArgs), 
                                deferred.promise;
                            }
                            return $q.when(handlerFn.apply(this, handlerArgs));
                        }, this));
                    }) ]);
                }
            };
        }
        function onTimeout(fn, delay) {
            delay ? setTimeout(fn, delay) : fn();
        }
        function register(handlerName, fn, options) {
            if (!settings.developerMode) {
                api[handlerName] = updateHandlers(handlerName, fn, options);
                var handlerSettings = settings[handlerName], handlerDelay = handlerSettings ? handlerSettings.bufferFlushDelay : null, delay = null !== handlerDelay ? handlerDelay : settings.bufferFlushDelay;
                angular.forEach(cache[handlerName], function(args, index) {
                    onTimeout(function() {
                        fn.apply(this, args);
                    }, index * delay);
                });
            }
        }
        function capitalize(input) {
            return input.replace(/^./, function(match) {
                return match.toUpperCase();
            });
        }
        function installHandlerRegisterFunction(handlerName) {
            var registerName = "register" + capitalize(handlerName);
            provider[registerName] = function(fn, options) {
                register(handlerName, fn, options);
            }, api[handlerName] = updateHandlers(handlerName, bufferedHandler(handlerName));
        }
        function startRegistering(_provider, _knownHandlers, _installHandlerRegisterFunction) {
            angular.forEach(_knownHandlers, _installHandlerRegisterFunction);
            for (var key in _provider) vm[key] = _provider[key];
        }
        var vm = this, settings = {
            pageTracking: {
                autoTrackFirstPage: !0,
                autoTrackVirtualPages: !0,
                trackRelativePath: !1,
                trackRoutes: !0,
                trackStates: !0,
                autoBasePath: !1,
                basePath: "",
                excludedRoutes: [],
                queryKeysWhitelisted: [],
                queryKeysBlacklisted: []
            },
            eventTracking: {},
            bufferFlushDelay: 1e3,
            trackExceptions: !1,
            optOut: !1,
            developerMode: !1
        }, knownHandlers = [ "pageTrack", "eventTrack", "exceptionTrack", "transactionTrack", "setAlias", "setUsername", "setUserProperties", "setUserPropertiesOnce", "setSuperProperties", "setSuperPropertiesOnce", "incrementProperty", "userTimings", "clearCookies" ], cache = {}, handlers = {}, handlerOptions = {}, api = {
            settings: settings
        };
        api.setOptOut = function(optOut) {
            this.settings.optOut = optOut, triggerRegister();
        }, api.getOptOut = function() {
            return this.settings.optOut;
        };
        var provider = {
            $get: [ "$injector", function($injector) {
                return apiWithInjector($injector);
            } ],
            api: api,
            settings: settings,
            virtualPageviews: function(value) {
                this.settings.pageTracking.autoTrackVirtualPages = value;
            },
            trackStates: function(value) {
                this.settings.pageTracking.trackStates = value;
            },
            trackRoutes: function(value) {
                this.settings.pageTracking.trackRoutes = value;
            },
            excludeRoutes: function(routes) {
                this.settings.pageTracking.excludedRoutes = routes;
            },
            queryKeysWhitelist: function(keys) {
                this.settings.pageTracking.queryKeysWhitelisted = keys;
            },
            queryKeysBlacklist: function(keys) {
                this.settings.pageTracking.queryKeysBlacklisted = keys;
            },
            firstPageview: function(value) {
                this.settings.pageTracking.autoTrackFirstPage = value;
            },
            withBase: function(value) {
                this.settings.pageTracking.basePath = value ? angular.element(document).find("base").attr("href") : "";
            },
            withAutoBase: function(value) {
                this.settings.pageTracking.autoBasePath = value;
            },
            trackExceptions: function(value) {
                this.settings.trackExceptions = value;
            },
            developerMode: function(value) {
                this.settings.developerMode = value;
            }
        }, apiWithInjector = function(injector) {
            return angular.extend(api, {
                $inject: injector.invoke
            });
        }, triggerRegister = function() {
            startRegistering(provider, knownHandlers, installHandlerRegisterFunction);
        };
        startRegistering(provider, knownHandlers, installHandlerRegisterFunction);
    }
    function $analyticsRun($rootScope, $window, $analytics, $injector) {
        function matchesExcludedRoute(url) {
            for (var i = 0; i < $analytics.settings.pageTracking.excludedRoutes.length; i++) {
                var excludedRoute = $analytics.settings.pageTracking.excludedRoutes[i];
                if (excludedRoute instanceof RegExp && excludedRoute.test(url) || url.indexOf(excludedRoute) > -1) return !0;
            }
            return !1;
        }
        function arrayDifference(a1, a2) {
            for (var result = [], i = 0; i < a1.length; i++) -1 === a2.indexOf(a1[i]) && result.push(a1[i]);
            return result;
        }
        function filterQueryString(url, keysMatchArr, thisType) {
            if (/\?/.test(url) && keysMatchArr.length > 0) {
                for (var urlArr = url.split("?"), urlBase = urlArr[0], pairs = urlArr[1].split("&"), matchedPairs = [], i = 0; i < keysMatchArr.length; i++) for (var listedKey = keysMatchArr[i], j = 0; j < pairs.length; j++) (listedKey instanceof RegExp && listedKey.test(pairs[j]) || pairs[j].indexOf(listedKey) > -1) && matchedPairs.push(pairs[j]);
                var matchedPairsArr = "white" == thisType ? matchedPairs : arrayDifference(pairs, matchedPairs);
                return matchedPairsArr.length > 0 ? urlBase + "?" + matchedPairsArr.join("&") : urlBase;
            }
            return url;
        }
        function whitelistQueryString(url) {
            return filterQueryString(url, $analytics.settings.pageTracking.queryKeysWhitelisted, "white");
        }
        function blacklistQueryString(url) {
            return filterQueryString(url, $analytics.settings.pageTracking.queryKeysBlacklisted, "black");
        }
        function pageTrack(url, $location) {
            matchesExcludedRoute(url) || (url = whitelistQueryString(url), url = blacklistQueryString(url), 
            $analytics.pageTrack(url, $location));
        }
        $analytics.settings.pageTracking.autoTrackFirstPage && $injector.invoke([ "$location", function($location) {
            var noRoutesOrStates = !0;
            if ($injector.has("$route")) {
                var $route = $injector.get("$route");
                if ($route) for (var route in $route.routes) {
                    noRoutesOrStates = !1;
                    break;
                } else null === $route && (noRoutesOrStates = !1);
            } else if ($injector.has("$state")) {
                var $state = $injector.get("$state");
                for (var state in $state.get()) {
                    noRoutesOrStates = !1;
                    break;
                }
            }
            if (noRoutesOrStates) if ($analytics.settings.pageTracking.autoBasePath && ($analytics.settings.pageTracking.basePath = $window.location.pathname), 
            $analytics.settings.pageTracking.trackRelativePath) {
                var url = $analytics.settings.pageTracking.basePath + $location.url();
                pageTrack(url, $location);
            } else pageTrack($location.absUrl(), $location);
        } ]), $analytics.settings.pageTracking.autoTrackVirtualPages && $injector.invoke([ "$location", function($location) {
            $analytics.settings.pageTracking.autoBasePath && ($analytics.settings.pageTracking.basePath = $window.location.pathname + "#");
            var noRoutesOrStates = !0;
            if ($analytics.settings.pageTracking.trackRoutes && $injector.has("$route")) {
                var $route = $injector.get("$route");
                if ($route) for (var route in $route.routes) {
                    noRoutesOrStates = !1;
                    break;
                } else null === $route && (noRoutesOrStates = !1);
                $rootScope.$on("$routeChangeSuccess", function(event, current) {
                    if (!current || !(current.$$route || current).redirectTo) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url();
                        pageTrack(url, $location);
                    }
                });
            }
            $analytics.settings.pageTracking.trackStates && ($injector.has("$state") && !$injector.has("$transitions") && (noRoutesOrStates = !1, 
            $rootScope.$on("$stateChangeSuccess", function(event, current) {
                var url = $analytics.settings.pageTracking.basePath + $location.url();
                pageTrack(url, $location);
            })), $injector.has("$state") && $injector.has("$transitions") && (noRoutesOrStates = !1, 
            $injector.invoke([ "$transitions", function($transitions) {
                $transitions.onSuccess({}, function($transition$) {
                    var transitionOptions = $transition$.options();
                    if (transitionOptions.notify) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url();
                        pageTrack(url, $location);
                    }
                });
            } ]))), noRoutesOrStates && $rootScope.$on("$locationChangeSuccess", function(event, current) {
                if (!current || !(current.$$route || current).redirectTo) if ($analytics.settings.pageTracking.trackRelativePath) {
                    var url = $analytics.settings.pageTracking.basePath + $location.url();
                    pageTrack(url, $location);
                } else pageTrack($location.absUrl(), $location);
            });
        } ]), $analytics.settings.developerMode && angular.forEach($analytics, function(attr, name) {
            "function" == typeof attr && ($analytics[name] = function() {});
        });
    }
    function analyticsOn($analytics) {
        return {
            restrict: "A",
            link: function($scope, $element, $attrs) {
                var eventType = $attrs.analyticsOn || "click", trackingData = {};
                angular.forEach($attrs.$attr, function(attr, name) {
                    isProperty(name) && (trackingData[propertyName(name)] = $attrs[name], $attrs.$observe(name, function(value) {
                        trackingData[propertyName(name)] = value;
                    }));
                }), angular.element($element[0]).bind(eventType, function($event) {
                    var eventName = $attrs.analyticsEvent || inferEventName($element[0]);
                    trackingData.eventType = $event.type, (!$attrs.analyticsIf || $scope.$eval($attrs.analyticsIf)) && ($attrs.analyticsProperties && angular.extend(trackingData, $scope.$eval($attrs.analyticsProperties)), 
                    $analytics.eventTrack(eventName, trackingData));
                });
            }
        };
    }
    function exceptionTrack($provide) {
        $provide.decorator("$exceptionHandler", [ "$delegate", "$injector", function($delegate, $injector) {
            return function(error, cause) {
                var result = $delegate(error, cause), $analytics = $injector.get("$analytics");
                return $analytics.settings.trackExceptions && $analytics.exceptionTrack(error, cause), 
                result;
            };
        } ]);
    }
    function isCommand(element) {
        return [ "a:", "button:", "button:button", "button:submit", "input:button", "input:submit" ].indexOf(element.tagName.toLowerCase() + ":" + (element.type || "")) >= 0;
    }
    function inferEventName(element) {
        return isCommand(element) ? element.innerText || element.value : element.id || element.name || element.tagName;
    }
    function isProperty(name) {
        return "analytics" === name.substr(0, 9) && -1 === [ "On", "Event", "If", "Properties", "EventType" ].indexOf(name.substr(9));
    }
    function propertyName(name) {
        var s = name.slice(9);
        return "undefined" != typeof s && null !== s && s.length > 0 ? s.substring(0, 1).toLowerCase() + s.substring(1) : s;
    }
    var angulartics = window.angulartics || (window.angulartics = {});
    angulartics.waitForVendorCount = 0, angulartics.waitForVendorApi = function(objectName, delay, containsField, registerFn, onTimeout) {
        onTimeout || angulartics.waitForVendorCount++, registerFn || (registerFn = containsField, 
        containsField = void 0), !Object.prototype.hasOwnProperty.call(window, objectName) || void 0 !== containsField && void 0 === window[objectName][containsField] ? setTimeout(function() {
            angulartics.waitForVendorApi(objectName, delay, containsField, registerFn, !0);
        }, delay) : (angulartics.waitForVendorCount--, registerFn(window[objectName]));
    }, angular.module("angulartics", []).provider("$analytics", $analytics).run([ "$rootScope", "$window", "$analytics", "$injector", $analyticsRun ]).directive("analyticsOn", [ "$analytics", analyticsOn ]).config([ "$provide", exceptionTrack ]);
}(angular), function(window, angular, undefined) {
    "use strict";
    angular.module("angulartics.google.analytics", [ "angulartics" ]).config([ "$analyticsProvider", function($analyticsProvider) {
        function detectUniversalAnalytics() {
            var gaNamespace = window.GoogleAnalyticsObject;
            return gaNamespace && window[gaNamespace];
        }
        function detectClassicAnalytics() {
            return !angular.isUndefined(window._gaq);
        }
        function dimensionsAndMetrics(properties) {
            var key, customData = {};
            for (key in properties) key.indexOf("dimension") && key.indexOf("metric") || (customData[key] = properties[key]);
            return customData;
        }
        $analyticsProvider.settings.pageTracking.trackRelativePath = !0, $analyticsProvider.settings.ga = {
            additionalAccountNames: undefined,
            additionalAccountHitTypes: {
                pageview: !0,
                event: !0,
                exception: !1,
                ecommerce: !1,
                userTiming: !1,
                setUserProperties: !1,
                userId: !1
            },
            disableEventTracking: null,
            disablePageTracking: null,
            enhancedEcommerce: !1,
            transport: null,
            userId: null
        }, $analyticsProvider.registerPageTrack(function(path, properties) {
            properties = properties || {}, $analyticsProvider.settings.ga.disablePageTracking || dispatchToGa("pageview", "send", angular.extend({}, properties, {
                hitType: "pageview",
                page: path
            }));
        }), $analyticsProvider.registerEventTrack(function(action, properties) {
            if (!$analyticsProvider.settings.ga.disableEventTracking && (action || action + "" == "0")) {
                if (properties = properties || {}, properties.category = properties.category || "Event", 
                properties.value) {
                    var parsed = parseInt(properties.value, 10);
                    properties.value = isNaN(parsed) ? 0 : parsed;
                }
                angular.isFunction(properties.hitCallback) || (properties.hitCallback = null), properties.nonInteraction = properties.nonInteraction || properties.noninteraction, 
                dispatchToGa("event", "send", angular.extend({}, properties, {
                    hitType: "event",
                    eventCategory: properties.category,
                    eventAction: action,
                    eventLabel: properties.label,
                    eventValue: properties.value,
                    nonInteraction: properties.nonInteraction,
                    page: properties.page || window.location.hash.substring(1) || window.location.pathname,
                    hitCallback: properties.hitCallback
                }));
            }
        }), $analyticsProvider.registerExceptionTrack(function(error, cause) {
            dispatchToGa("exception", "send", {
                hitType: "event",
                eventCategory: "Exceptions",
                eventAction: error.toString(),
                eventLabel: error.stack,
                nonInteraction: !0,
                page: window.location.hash.substring(1) || window.location.pathname,
                isException: !0
            });
        }), $analyticsProvider.registerSetUsername(function(userId) {
            $analyticsProvider.settings.ga.userId = userId;
        }), $analyticsProvider.registerSetUserProperties(function(properties) {
            properties && dispatchToGa("setUserProperties", "set", dimensionsAndMetrics(properties));
        }), $analyticsProvider.registerUserTimings(function(properties) {
            return !angular.isObject(properties) || angular.isArray(properties) ? console.log("Required argument properties is missing or not an object") : (angular.forEach([ "timingCategory", "timingVar", "timingValue" ], function(prop) {
                return angular.isUndefined(properties[prop]) ? console.log("Argument properties missing required property " + prop) : void 0;
            }), void dispatchToGa("userTiming", "send", {
                hitType: "timing",
                timingCategory: properties.timingCategory,
                timingVar: properties.timingVar,
                timingValue: properties.timingValue,
                timingLabel: properties.timingLabel,
                optSampleRate: properties.optSampleRate,
                page: properties.page || window.location.hash.substring(1) || window.location.pathname
            }));
        }), $analyticsProvider.registerTransactionTrack(function(transaction) {
            var product, i;
            if (dispatchToGa("ecommerce", "require", "ecommerce"), dispatchToGa("ecommerce", "ecommerce:addTransaction", transaction), 
            transaction.products) for (i = 0; i < transaction.products.length; i++) product = transaction.products[i], 
            product.sku = product.id, product.id = transaction.id, dispatchToGa("ecommerce", "ecommerce:addItem", transaction.products[i]);
            transaction.currencyCode && dispatchToGa("ecommerce", "_set", transaction.currencyCode), 
            dispatchToGa("ecommerce", "ecommerce:send", angular.copy(transaction));
        });
        var dispatchToGa = function() {
            function dispatchToUniversal_(command, fieldsObj, shouldCopyHit) {
                var uaCommand, pluginName, userId = $analyticsProvider.settings.ga.userId;
                if ("require" === command && "ecommerce" === fieldsObj) return pluginName = fieldsObj, 
                $analyticsProvider.settings.ga.enhancedEcommerce && (pluginName = "ec"), applyUniversalCall_([ command, pluginName ], shouldCopyHit);
                if (userId && angular.isObject(fieldsObj) && (fieldsObj.userId = userId), $analyticsProvider.settings.ga.transport && (fieldsObj.transport = $analyticsProvider.settings.ga.transport), 
                command.indexOf("ecommerce:") > -1 && $analyticsProvider.settings.ga.enhancedEcommerce) switch (command) {
                  case "ecommerce:addTransaction":
                    command = [ "ec:setAction", "purchase" ];
                    break;

                  case "ecommerce:addItem":
                    command = "ec:addProduct", fieldsObj.id = fieldsObj.sku;
                    break;

                  case "ecommerce:send":
                    command = "send", fieldsObj.hitType = "event", fieldsObj.eventCategory = "Angulartics Enhanced Ecommerce", 
                    fieldsObj.eventAction = "Purchase", fieldsObj.nonInteraction = !0;
                }
                uaCommand = command instanceof Array ? command.concat(fieldsObj) : [ command, fieldsObj ], 
                applyUniversalCall_(uaCommand, shouldCopyHit);
            }
            function applyUniversalCall_(commandArray, shouldCopyHit) {
                var commandClone, userId = $analyticsProvider.settings.ga.userId, gaNamespace = window.GoogleAnalyticsObject;
                window[gaNamespace].apply(this, commandArray), shouldCopyHit && (commandClone = angular.copy(commandArray), 
                userId && !$analyticsProvider.settings.ga.additionalAccountHitTypes.userId && commandClone[2] && "object" == typeof commandClone[2] && delete commandClone[2].userId, 
                angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function(accountName) {
                    commandClone[0] = accountName + "." + commandClone[0], window[gaNamespace].apply(this, commandClone);
                }));
            }
            function dispatchToClassic_(command, fieldsObj, shouldCopyHit) {
                if ("set" === command) return console.log('Classic Analytics does not support the "set" command or Custom Dimensions. Command ignored.');
                var classicCommand;
                if ("send" === command) switch (fieldsObj.hitType) {
                  case "pageview":
                    classicCommand = [ "_trackPageview", fieldsObj.page ];
                    break;

                  case "event":
                    classicCommand = [ "_trackEvent", fieldsObj.category, fieldsObj.action, fieldsObj.label, fieldsObj.value, fieldsObj.nonInteraction ];
                    break;

                  case "timing":
                    classicCommand = [ "_trackTiming", fieldsObj.timingCategory, fieldsObj.timingVar, fieldsObj.timingValue, fieldsObj.timingLabel, fieldsObj.optSampleRate ];
                }
                return "ecommerce:addTransaction" === command && (classicCommand = [ "_addTrans", fieldsObj.id, fieldsObj.affiliation, fieldsObj.revenue, fieldsObj.tax, fieldsObj.shipping, fieldsObj.billingCity, fieldsObj.billingRegion, fieldsObj.billingCountry ]), 
                "ecommerce:addItem" === command && (classicCommand = [ "_addItem", fieldsObj.id, fieldsObj.sku, fieldsObj.name, fieldsObj.category, fieldsObj.price, fieldsObj.quantity ]), 
                "_set" === command && (classicCommand = [ "_set", "currencyCode", fieldsObj ]), 
                "ecommerce:send" === command && (classicCommand = [ "_trackTrans" ]), classicCommand ? (window._gaq.push(classicCommand), 
                void (shouldCopyHit && angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function(accountName) {
                    var classicCommandClone = [].slice.call(classicCommand);
                    classicCommandClone[0] = accountName + "." + classicCommandClone[0], window._gaq.push(classicCommandClone);
                }))) : console.log("Unable to find command " + command + " or fieldsObj missing required properties. Command ignored.");
            }
            var handler;
            return detectClassicAnalytics() && (handler = dispatchToClassic_), detectUniversalAnalytics() && (handler = dispatchToUniversal_), 
            handler ? function(method, command, fieldsObj) {
                var shouldCopyHit = $analyticsProvider.settings.ga.additionalAccountHitTypes[method];
                handler(command, fieldsObj, shouldCopyHit);
            } : angular.noop;
        }();
    } ]);
}(window, window.angular);